"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/frappe-react-sdk";
exports.ids = ["vendor-chunks/frappe-react-sdk"];
exports.modules = {

/***/ "(ssr)/./node_modules/frappe-react-sdk/dist/frappe-react-sdk.es.js":
/*!*******************************************************************!*\
  !*** ./node_modules/frappe-react-sdk/dist/frappe-react-sdk.es.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FrappeContext: () => (/* binding */ te),\n/* harmony export */   FrappeProvider: () => (/* binding */ Ua),\n/* harmony export */   getDocListQueryString: () => (/* binding */ La),\n/* harmony export */   getRequestURL: () => (/* binding */ Bs),\n/* harmony export */   useFrappeAuth: () => (/* binding */ qa),\n/* harmony export */   useFrappeCreateDoc: () => (/* binding */ ja),\n/* harmony export */   useFrappeDeleteCall: () => (/* binding */ Ya),\n/* harmony export */   useFrappeDeleteDoc: () => (/* binding */ Ma),\n/* harmony export */   useFrappeDocTypeEventListener: () => (/* binding */ Xa),\n/* harmony export */   useFrappeDocumentEventListener: () => (/* binding */ Ga),\n/* harmony export */   useFrappeEventListener: () => (/* binding */ Bn),\n/* harmony export */   useFrappeFileUpload: () => (/* binding */ za),\n/* harmony export */   useFrappeGetCall: () => (/* binding */ Na),\n/* harmony export */   useFrappeGetDoc: () => (/* binding */ Ia),\n/* harmony export */   useFrappeGetDocCount: () => (/* binding */ Wa),\n/* harmony export */   useFrappeGetDocList: () => (/* binding */ Va),\n/* harmony export */   useFrappePostCall: () => (/* binding */ Ha),\n/* harmony export */   useFrappePutCall: () => (/* binding */ Ja),\n/* harmony export */   useFrappeUpdateDoc: () => (/* binding */ $a),\n/* harmony export */   useSWR: () => (/* binding */ vt),\n/* harmony export */   useSWRConfig: () => (/* binding */ No),\n/* harmony export */   useSearch: () => (/* binding */ Ka)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar Qs = Object.defineProperty;\nvar Zs = (n, e, t) => e in n ? Qs(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;\nvar xe = (n, e, t) => (Zs(n, typeof e != \"symbol\" ? e + \"\" : e, t), t);\n\nvar B = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {}, zt = {}, rt = {}, ft = {}, fe = B && B.__assign || function() {\n  return fe = Object.assign || function(n) {\n    for (var e, t = 1, r = arguments.length; t < r; t++) {\n      e = arguments[t];\n      for (var s in e)\n        Object.prototype.hasOwnProperty.call(e, s) && (n[s] = e[s]);\n    }\n    return n;\n  }, fe.apply(this, arguments);\n}, wt = B && B.__awaiter || function(n, e, t, r) {\n  function s(i) {\n    return i instanceof t ? i : new t(function(o) {\n      o(i);\n    });\n  }\n  return new (t || (t = Promise))(function(i, o) {\n    function u(h) {\n      try {\n        a(r.next(h));\n      } catch (f) {\n        o(f);\n      }\n    }\n    function l(h) {\n      try {\n        a(r.throw(h));\n      } catch (f) {\n        o(f);\n      }\n    }\n    function a(h) {\n      h.done ? i(h.value) : s(h.value).then(u, l);\n    }\n    a((r = r.apply(n, e || [])).next());\n  });\n}, Et = B && B.__generator || function(n, e) {\n  var t = { label: 0, sent: function() {\n    if (i[0] & 1)\n      throw i[1];\n    return i[1];\n  }, trys: [], ops: [] }, r, s, i, o;\n  return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == \"function\" && (o[Symbol.iterator] = function() {\n    return this;\n  }), o;\n  function u(a) {\n    return function(h) {\n      return l([a, h]);\n    };\n  }\n  function l(a) {\n    if (r)\n      throw new TypeError(\"Generator is already executing.\");\n    for (; t; )\n      try {\n        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)\n          return i;\n        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {\n          case 0:\n          case 1:\n            i = a;\n            break;\n          case 4:\n            return t.label++, { value: a[1], done: !1 };\n          case 5:\n            t.label++, s = a[1], a = [0];\n            continue;\n          case 7:\n            a = t.ops.pop(), t.trys.pop();\n            continue;\n          default:\n            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {\n              t = 0;\n              continue;\n            }\n            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {\n              t.label = a[1];\n              break;\n            }\n            if (a[0] === 6 && t.label < i[1]) {\n              t.label = i[1], i = a;\n              break;\n            }\n            if (i && t.label < i[2]) {\n              t.label = i[2], t.ops.push(a);\n              break;\n            }\n            i[2] && t.ops.pop(), t.trys.pop();\n            continue;\n        }\n        a = e.call(n, t);\n      } catch (h) {\n        a = [6, h], s = 0;\n      } finally {\n        r = i = 0;\n      }\n    if (a[0] & 5)\n      throw a[1];\n    return { value: a[0] ? a[1] : void 0, done: !0 };\n  }\n};\nObject.defineProperty(ft, \"__esModule\", { value: !0 });\nft.FrappeCall = void 0;\nvar ni = function() {\n  function n(e, t, r, s, i) {\n    this.appURL = e, this.axios = t, this.useToken = r != null ? r : !1, this.token = s, this.tokenType = i;\n  }\n  return n.prototype.get = function(e, t) {\n    return wt(this, void 0, void 0, function() {\n      return Et(this, function(r) {\n        return [2, this.axios.get(\"/api/method/\".concat(e), { params: t }).then(function(s) {\n          return s.data;\n        }).catch(function(s) {\n          var i, o;\n          throw fe(fe({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : \"There was an error.\", exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : \"\" });\n        })];\n      });\n    });\n  }, n.prototype.post = function(e, t) {\n    return wt(this, void 0, void 0, function() {\n      return Et(this, function(r) {\n        return [2, this.axios.post(\"/api/method/\".concat(e), fe({}, t)).then(function(s) {\n          return s.data;\n        }).catch(function(s) {\n          var i, o;\n          throw fe(fe({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : \"There was an error.\", exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : \"\" });\n        })];\n      });\n    });\n  }, n.prototype.put = function(e, t) {\n    return wt(this, void 0, void 0, function() {\n      return Et(this, function(r) {\n        return [2, this.axios.put(\"/api/method/\".concat(e), fe({}, t)).then(function(s) {\n          return s.data;\n        }).catch(function(s) {\n          var i, o;\n          throw fe(fe({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : \"There was an error.\", exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : \"\" });\n        })];\n      });\n    });\n  }, n.prototype.delete = function(e, t) {\n    return wt(this, void 0, void 0, function() {\n      return Et(this, function(r) {\n        return [2, this.axios.delete(\"/api/method/\".concat(e), { params: t }).then(function(s) {\n          return s.data;\n        }).catch(function(s) {\n          var i, o;\n          throw fe(fe({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : \"There was an error.\", exception: (o = s.response.data.exception) !== null && o !== void 0 ? o : \"\" });\n        })];\n      });\n    });\n  }, n;\n}();\nft.FrappeCall = ni;\nvar ht = {}, z = B && B.__assign || function() {\n  return z = Object.assign || function(n) {\n    for (var e, t = 1, r = arguments.length; t < r; t++) {\n      e = arguments[t];\n      for (var s in e)\n        Object.prototype.hasOwnProperty.call(e, s) && (n[s] = e[s]);\n    }\n    return n;\n  }, z.apply(this, arguments);\n}, Fe = B && B.__awaiter || function(n, e, t, r) {\n  function s(i) {\n    return i instanceof t ? i : new t(function(o) {\n      o(i);\n    });\n  }\n  return new (t || (t = Promise))(function(i, o) {\n    function u(h) {\n      try {\n        a(r.next(h));\n      } catch (f) {\n        o(f);\n      }\n    }\n    function l(h) {\n      try {\n        a(r.throw(h));\n      } catch (f) {\n        o(f);\n      }\n    }\n    function a(h) {\n      h.done ? i(h.value) : s(h.value).then(u, l);\n    }\n    a((r = r.apply(n, e || [])).next());\n  });\n}, Ue = B && B.__generator || function(n, e) {\n  var t = { label: 0, sent: function() {\n    if (i[0] & 1)\n      throw i[1];\n    return i[1];\n  }, trys: [], ops: [] }, r, s, i, o;\n  return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == \"function\" && (o[Symbol.iterator] = function() {\n    return this;\n  }), o;\n  function u(a) {\n    return function(h) {\n      return l([a, h]);\n    };\n  }\n  function l(a) {\n    if (r)\n      throw new TypeError(\"Generator is already executing.\");\n    for (; t; )\n      try {\n        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)\n          return i;\n        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {\n          case 0:\n          case 1:\n            i = a;\n            break;\n          case 4:\n            return t.label++, { value: a[1], done: !1 };\n          case 5:\n            t.label++, s = a[1], a = [0];\n            continue;\n          case 7:\n            a = t.ops.pop(), t.trys.pop();\n            continue;\n          default:\n            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {\n              t = 0;\n              continue;\n            }\n            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {\n              t.label = a[1];\n              break;\n            }\n            if (a[0] === 6 && t.label < i[1]) {\n              t.label = i[1], i = a;\n              break;\n            }\n            if (i && t.label < i[2]) {\n              t.label = i[2], t.ops.push(a);\n              break;\n            }\n            i[2] && t.ops.pop(), t.trys.pop();\n            continue;\n        }\n        a = e.call(n, t);\n      } catch (h) {\n        a = [6, h], s = 0;\n      } finally {\n        r = i = 0;\n      }\n    if (a[0] & 5)\n      throw a[1];\n    return { value: a[0] ? a[1] : void 0, done: !0 };\n  }\n};\nObject.defineProperty(ht, \"__esModule\", { value: !0 });\nht.FrappeDB = void 0;\nvar ri = function() {\n  function n(e, t, r, s, i) {\n    this.appURL = e, this.axios = t, this.useToken = r != null ? r : !1, this.token = s, this.tokenType = i;\n  }\n  return n.prototype.getDoc = function(e, t) {\n    return t === void 0 && (t = \"\"), Fe(this, void 0, void 0, function() {\n      return Ue(this, function(r) {\n        return [2, this.axios.get(\"/api/resource/\".concat(e, \"/\").concat(t)).then(function(s) {\n          return s.data.data;\n        }).catch(function(s) {\n          var i, o;\n          throw z(z({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: \"There was an error while fetching the document.\", exception: (o = (i = s.response.data.exception) !== null && i !== void 0 ? i : s.response.data.exc_type) !== null && o !== void 0 ? o : \"\" });\n        })];\n      });\n    });\n  }, n.prototype.getDocList = function(e, t) {\n    var r;\n    return Fe(this, void 0, void 0, function() {\n      var s, i, o, u, l, a, h, f, p, m, g;\n      return Ue(this, function(b) {\n        return s = {}, t && (i = t.fields, o = t.filters, u = t.orFilters, l = t.orderBy, a = t.limit, h = t.limit_start, f = t.groupBy, p = t.asDict, m = p === void 0 ? !0 : p, g = l ? \"\".concat(String(l == null ? void 0 : l.field), \" \").concat((r = l == null ? void 0 : l.order) !== null && r !== void 0 ? r : \"asc\") : \"\", s = {\n          fields: i ? JSON.stringify(i) : void 0,\n          filters: o ? JSON.stringify(o) : void 0,\n          or_filters: u ? JSON.stringify(u) : void 0,\n          order_by: g,\n          group_by: f,\n          limit: a,\n          limit_start: h,\n          as_dict: m\n        }), [2, this.axios.get(\"/api/resource/\".concat(e), { params: s }).then(function(E) {\n          return E.data.data;\n        }).catch(function(E) {\n          var _, S;\n          throw z(z({}, E.response.data), { httpStatus: E.response.status, httpStatusText: E.response.statusText, message: \"There was an error while fetching the documents.\", exception: (S = (_ = E.response.data.exception) !== null && _ !== void 0 ? _ : E.response.data.exc_type) !== null && S !== void 0 ? S : \"\" });\n        })];\n      });\n    });\n  }, n.prototype.createDoc = function(e, t) {\n    return Fe(this, void 0, void 0, function() {\n      return Ue(this, function(r) {\n        return [2, this.axios.post(\"/api/resource/\".concat(e), z({}, t)).then(function(s) {\n          return s.data.data;\n        }).catch(function(s) {\n          var i, o, u;\n          throw z(z({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: (i = s.response.data.message) !== null && i !== void 0 ? i : \"There was an error while creating the document.\", exception: (u = (o = s.response.data.exception) !== null && o !== void 0 ? o : s.response.data.exc_type) !== null && u !== void 0 ? u : \"\" });\n        })];\n      });\n    });\n  }, n.prototype.updateDoc = function(e, t, r) {\n    return Fe(this, void 0, void 0, function() {\n      return Ue(this, function(s) {\n        return [2, this.axios.put(\"/api/resource/\".concat(e, \"/\").concat(t), z({}, r)).then(function(i) {\n          return i.data.data;\n        }).catch(function(i) {\n          var o, u, l;\n          throw z(z({}, i.response.data), { httpStatus: i.response.status, httpStatusText: i.response.statusText, message: (o = i.response.data.message) !== null && o !== void 0 ? o : \"There was an error while updating the document.\", exception: (l = (u = i.response.data.exception) !== null && u !== void 0 ? u : i.response.data.exc_type) !== null && l !== void 0 ? l : \"\" });\n        })];\n      });\n    });\n  }, n.prototype.deleteDoc = function(e, t) {\n    return Fe(this, void 0, void 0, function() {\n      return Ue(this, function(r) {\n        return [2, this.axios.delete(\"/api/resource/\".concat(e, \"/\").concat(t)).then(function(s) {\n          return s.data;\n        }).catch(function(s) {\n          var i, o;\n          throw z(z({}, s.response.data), { httpStatus: s.response.status, httpStatusText: s.response.statusText, message: \"There was an error while deleting the document.\", exception: (o = (i = s.response.data.exception) !== null && i !== void 0 ? i : s.response.data.exc_type) !== null && o !== void 0 ? o : \"\" });\n        })];\n      });\n    });\n  }, n.prototype.getCount = function(e, t, r, s) {\n    return r === void 0 && (r = !1), s === void 0 && (s = !1), Fe(this, void 0, void 0, function() {\n      var i;\n      return Ue(this, function(o) {\n        return i = {\n          doctype: e,\n          filters: []\n        }, r && (i.cache = r), s && (i.debug = s), t && (i.filters = t ? JSON.stringify(t) : void 0), [2, this.axios.get(\"/api/method/frappe.client.get_count\", { params: i }).then(function(u) {\n          return u.data.message;\n        }).catch(function(u) {\n          var l, a;\n          throw z(z({}, u.response.data), { httpStatus: u.response.status, httpStatusText: u.response.statusText, message: \"There was an error while getting the count.\", exception: (a = (l = u.response.data.exception) !== null && l !== void 0 ? l : u.response.data.exc_type) !== null && a !== void 0 ? a : \"\" });\n        })];\n      });\n    });\n  }, n.prototype.getLastDoc = function(e, t) {\n    return Fe(this, void 0, void 0, function() {\n      var r, s;\n      return Ue(this, function(i) {\n        switch (i.label) {\n          case 0:\n            return r = {\n              orderBy: {\n                field: \"creation\",\n                order: \"desc\"\n              }\n            }, t && (r = z(z({}, r), t)), [4, this.getDocList(e, z(z({}, r), { limit: 1, fields: [\"name\"] }))];\n          case 1:\n            return s = i.sent(), s.length > 0 ? [2, this.getDoc(e, s[0].name)] : [2, {}];\n        }\n      });\n    });\n  }, n;\n}();\nht.FrappeDB = ri;\nvar dt = {}, Ft = B && B.__assign || function() {\n  return Ft = Object.assign || function(n) {\n    for (var e, t = 1, r = arguments.length; t < r; t++) {\n      e = arguments[t];\n      for (var s in e)\n        Object.prototype.hasOwnProperty.call(e, s) && (n[s] = e[s]);\n    }\n    return n;\n  }, Ft.apply(this, arguments);\n}, si = B && B.__awaiter || function(n, e, t, r) {\n  function s(i) {\n    return i instanceof t ? i : new t(function(o) {\n      o(i);\n    });\n  }\n  return new (t || (t = Promise))(function(i, o) {\n    function u(h) {\n      try {\n        a(r.next(h));\n      } catch (f) {\n        o(f);\n      }\n    }\n    function l(h) {\n      try {\n        a(r.throw(h));\n      } catch (f) {\n        o(f);\n      }\n    }\n    function a(h) {\n      h.done ? i(h.value) : s(h.value).then(u, l);\n    }\n    a((r = r.apply(n, e || [])).next());\n  });\n}, ii = B && B.__generator || function(n, e) {\n  var t = { label: 0, sent: function() {\n    if (i[0] & 1)\n      throw i[1];\n    return i[1];\n  }, trys: [], ops: [] }, r, s, i, o;\n  return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == \"function\" && (o[Symbol.iterator] = function() {\n    return this;\n  }), o;\n  function u(a) {\n    return function(h) {\n      return l([a, h]);\n    };\n  }\n  function l(a) {\n    if (r)\n      throw new TypeError(\"Generator is already executing.\");\n    for (; t; )\n      try {\n        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)\n          return i;\n        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {\n          case 0:\n          case 1:\n            i = a;\n            break;\n          case 4:\n            return t.label++, { value: a[1], done: !1 };\n          case 5:\n            t.label++, s = a[1], a = [0];\n            continue;\n          case 7:\n            a = t.ops.pop(), t.trys.pop();\n            continue;\n          default:\n            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {\n              t = 0;\n              continue;\n            }\n            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {\n              t.label = a[1];\n              break;\n            }\n            if (a[0] === 6 && t.label < i[1]) {\n              t.label = i[1], i = a;\n              break;\n            }\n            if (i && t.label < i[2]) {\n              t.label = i[2], t.ops.push(a);\n              break;\n            }\n            i[2] && t.ops.pop(), t.trys.pop();\n            continue;\n        }\n        a = e.call(n, t);\n      } catch (h) {\n        a = [6, h], s = 0;\n      } finally {\n        r = i = 0;\n      }\n    if (a[0] & 5)\n      throw a[1];\n    return { value: a[0] ? a[1] : void 0, done: !0 };\n  }\n};\nObject.defineProperty(dt, \"__esModule\", { value: !0 });\ndt.FrappeFileUpload = void 0;\nvar oi = function() {\n  function n(e, t, r, s, i) {\n    this.appURL = e, this.axios = t, this.useToken = r != null ? r : !1, this.token = s, this.tokenType = i;\n  }\n  return n.prototype.uploadFile = function(e, t, r, s) {\n    return s === void 0 && (s = \"upload_file\"), si(this, void 0, void 0, function() {\n      var i, o, u, l, a, h, f, p;\n      return ii(this, function(m) {\n        return i = new FormData(), e && i.append(\"file\", e, e.name), o = t.isPrivate, u = t.folder, l = t.file_url, a = t.doctype, h = t.docname, f = t.fieldname, p = t.otherData, o && i.append(\"is_private\", \"1\"), u && i.append(\"folder\", u), l && i.append(\"file_url\", l), a && h && (i.append(\"doctype\", a), i.append(\"docname\", h), f && i.append(\"fieldname\", f)), p && Object.keys(p).forEach(function(g) {\n          var b = p[g];\n          i.append(g, b);\n        }), [2, this.axios.post(\"/api/method/\".concat(s), i, {\n          onUploadProgress: function(g) {\n            r && r(g.loaded, g.total);\n          }\n        }).catch(function(g) {\n          var b, E;\n          throw Ft(Ft({}, g.response.data), { httpStatus: g.response.status, httpStatusText: g.response.statusText, message: (b = g.response.data.message) !== null && b !== void 0 ? b : \"There was an error while uploading the file.\", exception: (E = g.response.data.exception) !== null && E !== void 0 ? E : \"\" });\n        })];\n      });\n    });\n  }, n;\n}();\ndt.FrappeFileUpload = oi;\nvar Ke = {}, Gr = { exports: {} }, Fn = { exports: {} }, Xr = function(e, t) {\n  return function() {\n    for (var s = new Array(arguments.length), i = 0; i < s.length; i++)\n      s[i] = arguments[i];\n    return e.apply(t, s);\n  };\n}, ai = Xr, ke = Object.prototype.toString;\nfunction Un(n) {\n  return Array.isArray(n);\n}\nfunction En(n) {\n  return typeof n > \"u\";\n}\nfunction ui(n) {\n  return n !== null && !En(n) && n.constructor !== null && !En(n.constructor) && typeof n.constructor.isBuffer == \"function\" && n.constructor.isBuffer(n);\n}\nfunction Qr(n) {\n  return ke.call(n) === \"[object ArrayBuffer]\";\n}\nfunction ci(n) {\n  return ke.call(n) === \"[object FormData]\";\n}\nfunction li(n) {\n  var e;\n  return typeof ArrayBuffer < \"u\" && ArrayBuffer.isView ? e = ArrayBuffer.isView(n) : e = n && n.buffer && Qr(n.buffer), e;\n}\nfunction fi(n) {\n  return typeof n == \"string\";\n}\nfunction hi(n) {\n  return typeof n == \"number\";\n}\nfunction Zr(n) {\n  return n !== null && typeof n == \"object\";\n}\nfunction kt(n) {\n  if (ke.call(n) !== \"[object Object]\")\n    return !1;\n  var e = Object.getPrototypeOf(n);\n  return e === null || e === Object.prototype;\n}\nfunction di(n) {\n  return ke.call(n) === \"[object Date]\";\n}\nfunction pi(n) {\n  return ke.call(n) === \"[object File]\";\n}\nfunction vi(n) {\n  return ke.call(n) === \"[object Blob]\";\n}\nfunction es(n) {\n  return ke.call(n) === \"[object Function]\";\n}\nfunction yi(n) {\n  return Zr(n) && es(n.pipe);\n}\nfunction mi(n) {\n  return ke.call(n) === \"[object URLSearchParams]\";\n}\nfunction gi(n) {\n  return n.trim ? n.trim() : n.replace(/^\\s+|\\s+$/g, \"\");\n}\nfunction _i() {\n  return typeof navigator < \"u\" && (navigator.product === \"ReactNative\" || navigator.product === \"NativeScript\" || navigator.product === \"NS\") ? !1 : typeof window < \"u\" && typeof document < \"u\";\n}\nfunction qn(n, e) {\n  if (!(n === null || typeof n > \"u\"))\n    if (typeof n != \"object\" && (n = [n]), Un(n))\n      for (var t = 0, r = n.length; t < r; t++)\n        e.call(null, n[t], t, n);\n    else\n      for (var s in n)\n        Object.prototype.hasOwnProperty.call(n, s) && e.call(null, n[s], s, n);\n}\nfunction Rn() {\n  var n = {};\n  function e(s, i) {\n    kt(n[i]) && kt(s) ? n[i] = Rn(n[i], s) : kt(s) ? n[i] = Rn({}, s) : Un(s) ? n[i] = s.slice() : n[i] = s;\n  }\n  for (var t = 0, r = arguments.length; t < r; t++)\n    qn(arguments[t], e);\n  return n;\n}\nfunction bi(n, e, t) {\n  return qn(e, function(s, i) {\n    t && typeof s == \"function\" ? n[i] = ai(s, t) : n[i] = s;\n  }), n;\n}\nfunction wi(n) {\n  return n.charCodeAt(0) === 65279 && (n = n.slice(1)), n;\n}\nvar ae = {\n  isArray: Un,\n  isArrayBuffer: Qr,\n  isBuffer: ui,\n  isFormData: ci,\n  isArrayBufferView: li,\n  isString: fi,\n  isNumber: hi,\n  isObject: Zr,\n  isPlainObject: kt,\n  isUndefined: En,\n  isDate: di,\n  isFile: pi,\n  isBlob: vi,\n  isFunction: es,\n  isStream: yi,\n  isURLSearchParams: mi,\n  isStandardBrowserEnv: _i,\n  forEach: qn,\n  merge: Rn,\n  extend: bi,\n  trim: gi,\n  stripBOM: wi\n}, Ye = ae;\nfunction sr(n) {\n  return encodeURIComponent(n).replace(/%3A/gi, \":\").replace(/%24/g, \"$\").replace(/%2C/gi, \",\").replace(/%20/g, \"+\").replace(/%5B/gi, \"[\").replace(/%5D/gi, \"]\");\n}\nvar ts = function(e, t, r) {\n  if (!t)\n    return e;\n  var s;\n  if (r)\n    s = r(t);\n  else if (Ye.isURLSearchParams(t))\n    s = t.toString();\n  else {\n    var i = [];\n    Ye.forEach(t, function(l, a) {\n      l === null || typeof l > \"u\" || (Ye.isArray(l) ? a = a + \"[]\" : l = [l], Ye.forEach(l, function(f) {\n        Ye.isDate(f) ? f = f.toISOString() : Ye.isObject(f) && (f = JSON.stringify(f)), i.push(sr(a) + \"=\" + sr(f));\n      }));\n    }), s = i.join(\"&\");\n  }\n  if (s) {\n    var o = e.indexOf(\"#\");\n    o !== -1 && (e = e.slice(0, o)), e += (e.indexOf(\"?\") === -1 ? \"?\" : \"&\") + s;\n  }\n  return e;\n}, Ei = ae;\nfunction Ut() {\n  this.handlers = [];\n}\nUt.prototype.use = function(e, t, r) {\n  return this.handlers.push({\n    fulfilled: e,\n    rejected: t,\n    synchronous: r ? r.synchronous : !1,\n    runWhen: r ? r.runWhen : null\n  }), this.handlers.length - 1;\n};\nUt.prototype.eject = function(e) {\n  this.handlers[e] && (this.handlers[e] = null);\n};\nUt.prototype.forEach = function(e) {\n  Ei.forEach(this.handlers, function(r) {\n    r !== null && e(r);\n  });\n};\nvar Ri = Ut, Si = ae, Ti = function(e, t) {\n  Si.forEach(e, function(s, i) {\n    i !== t && i.toUpperCase() === t.toUpperCase() && (e[t] = s, delete e[i]);\n  });\n}, ns = function(e, t, r, s, i) {\n  return e.config = t, r && (e.code = r), e.request = s, e.response = i, e.isAxiosError = !0, e.toJSON = function() {\n    return {\n      message: this.message,\n      name: this.name,\n      description: this.description,\n      number: this.number,\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      config: this.config,\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  }, e;\n}, rs = {\n  silentJSONParsing: !0,\n  forcedJSONParsing: !0,\n  clarifyTimeoutError: !1\n}, Kt, ir;\nfunction ss() {\n  if (ir)\n    return Kt;\n  ir = 1;\n  var n = ns;\n  return Kt = function(t, r, s, i, o) {\n    var u = new Error(t);\n    return n(u, r, s, i, o);\n  }, Kt;\n}\nvar Gt, or;\nfunction Oi() {\n  if (or)\n    return Gt;\n  or = 1;\n  var n = ss();\n  return Gt = function(t, r, s) {\n    var i = s.config.validateStatus;\n    !s.status || !i || i(s.status) ? t(s) : r(n(\n      \"Request failed with status code \" + s.status,\n      s.config,\n      null,\n      s.request,\n      s\n    ));\n  }, Gt;\n}\nvar Xt, ar;\nfunction xi() {\n  if (ar)\n    return Xt;\n  ar = 1;\n  var n = ae;\n  return Xt = n.isStandardBrowserEnv() ? function() {\n    return {\n      write: function(r, s, i, o, u, l) {\n        var a = [];\n        a.push(r + \"=\" + encodeURIComponent(s)), n.isNumber(i) && a.push(\"expires=\" + new Date(i).toGMTString()), n.isString(o) && a.push(\"path=\" + o), n.isString(u) && a.push(\"domain=\" + u), l === !0 && a.push(\"secure\"), document.cookie = a.join(\"; \");\n      },\n      read: function(r) {\n        var s = document.cookie.match(new RegExp(\"(^|;\\\\s*)(\" + r + \")=([^;]*)\"));\n        return s ? decodeURIComponent(s[3]) : null;\n      },\n      remove: function(r) {\n        this.write(r, \"\", Date.now() - 864e5);\n      }\n    };\n  }() : function() {\n    return {\n      write: function() {\n      },\n      read: function() {\n        return null;\n      },\n      remove: function() {\n      }\n    };\n  }(), Xt;\n}\nvar Qt, ur;\nfunction Ci() {\n  return ur || (ur = 1, Qt = function(e) {\n    return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(e);\n  }), Qt;\n}\nvar Zt, cr;\nfunction Ai() {\n  return cr || (cr = 1, Zt = function(e, t) {\n    return t ? e.replace(/\\/+$/, \"\") + \"/\" + t.replace(/^\\/+/, \"\") : e;\n  }), Zt;\n}\nvar en, lr;\nfunction Di() {\n  if (lr)\n    return en;\n  lr = 1;\n  var n = Ci(), e = Ai();\n  return en = function(r, s) {\n    return r && !n(s) ? e(r, s) : s;\n  }, en;\n}\nvar tn, fr;\nfunction ki() {\n  if (fr)\n    return tn;\n  fr = 1;\n  var n = ae, e = [\n    \"age\",\n    \"authorization\",\n    \"content-length\",\n    \"content-type\",\n    \"etag\",\n    \"expires\",\n    \"from\",\n    \"host\",\n    \"if-modified-since\",\n    \"if-unmodified-since\",\n    \"last-modified\",\n    \"location\",\n    \"max-forwards\",\n    \"proxy-authorization\",\n    \"referer\",\n    \"retry-after\",\n    \"user-agent\"\n  ];\n  return tn = function(r) {\n    var s = {}, i, o, u;\n    return r && n.forEach(r.split(`\n`), function(a) {\n      if (u = a.indexOf(\":\"), i = n.trim(a.substr(0, u)).toLowerCase(), o = n.trim(a.substr(u + 1)), i) {\n        if (s[i] && e.indexOf(i) >= 0)\n          return;\n        i === \"set-cookie\" ? s[i] = (s[i] ? s[i] : []).concat([o]) : s[i] = s[i] ? s[i] + \", \" + o : o;\n      }\n    }), s;\n  }, tn;\n}\nvar nn, hr;\nfunction Li() {\n  if (hr)\n    return nn;\n  hr = 1;\n  var n = ae;\n  return nn = n.isStandardBrowserEnv() ? function() {\n    var t = /(msie|trident)/i.test(navigator.userAgent), r = document.createElement(\"a\"), s;\n    function i(o) {\n      var u = o;\n      return t && (r.setAttribute(\"href\", u), u = r.href), r.setAttribute(\"href\", u), {\n        href: r.href,\n        protocol: r.protocol ? r.protocol.replace(/:$/, \"\") : \"\",\n        host: r.host,\n        search: r.search ? r.search.replace(/^\\?/, \"\") : \"\",\n        hash: r.hash ? r.hash.replace(/^#/, \"\") : \"\",\n        hostname: r.hostname,\n        port: r.port,\n        pathname: r.pathname.charAt(0) === \"/\" ? r.pathname : \"/\" + r.pathname\n      };\n    }\n    return s = i(window.location.href), function(u) {\n      var l = n.isString(u) ? i(u) : u;\n      return l.protocol === s.protocol && l.host === s.host;\n    };\n  }() : function() {\n    return function() {\n      return !0;\n    };\n  }(), nn;\n}\nvar rn, dr;\nfunction qt() {\n  if (dr)\n    return rn;\n  dr = 1;\n  function n(e) {\n    this.message = e;\n  }\n  return n.prototype.toString = function() {\n    return \"Cancel\" + (this.message ? \": \" + this.message : \"\");\n  }, n.prototype.__CANCEL__ = !0, rn = n, rn;\n}\nvar sn, pr;\nfunction vr() {\n  if (pr)\n    return sn;\n  pr = 1;\n  var n = ae, e = Oi(), t = xi(), r = ts, s = Di(), i = ki(), o = Li(), u = ss(), l = rs, a = qt();\n  return sn = function(f) {\n    return new Promise(function(m, g) {\n      var b = f.data, E = f.headers, _ = f.responseType, S;\n      function k() {\n        f.cancelToken && f.cancelToken.unsubscribe(S), f.signal && f.signal.removeEventListener(\"abort\", S);\n      }\n      n.isFormData(b) && delete E[\"Content-Type\"];\n      var y = new XMLHttpRequest();\n      if (f.auth) {\n        var M = f.auth.username || \"\", T = f.auth.password ? unescape(encodeURIComponent(f.auth.password)) : \"\";\n        E.Authorization = \"Basic \" + btoa(M + \":\" + T);\n      }\n      var V = s(f.baseURL, f.url);\n      y.open(f.method.toUpperCase(), r(V, f.params, f.paramsSerializer), !0), y.timeout = f.timeout;\n      function D() {\n        if (!!y) {\n          var L = \"getAllResponseHeaders\" in y ? i(y.getAllResponseHeaders()) : null, Q = !_ || _ === \"text\" || _ === \"json\" ? y.responseText : y.response, ne = {\n            data: Q,\n            status: y.status,\n            statusText: y.statusText,\n            headers: L,\n            config: f,\n            request: y\n          };\n          e(function(F) {\n            m(F), k();\n          }, function(F) {\n            g(F), k();\n          }, ne), y = null;\n        }\n      }\n      if (\"onloadend\" in y ? y.onloadend = D : y.onreadystatechange = function() {\n        !y || y.readyState !== 4 || y.status === 0 && !(y.responseURL && y.responseURL.indexOf(\"file:\") === 0) || setTimeout(D);\n      }, y.onabort = function() {\n        !y || (g(u(\"Request aborted\", f, \"ECONNABORTED\", y)), y = null);\n      }, y.onerror = function() {\n        g(u(\"Network Error\", f, null, y)), y = null;\n      }, y.ontimeout = function() {\n        var Q = f.timeout ? \"timeout of \" + f.timeout + \"ms exceeded\" : \"timeout exceeded\", ne = f.transitional || l;\n        f.timeoutErrorMessage && (Q = f.timeoutErrorMessage), g(u(\n          Q,\n          f,\n          ne.clarifyTimeoutError ? \"ETIMEDOUT\" : \"ECONNABORTED\",\n          y\n        )), y = null;\n      }, n.isStandardBrowserEnv()) {\n        var j = (f.withCredentials || o(V)) && f.xsrfCookieName ? t.read(f.xsrfCookieName) : void 0;\n        j && (E[f.xsrfHeaderName] = j);\n      }\n      \"setRequestHeader\" in y && n.forEach(E, function(Q, ne) {\n        typeof b > \"u\" && ne.toLowerCase() === \"content-type\" ? delete E[ne] : y.setRequestHeader(ne, Q);\n      }), n.isUndefined(f.withCredentials) || (y.withCredentials = !!f.withCredentials), _ && _ !== \"json\" && (y.responseType = f.responseType), typeof f.onDownloadProgress == \"function\" && y.addEventListener(\"progress\", f.onDownloadProgress), typeof f.onUploadProgress == \"function\" && y.upload && y.upload.addEventListener(\"progress\", f.onUploadProgress), (f.cancelToken || f.signal) && (S = function(L) {\n        !y || (g(!L || L && L.type ? new a(\"canceled\") : L), y.abort(), y = null);\n      }, f.cancelToken && f.cancelToken.subscribe(S), f.signal && (f.signal.aborted ? S() : f.signal.addEventListener(\"abort\", S))), b || (b = null), y.send(b);\n    });\n  }, sn;\n}\nvar Z = ae, yr = Ti, Ni = ns, Pi = rs, Bi = {\n  \"Content-Type\": \"application/x-www-form-urlencoded\"\n};\nfunction mr(n, e) {\n  !Z.isUndefined(n) && Z.isUndefined(n[\"Content-Type\"]) && (n[\"Content-Type\"] = e);\n}\nfunction Fi() {\n  var n;\n  return (typeof XMLHttpRequest < \"u\" || typeof process < \"u\" && Object.prototype.toString.call(process) === \"[object process]\") && (n = vr()), n;\n}\nfunction Ui(n, e, t) {\n  if (Z.isString(n))\n    try {\n      return (e || JSON.parse)(n), Z.trim(n);\n    } catch (r) {\n      if (r.name !== \"SyntaxError\")\n        throw r;\n    }\n  return (t || JSON.stringify)(n);\n}\nvar It = {\n  transitional: Pi,\n  adapter: Fi(),\n  transformRequest: [function(e, t) {\n    return yr(t, \"Accept\"), yr(t, \"Content-Type\"), Z.isFormData(e) || Z.isArrayBuffer(e) || Z.isBuffer(e) || Z.isStream(e) || Z.isFile(e) || Z.isBlob(e) ? e : Z.isArrayBufferView(e) ? e.buffer : Z.isURLSearchParams(e) ? (mr(t, \"application/x-www-form-urlencoded;charset=utf-8\"), e.toString()) : Z.isObject(e) || t && t[\"Content-Type\"] === \"application/json\" ? (mr(t, \"application/json\"), Ui(e)) : e;\n  }],\n  transformResponse: [function(e) {\n    var t = this.transitional || It.transitional, r = t && t.silentJSONParsing, s = t && t.forcedJSONParsing, i = !r && this.responseType === \"json\";\n    if (i || s && Z.isString(e) && e.length)\n      try {\n        return JSON.parse(e);\n      } catch (o) {\n        if (i)\n          throw o.name === \"SyntaxError\" ? Ni(o, this, \"E_JSON_PARSE\") : o;\n      }\n    return e;\n  }],\n  timeout: 0,\n  xsrfCookieName: \"XSRF-TOKEN\",\n  xsrfHeaderName: \"X-XSRF-TOKEN\",\n  maxContentLength: -1,\n  maxBodyLength: -1,\n  validateStatus: function(e) {\n    return e >= 200 && e < 300;\n  },\n  headers: {\n    common: {\n      Accept: \"application/json, text/plain, */*\"\n    }\n  }\n};\nZ.forEach([\"delete\", \"get\", \"head\"], function(e) {\n  It.headers[e] = {};\n});\nZ.forEach([\"post\", \"put\", \"patch\"], function(e) {\n  It.headers[e] = Z.merge(Bi);\n});\nvar In = It, qi = ae, Ii = In, Vi = function(e, t, r) {\n  var s = this || Ii;\n  return qi.forEach(r, function(o) {\n    e = o.call(s, e, t);\n  }), e;\n}, on, gr;\nfunction is() {\n  return gr || (gr = 1, on = function(e) {\n    return !!(e && e.__CANCEL__);\n  }), on;\n}\nvar _r = ae, an = Vi, ji = is(), $i = In, Mi = qt();\nfunction un(n) {\n  if (n.cancelToken && n.cancelToken.throwIfRequested(), n.signal && n.signal.aborted)\n    throw new Mi(\"canceled\");\n}\nvar Wi = function(e) {\n  un(e), e.headers = e.headers || {}, e.data = an.call(\n    e,\n    e.data,\n    e.headers,\n    e.transformRequest\n  ), e.headers = _r.merge(\n    e.headers.common || {},\n    e.headers[e.method] || {},\n    e.headers\n  ), _r.forEach(\n    [\"delete\", \"get\", \"head\", \"post\", \"put\", \"patch\", \"common\"],\n    function(s) {\n      delete e.headers[s];\n    }\n  );\n  var t = e.adapter || $i.adapter;\n  return t(e).then(function(s) {\n    return un(e), s.data = an.call(\n      e,\n      s.data,\n      s.headers,\n      e.transformResponse\n    ), s;\n  }, function(s) {\n    return ji(s) || (un(e), s && s.response && (s.response.data = an.call(\n      e,\n      s.response.data,\n      s.response.headers,\n      e.transformResponse\n    ))), Promise.reject(s);\n  });\n}, ue = ae, os = function(e, t) {\n  t = t || {};\n  var r = {};\n  function s(h, f) {\n    return ue.isPlainObject(h) && ue.isPlainObject(f) ? ue.merge(h, f) : ue.isPlainObject(f) ? ue.merge({}, f) : ue.isArray(f) ? f.slice() : f;\n  }\n  function i(h) {\n    if (ue.isUndefined(t[h])) {\n      if (!ue.isUndefined(e[h]))\n        return s(void 0, e[h]);\n    } else\n      return s(e[h], t[h]);\n  }\n  function o(h) {\n    if (!ue.isUndefined(t[h]))\n      return s(void 0, t[h]);\n  }\n  function u(h) {\n    if (ue.isUndefined(t[h])) {\n      if (!ue.isUndefined(e[h]))\n        return s(void 0, e[h]);\n    } else\n      return s(void 0, t[h]);\n  }\n  function l(h) {\n    if (h in t)\n      return s(e[h], t[h]);\n    if (h in e)\n      return s(void 0, e[h]);\n  }\n  var a = {\n    url: o,\n    method: o,\n    data: o,\n    baseURL: u,\n    transformRequest: u,\n    transformResponse: u,\n    paramsSerializer: u,\n    timeout: u,\n    timeoutMessage: u,\n    withCredentials: u,\n    adapter: u,\n    responseType: u,\n    xsrfCookieName: u,\n    xsrfHeaderName: u,\n    onUploadProgress: u,\n    onDownloadProgress: u,\n    decompress: u,\n    maxContentLength: u,\n    maxBodyLength: u,\n    transport: u,\n    httpAgent: u,\n    httpsAgent: u,\n    cancelToken: u,\n    socketPath: u,\n    responseEncoding: u,\n    validateStatus: l\n  };\n  return ue.forEach(Object.keys(e).concat(Object.keys(t)), function(f) {\n    var p = a[f] || i, m = p(f);\n    ue.isUndefined(m) && p !== l || (r[f] = m);\n  }), r;\n}, cn, br;\nfunction as() {\n  return br || (br = 1, cn = {\n    version: \"0.26.1\"\n  }), cn;\n}\nvar Hi = as().version, Vn = {};\n[\"object\", \"boolean\", \"number\", \"function\", \"string\", \"symbol\"].forEach(function(n, e) {\n  Vn[n] = function(r) {\n    return typeof r === n || \"a\" + (e < 1 ? \"n \" : \" \") + n;\n  };\n});\nvar wr = {};\nVn.transitional = function(e, t, r) {\n  function s(i, o) {\n    return \"[Axios v\" + Hi + \"] Transitional option '\" + i + \"'\" + o + (r ? \". \" + r : \"\");\n  }\n  return function(i, o, u) {\n    if (e === !1)\n      throw new Error(s(o, \" has been removed\" + (t ? \" in \" + t : \"\")));\n    return t && !wr[o] && (wr[o] = !0, console.warn(\n      s(\n        o,\n        \" has been deprecated since v\" + t + \" and will be removed in the near future\"\n      )\n    )), e ? e(i, o, u) : !0;\n  };\n};\nfunction Ji(n, e, t) {\n  if (typeof n != \"object\")\n    throw new TypeError(\"options must be an object\");\n  for (var r = Object.keys(n), s = r.length; s-- > 0; ) {\n    var i = r[s], o = e[i];\n    if (o) {\n      var u = n[i], l = u === void 0 || o(u, i, n);\n      if (l !== !0)\n        throw new TypeError(\"option \" + i + \" must be \" + l);\n      continue;\n    }\n    if (t !== !0)\n      throw Error(\"Unknown option \" + i);\n  }\n}\nvar Yi = {\n  assertOptions: Ji,\n  validators: Vn\n}, us = ae, zi = ts, Er = Ri, Rr = Wi, Vt = os, cs = Yi, ze = cs.validators;\nfunction pt(n) {\n  this.defaults = n, this.interceptors = {\n    request: new Er(),\n    response: new Er()\n  };\n}\npt.prototype.request = function(e, t) {\n  typeof e == \"string\" ? (t = t || {}, t.url = e) : t = e || {}, t = Vt(this.defaults, t), t.method ? t.method = t.method.toLowerCase() : this.defaults.method ? t.method = this.defaults.method.toLowerCase() : t.method = \"get\";\n  var r = t.transitional;\n  r !== void 0 && cs.assertOptions(r, {\n    silentJSONParsing: ze.transitional(ze.boolean),\n    forcedJSONParsing: ze.transitional(ze.boolean),\n    clarifyTimeoutError: ze.transitional(ze.boolean)\n  }, !1);\n  var s = [], i = !0;\n  this.interceptors.request.forEach(function(m) {\n    typeof m.runWhen == \"function\" && m.runWhen(t) === !1 || (i = i && m.synchronous, s.unshift(m.fulfilled, m.rejected));\n  });\n  var o = [];\n  this.interceptors.response.forEach(function(m) {\n    o.push(m.fulfilled, m.rejected);\n  });\n  var u;\n  if (!i) {\n    var l = [Rr, void 0];\n    for (Array.prototype.unshift.apply(l, s), l = l.concat(o), u = Promise.resolve(t); l.length; )\n      u = u.then(l.shift(), l.shift());\n    return u;\n  }\n  for (var a = t; s.length; ) {\n    var h = s.shift(), f = s.shift();\n    try {\n      a = h(a);\n    } catch (p) {\n      f(p);\n      break;\n    }\n  }\n  try {\n    u = Rr(a);\n  } catch (p) {\n    return Promise.reject(p);\n  }\n  for (; o.length; )\n    u = u.then(o.shift(), o.shift());\n  return u;\n};\npt.prototype.getUri = function(e) {\n  return e = Vt(this.defaults, e), zi(e.url, e.params, e.paramsSerializer).replace(/^\\?/, \"\");\n};\nus.forEach([\"delete\", \"get\", \"head\", \"options\"], function(e) {\n  pt.prototype[e] = function(t, r) {\n    return this.request(Vt(r || {}, {\n      method: e,\n      url: t,\n      data: (r || {}).data\n    }));\n  };\n});\nus.forEach([\"post\", \"put\", \"patch\"], function(e) {\n  pt.prototype[e] = function(t, r, s) {\n    return this.request(Vt(s || {}, {\n      method: e,\n      url: t,\n      data: r\n    }));\n  };\n});\nvar Ki = pt, ln, Sr;\nfunction Gi() {\n  if (Sr)\n    return ln;\n  Sr = 1;\n  var n = qt();\n  function e(t) {\n    if (typeof t != \"function\")\n      throw new TypeError(\"executor must be a function.\");\n    var r;\n    this.promise = new Promise(function(o) {\n      r = o;\n    });\n    var s = this;\n    this.promise.then(function(i) {\n      if (!!s._listeners) {\n        var o, u = s._listeners.length;\n        for (o = 0; o < u; o++)\n          s._listeners[o](i);\n        s._listeners = null;\n      }\n    }), this.promise.then = function(i) {\n      var o, u = new Promise(function(l) {\n        s.subscribe(l), o = l;\n      }).then(i);\n      return u.cancel = function() {\n        s.unsubscribe(o);\n      }, u;\n    }, t(function(o) {\n      s.reason || (s.reason = new n(o), r(s.reason));\n    });\n  }\n  return e.prototype.throwIfRequested = function() {\n    if (this.reason)\n      throw this.reason;\n  }, e.prototype.subscribe = function(r) {\n    if (this.reason) {\n      r(this.reason);\n      return;\n    }\n    this._listeners ? this._listeners.push(r) : this._listeners = [r];\n  }, e.prototype.unsubscribe = function(r) {\n    if (!!this._listeners) {\n      var s = this._listeners.indexOf(r);\n      s !== -1 && this._listeners.splice(s, 1);\n    }\n  }, e.source = function() {\n    var r, s = new e(function(o) {\n      r = o;\n    });\n    return {\n      token: s,\n      cancel: r\n    };\n  }, ln = e, ln;\n}\nvar fn, Tr;\nfunction Xi() {\n  return Tr || (Tr = 1, fn = function(e) {\n    return function(r) {\n      return e.apply(null, r);\n    };\n  }), fn;\n}\nvar hn, Or;\nfunction Qi() {\n  if (Or)\n    return hn;\n  Or = 1;\n  var n = ae;\n  return hn = function(t) {\n    return n.isObject(t) && t.isAxiosError === !0;\n  }, hn;\n}\nvar xr = ae, Zi = Xr, Lt = Ki, eo = os, to = In;\nfunction ls(n) {\n  var e = new Lt(n), t = Zi(Lt.prototype.request, e);\n  return xr.extend(t, Lt.prototype, e), xr.extend(t, e), t.create = function(s) {\n    return ls(eo(n, s));\n  }, t;\n}\nvar _e = ls(to);\n_e.Axios = Lt;\n_e.Cancel = qt();\n_e.CancelToken = Gi();\n_e.isCancel = is();\n_e.VERSION = as().version;\n_e.all = function(e) {\n  return Promise.all(e);\n};\n_e.spread = Xi();\n_e.isAxiosError = Qi();\nFn.exports = _e;\nFn.exports.default = _e;\n(function(n) {\n  n.exports = Fn.exports;\n})(Gr);\nObject.defineProperty(Ke, \"__esModule\", { value: !0 });\nKe.getRequestHeaders = Ke.getAxiosClient = void 0;\nvar no = Gr.exports;\nfunction ro(n, e, t, r) {\n  return no.default.create({\n    baseURL: n,\n    headers: fs(e, r, t),\n    withCredentials: !0\n  });\n}\nKe.getAxiosClient = ro;\nfunction fs(n, e, t) {\n  n === void 0 && (n = !1);\n  var r = {\n    Accept: \"application/json\",\n    \"Content-Type\": \"application/json; charset=utf-8\"\n  };\n  return n && e && t && (r.Authorization = \"\".concat(e, \" \").concat(t())), typeof window < \"u\" && typeof document < \"u\" && (window.location && (r[\"X-Frappe-Site-Name\"] = window.location.hostname), window.csrf_token && window.csrf_token !== \"{{ csrf_token }}\" && (r[\"X-Frappe-CSRF-Token\"] = window.csrf_token)), r;\n}\nKe.getRequestHeaders = fs;\nvar Cr;\nfunction so() {\n  if (Cr)\n    return rt;\n  Cr = 1, Object.defineProperty(rt, \"__esModule\", { value: !0 }), rt.FrappeApp = void 0;\n  var n = hs(), e = ft, t = ht, r = dt, s = Ke, i = function() {\n    function o(u, l, a) {\n      var h, f;\n      this.url = u, this.name = a != null ? a : \"FrappeApp\", this.useToken = (h = l == null ? void 0 : l.useToken) !== null && h !== void 0 ? h : !1, this.token = l == null ? void 0 : l.token, this.tokenType = (f = l == null ? void 0 : l.type) !== null && f !== void 0 ? f : \"Bearer\", this.axios = (0, s.getAxiosClient)(this.url, this.useToken, this.token, this.tokenType);\n    }\n    return o.prototype.auth = function() {\n      return new n.FrappeAuth(this.url, this.axios, this.useToken, this.token, this.tokenType);\n    }, o.prototype.db = function() {\n      return new t.FrappeDB(this.url, this.axios, this.useToken, this.token, this.tokenType);\n    }, o.prototype.file = function() {\n      return new r.FrappeFileUpload(this.url, this.axios, this.useToken, this.token, this.tokenType);\n    }, o.prototype.call = function() {\n      return new e.FrappeCall(this.url, this.axios, this.useToken, this.token, this.tokenType);\n    }, o;\n  }();\n  return rt.FrappeApp = i, rt;\n}\nvar jt = {}, ye = B && B.__assign || function() {\n  return ye = Object.assign || function(n) {\n    for (var e, t = 1, r = arguments.length; t < r; t++) {\n      e = arguments[t];\n      for (var s in e)\n        Object.prototype.hasOwnProperty.call(e, s) && (n[s] = e[s]);\n    }\n    return n;\n  }, ye.apply(this, arguments);\n}, Rt = B && B.__awaiter || function(n, e, t, r) {\n  function s(i) {\n    return i instanceof t ? i : new t(function(o) {\n      o(i);\n    });\n  }\n  return new (t || (t = Promise))(function(i, o) {\n    function u(h) {\n      try {\n        a(r.next(h));\n      } catch (f) {\n        o(f);\n      }\n    }\n    function l(h) {\n      try {\n        a(r.throw(h));\n      } catch (f) {\n        o(f);\n      }\n    }\n    function a(h) {\n      h.done ? i(h.value) : s(h.value).then(u, l);\n    }\n    a((r = r.apply(n, e || [])).next());\n  });\n}, St = B && B.__generator || function(n, e) {\n  var t = { label: 0, sent: function() {\n    if (i[0] & 1)\n      throw i[1];\n    return i[1];\n  }, trys: [], ops: [] }, r, s, i, o;\n  return o = { next: u(0), throw: u(1), return: u(2) }, typeof Symbol == \"function\" && (o[Symbol.iterator] = function() {\n    return this;\n  }), o;\n  function u(a) {\n    return function(h) {\n      return l([a, h]);\n    };\n  }\n  function l(a) {\n    if (r)\n      throw new TypeError(\"Generator is already executing.\");\n    for (; t; )\n      try {\n        if (r = 1, s && (i = a[0] & 2 ? s.return : a[0] ? s.throw || ((i = s.return) && i.call(s), 0) : s.next) && !(i = i.call(s, a[1])).done)\n          return i;\n        switch (s = 0, i && (a = [a[0] & 2, i.value]), a[0]) {\n          case 0:\n          case 1:\n            i = a;\n            break;\n          case 4:\n            return t.label++, { value: a[1], done: !1 };\n          case 5:\n            t.label++, s = a[1], a = [0];\n            continue;\n          case 7:\n            a = t.ops.pop(), t.trys.pop();\n            continue;\n          default:\n            if (i = t.trys, !(i = i.length > 0 && i[i.length - 1]) && (a[0] === 6 || a[0] === 2)) {\n              t = 0;\n              continue;\n            }\n            if (a[0] === 3 && (!i || a[1] > i[0] && a[1] < i[3])) {\n              t.label = a[1];\n              break;\n            }\n            if (a[0] === 6 && t.label < i[1]) {\n              t.label = i[1], i = a;\n              break;\n            }\n            if (i && t.label < i[2]) {\n              t.label = i[2], t.ops.push(a);\n              break;\n            }\n            i[2] && t.ops.pop(), t.trys.pop();\n            continue;\n        }\n        a = e.call(n, t);\n      } catch (h) {\n        a = [6, h], s = 0;\n      } finally {\n        r = i = 0;\n      }\n    if (a[0] & 5)\n      throw a[1];\n    return { value: a[0] ? a[1] : void 0, done: !0 };\n  }\n};\nObject.defineProperty(jt, \"__esModule\", { value: !0 });\njt.FrappeAuth = void 0;\nvar io = function() {\n  function n(e, t, r, s, i) {\n    this.appURL = e, this.axios = t, this.useToken = r != null ? r : !1, this.token = s, this.tokenType = i;\n  }\n  return n.prototype.loginWithUsernamePassword = function(e) {\n    return Rt(this, void 0, void 0, function() {\n      var t, r, s;\n      return St(this, function(i) {\n        return t = e.username, r = e.password, s = e.device, [2, this.axios.post(\"/api/method/login\", {\n          usr: t,\n          pwd: r,\n          device: s\n        }).then(function(o) {\n          return o.data;\n        }).catch(function(o) {\n          var u, l;\n          throw ye(ye({}, o.response.data), { httpStatus: o.response.status, httpStatusText: o.response.statusText, message: (u = o.response.data.message) !== null && u !== void 0 ? u : \"There was an error while logging in\", exception: (l = o.response.data.exception) !== null && l !== void 0 ? l : \"\" });\n        })];\n      });\n    });\n  }, n.prototype.getLoggedInUser = function() {\n    return Rt(this, void 0, void 0, function() {\n      return St(this, function(e) {\n        return [2, this.axios.get(\"/api/method/frappe.auth.get_logged_user\").then(function(t) {\n          return t.data.message;\n        }).catch(function(t) {\n          var r;\n          throw ye(ye({}, t.response.data), { httpStatus: t.response.status, httpStatusText: t.response.statusText, message: \"There was an error while fetching the logged in user\", exception: (r = t.response.data.exception) !== null && r !== void 0 ? r : \"\" });\n        })];\n      });\n    });\n  }, n.prototype.logout = function() {\n    return Rt(this, void 0, void 0, function() {\n      return St(this, function(e) {\n        return [2, this.axios.post(\"/api/method/logout\", {}).then(function() {\n        }).catch(function(t) {\n          var r, s;\n          throw ye(ye({}, t.response.data), { httpStatus: t.response.status, httpStatusText: t.response.statusText, message: (r = t.response.data.message) !== null && r !== void 0 ? r : \"There was an error while logging out\", exception: (s = t.response.data.exception) !== null && s !== void 0 ? s : \"\" });\n        })];\n      });\n    });\n  }, n.prototype.forgetPassword = function(e) {\n    return Rt(this, void 0, void 0, function() {\n      return St(this, function(t) {\n        return [2, this.axios.post(\"/\", {\n          cmd: \"frappe.core.doctype.user.user.reset_password\",\n          user: e\n        }).then(function() {\n        }).catch(function(r) {\n          var s, i;\n          throw ye(ye({}, r.response.data), { httpStatus: r.response.status, httpStatusText: r.response.statusText, message: (s = r.response.data.message) !== null && s !== void 0 ? s : \"There was an error sending password reset email.\", exception: (i = r.response.data.exception) !== null && i !== void 0 ? i : \"\" });\n        })];\n      });\n    });\n  }, n;\n}();\njt.FrappeAuth = io;\nvar Ar;\nfunction hs() {\n  return Ar || (Ar = 1, function(n) {\n    var e = B && B.__createBinding || (Object.create ? function(r, s, i, o) {\n      o === void 0 && (o = i);\n      var u = Object.getOwnPropertyDescriptor(s, i);\n      (!u || (\"get\" in u ? !s.__esModule : u.writable || u.configurable)) && (u = { enumerable: !0, get: function() {\n        return s[i];\n      } }), Object.defineProperty(r, o, u);\n    } : function(r, s, i, o) {\n      o === void 0 && (o = i), r[o] = s[i];\n    }), t = B && B.__exportStar || function(r, s) {\n      for (var i in r)\n        i !== \"default\" && !Object.prototype.hasOwnProperty.call(s, i) && e(s, r, i);\n    };\n    Object.defineProperty(n, \"__esModule\", { value: !0 }), t(so(), n), t(jt, n), t(ht, n), t(dt, n), t(ft, n);\n  }(zt)), zt;\n}\nvar oo = hs(), ds = { exports: {} }, dn = {};\n/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Dr;\nfunction ao() {\n  if (Dr)\n    return dn;\n  Dr = 1;\n  var n = (react__WEBPACK_IMPORTED_MODULE_0___default());\n  function e(f, p) {\n    return f === p && (f !== 0 || 1 / f === 1 / p) || f !== f && p !== p;\n  }\n  var t = typeof Object.is == \"function\" ? Object.is : e, r = n.useState, s = n.useEffect, i = n.useLayoutEffect, o = n.useDebugValue;\n  function u(f, p) {\n    var m = p(), g = r({ inst: { value: m, getSnapshot: p } }), b = g[0].inst, E = g[1];\n    return i(function() {\n      b.value = m, b.getSnapshot = p, l(b) && E({ inst: b });\n    }, [f, m, p]), s(function() {\n      return l(b) && E({ inst: b }), f(function() {\n        l(b) && E({ inst: b });\n      });\n    }, [f]), o(m), m;\n  }\n  function l(f) {\n    var p = f.getSnapshot;\n    f = f.value;\n    try {\n      var m = p();\n      return !t(f, m);\n    } catch {\n      return !0;\n    }\n  }\n  function a(f, p) {\n    return p();\n  }\n  var h = typeof window > \"u\" || typeof window.document > \"u\" || typeof window.document.createElement > \"u\" ? a : u;\n  return dn.useSyncExternalStore = n.useSyncExternalStore !== void 0 ? n.useSyncExternalStore : h, dn;\n}\nvar pn = {};\n/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar kr;\nfunction uo() {\n  return kr || (kr = 1,  true && function() {\n    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < \"u\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == \"function\" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n    var n = (react__WEBPACK_IMPORTED_MODULE_0___default()), e = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function t(k) {\n      {\n        for (var y = arguments.length, M = new Array(y > 1 ? y - 1 : 0), T = 1; T < y; T++)\n          M[T - 1] = arguments[T];\n        r(\"error\", k, M);\n      }\n    }\n    function r(k, y, M) {\n      {\n        var T = e.ReactDebugCurrentFrame, V = T.getStackAddendum();\n        V !== \"\" && (y += \"%s\", M = M.concat([V]));\n        var D = M.map(function(j) {\n          return String(j);\n        });\n        D.unshift(\"Warning: \" + y), Function.prototype.apply.call(console[k], console, D);\n      }\n    }\n    function s(k, y) {\n      return k === y && (k !== 0 || 1 / k === 1 / y) || k !== k && y !== y;\n    }\n    var i = typeof Object.is == \"function\" ? Object.is : s, o = n.useState, u = n.useEffect, l = n.useLayoutEffect, a = n.useDebugValue, h = !1, f = !1;\n    function p(k, y, M) {\n      h || n.startTransition !== void 0 && (h = !0, t(\"You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.\"));\n      var T = y();\n      if (!f) {\n        var V = y();\n        i(T, V) || (t(\"The result of getSnapshot should be cached to avoid an infinite loop\"), f = !0);\n      }\n      var D = o({\n        inst: {\n          value: T,\n          getSnapshot: y\n        }\n      }), j = D[0].inst, L = D[1];\n      return l(function() {\n        j.value = T, j.getSnapshot = y, m(j) && L({\n          inst: j\n        });\n      }, [k, T, y]), u(function() {\n        m(j) && L({\n          inst: j\n        });\n        var Q = function() {\n          m(j) && L({\n            inst: j\n          });\n        };\n        return k(Q);\n      }, [k]), a(T), T;\n    }\n    function m(k) {\n      var y = k.getSnapshot, M = k.value;\n      try {\n        var T = y();\n        return !i(M, T);\n      } catch {\n        return !0;\n      }\n    }\n    function g(k, y, M) {\n      return y();\n    }\n    var b = typeof window < \"u\" && typeof window.document < \"u\" && typeof window.document.createElement < \"u\", E = !b, _ = E ? g : p, S = n.useSyncExternalStore !== void 0 ? n.useSyncExternalStore : _;\n    pn.useSyncExternalStore = S, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < \"u\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == \"function\" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n  }()), pn;\n}\n(function(n) {\n   false ? 0 : n.exports = uo();\n})(ds);\nconst Ae = () => {\n}, oe = Ae(), vn = Object, C = (n) => n === oe, Oe = (n) => typeof n == \"function\", De = (n, e) => ({\n  ...n,\n  ...e\n}), co = (n) => Oe(n.then), Tt = /* @__PURE__ */ new WeakMap();\nlet lo = 0;\nconst ct = (n) => {\n  const e = typeof n, t = n && n.constructor, r = t == Date;\n  let s, i;\n  if (vn(n) === n && !r && t != RegExp) {\n    if (s = Tt.get(n), s)\n      return s;\n    if (s = ++lo + \"~\", Tt.set(n, s), t == Array) {\n      for (s = \"@\", i = 0; i < n.length; i++)\n        s += ct(n[i]) + \",\";\n      Tt.set(n, s);\n    }\n    if (t == vn) {\n      s = \"#\";\n      const o = vn.keys(n).sort();\n      for (; !C(i = o.pop()); )\n        C(n[i]) || (s += i + \":\" + ct(n[i]) + \",\");\n      Tt.set(n, s);\n    }\n  } else\n    s = r ? n.toJSON() : e == \"symbol\" ? n.toString() : e == \"string\" ? JSON.stringify(n) : \"\" + n;\n  return s;\n}, Te = /* @__PURE__ */ new WeakMap(), yn = {}, Ot = {}, jn = \"undefined\", $t = typeof window != jn, Sn = typeof document != jn, fo = () => $t && typeof window.requestAnimationFrame != jn, ps = (n, e) => {\n  const t = Te.get(n);\n  return [\n    () => !C(e) && n.get(e) || yn,\n    (r) => {\n      if (!C(e)) {\n        const s = n.get(e);\n        e in Ot || (Ot[e] = s), t[5](e, De(s, r), s || yn);\n      }\n    },\n    t[6],\n    () => !C(e) && e in Ot ? Ot[e] : !C(e) && n.get(e) || yn\n  ];\n};\nlet Tn = !0;\nconst ho = () => Tn, [On, xn] = $t && window.addEventListener ? [\n  window.addEventListener.bind(window),\n  window.removeEventListener.bind(window)\n] : [\n  Ae,\n  Ae\n], po = () => {\n  const n = Sn && document.visibilityState;\n  return C(n) || n !== \"hidden\";\n}, vo = (n) => (Sn && document.addEventListener(\"visibilitychange\", n), On(\"focus\", n), () => {\n  Sn && document.removeEventListener(\"visibilitychange\", n), xn(\"focus\", n);\n}), yo = (n) => {\n  const e = () => {\n    Tn = !0, n();\n  }, t = () => {\n    Tn = !1;\n  };\n  return On(\"online\", e), On(\"offline\", t), () => {\n    xn(\"online\", e), xn(\"offline\", t);\n  };\n}, mo = {\n  isOnline: ho,\n  isVisible: po\n}, go = {\n  initFocus: vo,\n  initReconnect: yo\n}, Lr = !(react__WEBPACK_IMPORTED_MODULE_0___default().useId), lt = !$t || \"Deno\" in window, _o = (n) => fo() ? window.requestAnimationFrame(n) : setTimeout(n, 1), mn = lt ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect, gn = typeof navigator < \"u\" && navigator.connection, Nr = !lt && gn && ([\n  \"slow-2g\",\n  \"2g\"\n].includes(gn.effectiveType) || gn.saveData), $n = (n) => {\n  if (Oe(n))\n    try {\n      n = n();\n    } catch {\n      n = \"\";\n    }\n  const e = n;\n  return n = typeof n == \"string\" ? n : (Array.isArray(n) ? n.length : n) ? ct(n) : \"\", [\n    n,\n    e\n  ];\n};\nlet bo = 0;\nconst Cn = () => ++bo, vs = 0, ys = 1, ms = 2, wo = 3;\nvar st = {\n  __proto__: null,\n  ERROR_REVALIDATE_EVENT: wo,\n  FOCUS_EVENT: vs,\n  MUTATE_EVENT: ms,\n  RECONNECT_EVENT: ys\n};\nasync function gs(...n) {\n  const [e, t, r, s] = n, i = De({\n    populateCache: !0,\n    throwOnError: !0\n  }, typeof s == \"boolean\" ? {\n    revalidate: s\n  } : s || {});\n  let o = i.populateCache;\n  const u = i.rollbackOnError;\n  let l = i.optimisticData;\n  const a = i.revalidate !== !1, h = (m) => typeof u == \"function\" ? u(m) : u !== !1, f = i.throwOnError;\n  if (Oe(t)) {\n    const m = t, g = [], b = e.keys();\n    for (const E of b)\n      !/^\\$(inf|sub)\\$/.test(E) && m(e.get(E)._k) && g.push(E);\n    return Promise.all(g.map(p));\n  }\n  return p(t);\n  async function p(m) {\n    const [g] = $n(m);\n    if (!g)\n      return;\n    const [b, E] = ps(e, g), [_, S, k, y] = Te.get(e), M = () => {\n      const F = _[g];\n      return a && (delete k[g], delete y[g], F && F[0]) ? F[0](ms).then(() => b().data) : b().data;\n    };\n    if (n.length < 3)\n      return M();\n    let T = r, V;\n    const D = Cn();\n    S[g] = [\n      D,\n      0\n    ];\n    const j = !C(l), L = b(), Q = L.data, ne = L._c, G = C(ne) ? Q : ne;\n    if (j && (l = Oe(l) ? l(G, Q) : l, E({\n      data: l,\n      _c: G\n    })), Oe(T))\n      try {\n        T = T(G);\n      } catch (F) {\n        V = F;\n      }\n    if (T && co(T))\n      if (T = await T.catch((F) => {\n        V = F;\n      }), D !== S[g][0]) {\n        if (V)\n          throw V;\n        return T;\n      } else\n        V && j && h(V) && (o = !0, E({\n          data: G,\n          _c: oe\n        }));\n    if (o && !V)\n      if (Oe(o)) {\n        const F = o(T, G);\n        E({\n          data: F,\n          error: oe,\n          _c: oe\n        });\n      } else\n        E({\n          data: T,\n          error: oe,\n          _c: oe\n        });\n    if (S[g][1] = Cn(), Promise.resolve(M()).then(() => {\n      E({\n        _c: oe\n      });\n    }), V) {\n      if (f)\n        throw V;\n      return;\n    }\n    return T;\n  }\n}\nconst Pr = (n, e) => {\n  for (const t in n)\n    n[t][0] && n[t][0](e);\n}, Eo = (n, e) => {\n  if (!Te.has(n)) {\n    const t = De(go, e), r = {}, s = gs.bind(oe, n);\n    let i = Ae;\n    const o = {}, u = (h, f) => {\n      const p = o[h] || [];\n      return o[h] = p, p.push(f), () => p.splice(p.indexOf(f), 1);\n    }, l = (h, f, p) => {\n      n.set(h, f);\n      const m = o[h];\n      if (m)\n        for (const g of m)\n          g(f, p);\n    }, a = () => {\n      if (!Te.has(n) && (Te.set(n, [\n        r,\n        {},\n        {},\n        {},\n        s,\n        l,\n        u\n      ]), !lt)) {\n        const h = t.initFocus(setTimeout.bind(oe, Pr.bind(oe, r, vs))), f = t.initReconnect(setTimeout.bind(oe, Pr.bind(oe, r, ys)));\n        i = () => {\n          h && h(), f && f(), Te.delete(n);\n        };\n      }\n    };\n    return a(), [\n      n,\n      s,\n      a,\n      i\n    ];\n  }\n  return [\n    n,\n    Te.get(n)[4]\n  ];\n}, Ro = (n, e, t, r, s) => {\n  const i = t.errorRetryCount, o = s.retryCount, u = ~~((Math.random() + 0.5) * (1 << (o < 8 ? o : 8))) * t.errorRetryInterval;\n  !C(i) && o > i || setTimeout(r, u, s);\n}, So = (n, e) => ct(n) == ct(e), [_s, To] = Eo(/* @__PURE__ */ new Map()), Oo = De(\n  {\n    onLoadingSlow: Ae,\n    onSuccess: Ae,\n    onError: Ae,\n    onErrorRetry: Ro,\n    onDiscarded: Ae,\n    revalidateOnFocus: !0,\n    revalidateOnReconnect: !0,\n    revalidateIfStale: !0,\n    shouldRetryOnError: !0,\n    errorRetryInterval: Nr ? 1e4 : 5e3,\n    focusThrottleInterval: 5 * 1e3,\n    dedupingInterval: 2 * 1e3,\n    loadingTimeout: Nr ? 5e3 : 3e3,\n    compare: So,\n    isPaused: () => !1,\n    cache: _s,\n    mutate: To,\n    fallback: {}\n  },\n  mo\n), xo = (n, e) => {\n  const t = De(n, e);\n  if (e) {\n    const { use: r, fallback: s } = n, { use: i, fallback: o } = e;\n    r && i && (t.use = r.concat(i)), s && o && (t.fallback = De(s, o));\n  }\n  return t;\n}, Co = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({}), Ao = \"$inf$\", bs = $t && window.__SWR_DEVTOOLS_USE__, Do = bs ? window.__SWR_DEVTOOLS_USE__ : [], ko = () => {\n  bs && (window.__SWR_DEVTOOLS_REACT__ = (react__WEBPACK_IMPORTED_MODULE_0___default()));\n}, Lo = (n) => Oe(n[1]) ? [\n  n[0],\n  n[1],\n  n[2] || {}\n] : [\n  n[0],\n  null,\n  (n[1] === null ? n[2] : n[1]) || {}\n], No = () => De(Oo, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Co)), Po = (n) => (e, t, r) => n(e, t && ((...i) => {\n  const [o] = $n(e), [, , , u] = Te.get(_s);\n  if (o.startsWith(Ao))\n    return t(...i);\n  const l = u[o];\n  return C(l) ? t(...i) : (delete u[o], l);\n}), r), Bo = Do.concat(Po), Fo = (n) => function(...t) {\n  const r = No(), [s, i, o] = Lo(t), u = xo(r, o);\n  let l = n;\n  const { use: a } = u, h = (a || []).concat(Bo);\n  for (let f = h.length; f--; )\n    l = h[f](l);\n  return l(s, i || u.fetcher || null, u);\n}, Uo = (n, e, t) => {\n  const r = e[n] || (e[n] = []);\n  return r.push(t), () => {\n    const s = r.indexOf(t);\n    s >= 0 && (r[s] = r[r.length - 1], r.pop());\n  };\n};\nko();\nconst Br = (react__WEBPACK_IMPORTED_MODULE_0___default().use) || ((n) => {\n  if (n.status === \"pending\")\n    throw n;\n  if (n.status === \"fulfilled\")\n    return n.value;\n  throw n.status === \"rejected\" ? n.reason : (n.status = \"pending\", n.then((e) => {\n    n.status = \"fulfilled\", n.value = e;\n  }, (e) => {\n    n.status = \"rejected\", n.reason = e;\n  }), n);\n}), _n = {\n  dedupe: !0\n}, qo = (n, e, t) => {\n  const { cache: r, compare: s, suspense: i, fallbackData: o, revalidateOnMount: u, revalidateIfStale: l, refreshInterval: a, refreshWhenHidden: h, refreshWhenOffline: f, keepPreviousData: p } = t, [m, g, b, E] = Te.get(r), [_, S] = $n(n), k = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), y = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), M = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(_), T = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(e), V = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(t), D = () => V.current, j = () => D().isVisible() && D().isOnline(), [L, Q, ne, G] = ps(r, _), F = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({}).current, Le = C(o) ? t.fallback[_] : o, Qe = (N, U) => {\n    for (const X in F) {\n      const I = X;\n      if (I === \"data\") {\n        if (!s(N[I], U[I]) && (!C(N[I]) || !s(Ie, U[I])))\n          return !1;\n      } else if (U[I] !== N[I])\n        return !1;\n    }\n    return !0;\n  }, Ze = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const N = (() => !_ || !e ? !1 : C(u) ? D().isPaused() || i ? !1 : C(l) ? !0 : l : u)(), U = (J) => {\n      const de = De(J);\n      return delete de._k, N ? {\n        isValidating: !0,\n        isLoading: !0,\n        ...de\n      } : de;\n    }, X = L(), I = G(), re = U(X), Re = X === I ? re : U(I);\n    let H = re;\n    return [\n      () => {\n        const J = U(L());\n        return Qe(J, H) ? (H.data = J.data, H.isLoading = J.isLoading, H.isValidating = J.isValidating, H.error = J.error, H) : (H = J, J);\n      },\n      () => Re\n    ];\n  }, [\n    r,\n    _\n  ]), be = ds.exports.useSyncExternalStore((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (N) => ne(_, (U, X) => {\n      Qe(X, U) || N();\n    }),\n    [\n      r,\n      _\n    ]\n  ), Ze[0], Ze[1]), et = !k.current, yt = m[_] && m[_].length > 0, we = be.data, Ee = C(we) ? Le : we, Ne = be.error, mt = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(Ee), Ie = p ? C(we) ? mt.current : we : Ee, Ve = (() => yt && !C(Ne) ? !1 : et && !C(u) ? u : D().isPaused() ? !1 : i ? C(Ee) ? !1 : l : C(Ee) || l)(), je = !!(_ && e && et && Ve), $e = C(be.isValidating) ? je : be.isValidating, tt = C(be.isLoading) ? je : be.isLoading, ve = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (N) => {\n      const U = T.current;\n      if (!_ || !U || y.current || D().isPaused())\n        return !1;\n      let X, I, re = !0;\n      const Re = N || {}, H = !b[_] || !Re.dedupe, J = () => Lr ? !y.current && _ === M.current && k.current : _ === M.current, de = {\n        isValidating: !1,\n        isLoading: !1\n      }, _t = () => {\n        Q(de);\n      }, Me = () => {\n        const ie = b[_];\n        ie && ie[1] === I && delete b[_];\n      }, bt = {\n        isValidating: !0\n      };\n      C(L().data) && (bt.isLoading = !0);\n      try {\n        if (H && (Q(bt), t.loadingTimeout && C(L().data) && setTimeout(() => {\n          re && J() && D().onLoadingSlow(_, t);\n        }, t.loadingTimeout), b[_] = [\n          U(S),\n          Cn()\n        ]), [X, I] = b[_], X = await X, H && setTimeout(Me, t.dedupingInterval), !b[_] || b[_][1] !== I)\n          return H && J() && D().onDiscarded(_), !1;\n        de.error = oe;\n        const ie = g[_];\n        if (!C(ie) && (I <= ie[0] || I <= ie[1] || ie[1] === 0))\n          return _t(), H && J() && D().onDiscarded(_), !1;\n        const ce = L().data;\n        de.data = s(ce, X) ? ce : X, H && J() && D().onSuccess(X, _, t);\n      } catch (ie) {\n        Me();\n        const ce = D(), { shouldRetryOnError: We } = ce;\n        ce.isPaused() || (de.error = ie, H && J() && (ce.onError(ie, _, ce), (We === !0 || Oe(We) && We(ie)) && j() && ce.onErrorRetry(ie, _, ce, (Pe) => {\n          const nt = m[_];\n          nt && nt[0] && nt[0](st.ERROR_REVALIDATE_EVENT, Pe);\n        }, {\n          retryCount: (Re.retryCount || 0) + 1,\n          dedupe: !0\n        })));\n      }\n      return re = !1, _t(), !0;\n    },\n    [\n      _,\n      r\n    ]\n  ), gt = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (...N) => gs(r, M.current, ...N),\n    []\n  );\n  if (mn(() => {\n    T.current = e, V.current = t, C(we) || (mt.current = we);\n  }), mn(() => {\n    if (!_)\n      return;\n    const N = ve.bind(oe, _n);\n    let U = 0;\n    const I = Uo(_, m, (re, Re = {}) => {\n      if (re == st.FOCUS_EVENT) {\n        const H = Date.now();\n        D().revalidateOnFocus && H > U && j() && (U = H + D().focusThrottleInterval, N());\n      } else if (re == st.RECONNECT_EVENT)\n        D().revalidateOnReconnect && j() && N();\n      else {\n        if (re == st.MUTATE_EVENT)\n          return ve();\n        if (re == st.ERROR_REVALIDATE_EVENT)\n          return ve(Re);\n      }\n    });\n    return y.current = !1, M.current = _, k.current = !0, Q({\n      _k: S\n    }), Ve && (C(Ee) || lt ? N() : _o(N)), () => {\n      y.current = !0, I();\n    };\n  }, [\n    _\n  ]), mn(() => {\n    let N;\n    function U() {\n      const I = Oe(a) ? a(L().data) : a;\n      I && N !== -1 && (N = setTimeout(X, I));\n    }\n    function X() {\n      !L().error && (h || D().isVisible()) && (f || D().isOnline()) ? ve(_n).then(U) : U();\n    }\n    return U(), () => {\n      N && (clearTimeout(N), N = -1);\n    };\n  }, [\n    a,\n    h,\n    f,\n    _\n  ]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(Ie), i && C(Ee) && _) {\n    if (!Lr && lt)\n      throw new Error(\"Fallback data is required when using suspense in SSR.\");\n    T.current = e, V.current = t, y.current = !1;\n    const N = E[_];\n    if (!C(N)) {\n      const U = gt(N);\n      Br(U);\n    }\n    if (C(Ne)) {\n      const U = ve(_n);\n      C(Ie) || (U.status = \"fulfilled\", U.value = !0), Br(U);\n    } else\n      throw Ne;\n  }\n  return {\n    mutate: gt,\n    get data() {\n      return F.data = !0, Ie;\n    },\n    get error() {\n      return F.error = !0, Ne;\n    },\n    get isValidating() {\n      return F.isValidating = !0, $e;\n    },\n    get isLoading() {\n      return F.isLoading = !0, tt;\n    }\n  };\n}, vt = Fo(qo), ge = /* @__PURE__ */ Object.create(null);\nge.open = \"0\";\nge.close = \"1\";\nge.ping = \"2\";\nge.pong = \"3\";\nge.message = \"4\";\nge.upgrade = \"5\";\nge.noop = \"6\";\nconst Nt = /* @__PURE__ */ Object.create(null);\nObject.keys(ge).forEach((n) => {\n  Nt[ge[n]] = n;\n});\nconst An = { type: \"error\", data: \"parser error\" }, ws = typeof Blob == \"function\" || typeof Blob < \"u\" && Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\", Es = typeof ArrayBuffer == \"function\", Rs = (n) => typeof ArrayBuffer.isView == \"function\" ? ArrayBuffer.isView(n) : n && n.buffer instanceof ArrayBuffer, Mn = ({ type: n, data: e }, t, r) => ws && e instanceof Blob ? t ? r(e) : Fr(e, r) : Es && (e instanceof ArrayBuffer || Rs(e)) ? t ? r(e) : Fr(new Blob([e]), r) : r(ge[n] + (e || \"\")), Fr = (n, e) => {\n  const t = new FileReader();\n  return t.onload = function() {\n    const r = t.result.split(\",\")[1];\n    e(\"b\" + (r || \"\"));\n  }, t.readAsDataURL(n);\n};\nfunction Ur(n) {\n  return n instanceof Uint8Array ? n : n instanceof ArrayBuffer ? new Uint8Array(n) : new Uint8Array(n.buffer, n.byteOffset, n.byteLength);\n}\nlet bn;\nfunction Io(n, e) {\n  if (ws && n.data instanceof Blob)\n    return n.data.arrayBuffer().then(Ur).then(e);\n  if (Es && (n.data instanceof ArrayBuffer || Rs(n.data)))\n    return e(Ur(n.data));\n  Mn(n, !1, (t) => {\n    bn || (bn = new TextEncoder()), e(bn.encode(t));\n  });\n}\nconst qr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", ut = typeof Uint8Array > \"u\" ? [] : new Uint8Array(256);\nfor (let n = 0; n < qr.length; n++)\n  ut[qr.charCodeAt(n)] = n;\nconst Vo = (n) => {\n  let e = n.length * 0.75, t = n.length, r, s = 0, i, o, u, l;\n  n[n.length - 1] === \"=\" && (e--, n[n.length - 2] === \"=\" && e--);\n  const a = new ArrayBuffer(e), h = new Uint8Array(a);\n  for (r = 0; r < t; r += 4)\n    i = ut[n.charCodeAt(r)], o = ut[n.charCodeAt(r + 1)], u = ut[n.charCodeAt(r + 2)], l = ut[n.charCodeAt(r + 3)], h[s++] = i << 2 | o >> 4, h[s++] = (o & 15) << 4 | u >> 2, h[s++] = (u & 3) << 6 | l & 63;\n  return a;\n}, jo = typeof ArrayBuffer == \"function\", Wn = (n, e) => {\n  if (typeof n != \"string\")\n    return {\n      type: \"message\",\n      data: Ss(n, e)\n    };\n  const t = n.charAt(0);\n  return t === \"b\" ? {\n    type: \"message\",\n    data: $o(n.substring(1), e)\n  } : Nt[t] ? n.length > 1 ? {\n    type: Nt[t],\n    data: n.substring(1)\n  } : {\n    type: Nt[t]\n  } : An;\n}, $o = (n, e) => {\n  if (jo) {\n    const t = Vo(n);\n    return Ss(t, e);\n  } else\n    return { base64: !0, data: n };\n}, Ss = (n, e) => {\n  switch (e) {\n    case \"blob\":\n      return n instanceof Blob ? n : new Blob([n]);\n    case \"arraybuffer\":\n    default:\n      return n instanceof ArrayBuffer ? n : n.buffer;\n  }\n}, Ts = String.fromCharCode(30), Mo = (n, e) => {\n  const t = n.length, r = new Array(t);\n  let s = 0;\n  n.forEach((i, o) => {\n    Mn(i, !1, (u) => {\n      r[o] = u, ++s === t && e(r.join(Ts));\n    });\n  });\n}, Wo = (n, e) => {\n  const t = n.split(Ts), r = [];\n  for (let s = 0; s < t.length; s++) {\n    const i = Wn(t[s], e);\n    if (r.push(i), i.type === \"error\")\n      break;\n  }\n  return r;\n};\nfunction Ho() {\n  return new TransformStream({\n    transform(n, e) {\n      Io(n, (t) => {\n        const r = t.length;\n        let s;\n        if (r < 126)\n          s = new Uint8Array(1), new DataView(s.buffer).setUint8(0, r);\n        else if (r < 65536) {\n          s = new Uint8Array(3);\n          const i = new DataView(s.buffer);\n          i.setUint8(0, 126), i.setUint16(1, r);\n        } else {\n          s = new Uint8Array(9);\n          const i = new DataView(s.buffer);\n          i.setUint8(0, 127), i.setBigUint64(1, BigInt(r));\n        }\n        n.data && typeof n.data != \"string\" && (s[0] |= 128), e.enqueue(s), e.enqueue(t);\n      });\n    }\n  });\n}\nlet wn;\nfunction xt(n) {\n  return n.reduce((e, t) => e + t.length, 0);\n}\nfunction Ct(n, e) {\n  if (n[0].length === e)\n    return n.shift();\n  const t = new Uint8Array(e);\n  let r = 0;\n  for (let s = 0; s < e; s++)\n    t[s] = n[0][r++], r === n[0].length && (n.shift(), r = 0);\n  return n.length && r < n[0].length && (n[0] = n[0].slice(r)), t;\n}\nfunction Jo(n, e) {\n  wn || (wn = new TextDecoder());\n  const t = [];\n  let r = 0, s = -1, i = !1;\n  return new TransformStream({\n    transform(o, u) {\n      for (t.push(o); ; ) {\n        if (r === 0) {\n          if (xt(t) < 1)\n            break;\n          const l = Ct(t, 1);\n          i = (l[0] & 128) === 128, s = l[0] & 127, s < 126 ? r = 3 : s === 126 ? r = 1 : r = 2;\n        } else if (r === 1) {\n          if (xt(t) < 2)\n            break;\n          const l = Ct(t, 2);\n          s = new DataView(l.buffer, l.byteOffset, l.length).getUint16(0), r = 3;\n        } else if (r === 2) {\n          if (xt(t) < 8)\n            break;\n          const l = Ct(t, 8), a = new DataView(l.buffer, l.byteOffset, l.length), h = a.getUint32(0);\n          if (h > Math.pow(2, 53 - 32) - 1) {\n            u.enqueue(An);\n            break;\n          }\n          s = h * Math.pow(2, 32) + a.getUint32(4), r = 3;\n        } else {\n          if (xt(t) < s)\n            break;\n          const l = Ct(t, s);\n          u.enqueue(Wn(i ? l : wn.decode(l), e)), r = 0;\n        }\n        if (s === 0 || s > n) {\n          u.enqueue(An);\n          break;\n        }\n      }\n    }\n  });\n}\nconst Os = 4;\nfunction K(n) {\n  if (n)\n    return Yo(n);\n}\nfunction Yo(n) {\n  for (var e in K.prototype)\n    n[e] = K.prototype[e];\n  return n;\n}\nK.prototype.on = K.prototype.addEventListener = function(n, e) {\n  return this._callbacks = this._callbacks || {}, (this._callbacks[\"$\" + n] = this._callbacks[\"$\" + n] || []).push(e), this;\n};\nK.prototype.once = function(n, e) {\n  function t() {\n    this.off(n, t), e.apply(this, arguments);\n  }\n  return t.fn = e, this.on(n, t), this;\n};\nK.prototype.off = K.prototype.removeListener = K.prototype.removeAllListeners = K.prototype.removeEventListener = function(n, e) {\n  if (this._callbacks = this._callbacks || {}, arguments.length == 0)\n    return this._callbacks = {}, this;\n  var t = this._callbacks[\"$\" + n];\n  if (!t)\n    return this;\n  if (arguments.length == 1)\n    return delete this._callbacks[\"$\" + n], this;\n  for (var r, s = 0; s < t.length; s++)\n    if (r = t[s], r === e || r.fn === e) {\n      t.splice(s, 1);\n      break;\n    }\n  return t.length === 0 && delete this._callbacks[\"$\" + n], this;\n};\nK.prototype.emit = function(n) {\n  this._callbacks = this._callbacks || {};\n  for (var e = new Array(arguments.length - 1), t = this._callbacks[\"$\" + n], r = 1; r < arguments.length; r++)\n    e[r - 1] = arguments[r];\n  if (t) {\n    t = t.slice(0);\n    for (var r = 0, s = t.length; r < s; ++r)\n      t[r].apply(this, e);\n  }\n  return this;\n};\nK.prototype.emitReserved = K.prototype.emit;\nK.prototype.listeners = function(n) {\n  return this._callbacks = this._callbacks || {}, this._callbacks[\"$\" + n] || [];\n};\nK.prototype.hasListeners = function(n) {\n  return !!this.listeners(n).length;\n};\nconst he = (() => typeof self < \"u\" ? self : typeof window < \"u\" ? window : Function(\"return this\")())();\nfunction xs(n, ...e) {\n  return e.reduce((t, r) => (n.hasOwnProperty(r) && (t[r] = n[r]), t), {});\n}\nconst zo = he.setTimeout, Ko = he.clearTimeout;\nfunction Mt(n, e) {\n  e.useNativeTimers ? (n.setTimeoutFn = zo.bind(he), n.clearTimeoutFn = Ko.bind(he)) : (n.setTimeoutFn = he.setTimeout.bind(he), n.clearTimeoutFn = he.clearTimeout.bind(he));\n}\nconst Go = 1.33;\nfunction Xo(n) {\n  return typeof n == \"string\" ? Qo(n) : Math.ceil((n.byteLength || n.size) * Go);\n}\nfunction Qo(n) {\n  let e = 0, t = 0;\n  for (let r = 0, s = n.length; r < s; r++)\n    e = n.charCodeAt(r), e < 128 ? t += 1 : e < 2048 ? t += 2 : e < 55296 || e >= 57344 ? t += 3 : (r++, t += 4);\n  return t;\n}\nfunction Zo(n) {\n  let e = \"\";\n  for (let t in n)\n    n.hasOwnProperty(t) && (e.length && (e += \"&\"), e += encodeURIComponent(t) + \"=\" + encodeURIComponent(n[t]));\n  return e;\n}\nfunction ea(n) {\n  let e = {}, t = n.split(\"&\");\n  for (let r = 0, s = t.length; r < s; r++) {\n    let i = t[r].split(\"=\");\n    e[decodeURIComponent(i[0])] = decodeURIComponent(i[1]);\n  }\n  return e;\n}\nclass ta extends Error {\n  constructor(e, t, r) {\n    super(e), this.description = t, this.context = r, this.type = \"TransportError\";\n  }\n}\nclass Hn extends K {\n  constructor(e) {\n    super(), this.writable = !1, Mt(this, e), this.opts = e, this.query = e.query, this.socket = e.socket;\n  }\n  onError(e, t, r) {\n    return super.emitReserved(\"error\", new ta(e, t, r)), this;\n  }\n  open() {\n    return this.readyState = \"opening\", this.doOpen(), this;\n  }\n  close() {\n    return (this.readyState === \"opening\" || this.readyState === \"open\") && (this.doClose(), this.onClose()), this;\n  }\n  send(e) {\n    this.readyState === \"open\" && this.write(e);\n  }\n  onOpen() {\n    this.readyState = \"open\", this.writable = !0, super.emitReserved(\"open\");\n  }\n  onData(e) {\n    const t = Wn(e, this.socket.binaryType);\n    this.onPacket(t);\n  }\n  onPacket(e) {\n    super.emitReserved(\"packet\", e);\n  }\n  onClose(e) {\n    this.readyState = \"closed\", super.emitReserved(\"close\", e);\n  }\n  pause(e) {\n  }\n  createUri(e, t = {}) {\n    return e + \"://\" + this._hostname() + this._port() + this.opts.path + this._query(t);\n  }\n  _hostname() {\n    const e = this.opts.hostname;\n    return e.indexOf(\":\") === -1 ? e : \"[\" + e + \"]\";\n  }\n  _port() {\n    return this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? \":\" + this.opts.port : \"\";\n  }\n  _query(e) {\n    const t = Zo(e);\n    return t.length ? \"?\" + t : \"\";\n  }\n}\nconst Cs = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".split(\"\"), Dn = 64, na = {};\nlet Ir = 0, At = 0, Vr;\nfunction jr(n) {\n  let e = \"\";\n  do\n    e = Cs[n % Dn] + e, n = Math.floor(n / Dn);\n  while (n > 0);\n  return e;\n}\nfunction As() {\n  const n = jr(+new Date());\n  return n !== Vr ? (Ir = 0, Vr = n) : n + \".\" + jr(Ir++);\n}\nfor (; At < Dn; At++)\n  na[Cs[At]] = At;\nlet Ds = !1;\ntry {\n  Ds = typeof XMLHttpRequest < \"u\" && \"withCredentials\" in new XMLHttpRequest();\n} catch {\n}\nconst ra = Ds;\nfunction ks(n) {\n  const e = n.xdomain;\n  try {\n    if (typeof XMLHttpRequest < \"u\" && (!e || ra))\n      return new XMLHttpRequest();\n  } catch {\n  }\n  if (!e)\n    try {\n      return new he[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n    } catch {\n    }\n}\nfunction sa() {\n}\nconst ia = function() {\n  return new ks({\n    xdomain: !1\n  }).responseType != null;\n}();\nclass oa extends Hn {\n  constructor(e) {\n    if (super(e), this.polling = !1, typeof location < \"u\") {\n      const r = location.protocol === \"https:\";\n      let s = location.port;\n      s || (s = r ? \"443\" : \"80\"), this.xd = typeof location < \"u\" && e.hostname !== location.hostname || s !== e.port;\n    }\n    const t = e && e.forceBase64;\n    this.supportsBinary = ia && !t, this.opts.withCredentials && (this.cookieJar = void 0);\n  }\n  get name() {\n    return \"polling\";\n  }\n  doOpen() {\n    this.poll();\n  }\n  pause(e) {\n    this.readyState = \"pausing\";\n    const t = () => {\n      this.readyState = \"paused\", e();\n    };\n    if (this.polling || !this.writable) {\n      let r = 0;\n      this.polling && (r++, this.once(\"pollComplete\", function() {\n        --r || t();\n      })), this.writable || (r++, this.once(\"drain\", function() {\n        --r || t();\n      }));\n    } else\n      t();\n  }\n  poll() {\n    this.polling = !0, this.doPoll(), this.emitReserved(\"poll\");\n  }\n  onData(e) {\n    const t = (r) => {\n      if (this.readyState === \"opening\" && r.type === \"open\" && this.onOpen(), r.type === \"close\")\n        return this.onClose({ description: \"transport closed by the server\" }), !1;\n      this.onPacket(r);\n    };\n    Wo(e, this.socket.binaryType).forEach(t), this.readyState !== \"closed\" && (this.polling = !1, this.emitReserved(\"pollComplete\"), this.readyState === \"open\" && this.poll());\n  }\n  doClose() {\n    const e = () => {\n      this.write([{ type: \"close\" }]);\n    };\n    this.readyState === \"open\" ? e() : this.once(\"open\", e);\n  }\n  write(e) {\n    this.writable = !1, Mo(e, (t) => {\n      this.doWrite(t, () => {\n        this.writable = !0, this.emitReserved(\"drain\");\n      });\n    });\n  }\n  uri() {\n    const e = this.opts.secure ? \"https\" : \"http\", t = this.query || {};\n    return this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = As()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.createUri(e, t);\n  }\n  request(e = {}) {\n    return Object.assign(e, { xd: this.xd, cookieJar: this.cookieJar }, this.opts), new me(this.uri(), e);\n  }\n  doWrite(e, t) {\n    const r = this.request({\n      method: \"POST\",\n      data: e\n    });\n    r.on(\"success\", t), r.on(\"error\", (s, i) => {\n      this.onError(\"xhr post error\", s, i);\n    });\n  }\n  doPoll() {\n    const e = this.request();\n    e.on(\"data\", this.onData.bind(this)), e.on(\"error\", (t, r) => {\n      this.onError(\"xhr poll error\", t, r);\n    }), this.pollXhr = e;\n  }\n}\nclass me extends K {\n  constructor(e, t) {\n    super(), Mt(this, t), this.opts = t, this.method = t.method || \"GET\", this.uri = e, this.data = t.data !== void 0 ? t.data : null, this.create();\n  }\n  create() {\n    var e;\n    const t = xs(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n    t.xdomain = !!this.opts.xd;\n    const r = this.xhr = new ks(t);\n    try {\n      r.open(this.method, this.uri, !0);\n      try {\n        if (this.opts.extraHeaders) {\n          r.setDisableHeaderCheck && r.setDisableHeaderCheck(!0);\n          for (let s in this.opts.extraHeaders)\n            this.opts.extraHeaders.hasOwnProperty(s) && r.setRequestHeader(s, this.opts.extraHeaders[s]);\n        }\n      } catch {\n      }\n      if (this.method === \"POST\")\n        try {\n          r.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n        } catch {\n        }\n      try {\n        r.setRequestHeader(\"Accept\", \"*/*\");\n      } catch {\n      }\n      (e = this.opts.cookieJar) === null || e === void 0 || e.addCookies(r), \"withCredentials\" in r && (r.withCredentials = this.opts.withCredentials), this.opts.requestTimeout && (r.timeout = this.opts.requestTimeout), r.onreadystatechange = () => {\n        var s;\n        r.readyState === 3 && ((s = this.opts.cookieJar) === null || s === void 0 || s.parseCookies(r)), r.readyState === 4 && (r.status === 200 || r.status === 1223 ? this.onLoad() : this.setTimeoutFn(() => {\n          this.onError(typeof r.status == \"number\" ? r.status : 0);\n        }, 0));\n      }, r.send(this.data);\n    } catch (s) {\n      this.setTimeoutFn(() => {\n        this.onError(s);\n      }, 0);\n      return;\n    }\n    typeof document < \"u\" && (this.index = me.requestsCount++, me.requests[this.index] = this);\n  }\n  onError(e) {\n    this.emitReserved(\"error\", e, this.xhr), this.cleanup(!0);\n  }\n  cleanup(e) {\n    if (!(typeof this.xhr > \"u\" || this.xhr === null)) {\n      if (this.xhr.onreadystatechange = sa, e)\n        try {\n          this.xhr.abort();\n        } catch {\n        }\n      typeof document < \"u\" && delete me.requests[this.index], this.xhr = null;\n    }\n  }\n  onLoad() {\n    const e = this.xhr.responseText;\n    e !== null && (this.emitReserved(\"data\", e), this.emitReserved(\"success\"), this.cleanup());\n  }\n  abort() {\n    this.cleanup();\n  }\n}\nme.requestsCount = 0;\nme.requests = {};\nif (typeof document < \"u\") {\n  if (typeof attachEvent == \"function\")\n    attachEvent(\"onunload\", $r);\n  else if (typeof addEventListener == \"function\") {\n    const n = \"onpagehide\" in he ? \"pagehide\" : \"unload\";\n    addEventListener(n, $r, !1);\n  }\n}\nfunction $r() {\n  for (let n in me.requests)\n    me.requests.hasOwnProperty(n) && me.requests[n].abort();\n}\nconst Jn = (() => typeof Promise == \"function\" && typeof Promise.resolve == \"function\" ? (e) => Promise.resolve().then(e) : (e, t) => t(e, 0))(), Dt = he.WebSocket || he.MozWebSocket, Mr = !0, aa = \"arraybuffer\", Wr = typeof navigator < \"u\" && typeof navigator.product == \"string\" && navigator.product.toLowerCase() === \"reactnative\";\nclass ua extends Hn {\n  constructor(e) {\n    super(e), this.supportsBinary = !e.forceBase64;\n  }\n  get name() {\n    return \"websocket\";\n  }\n  doOpen() {\n    if (!this.check())\n      return;\n    const e = this.uri(), t = this.opts.protocols, r = Wr ? {} : xs(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n    this.opts.extraHeaders && (r.headers = this.opts.extraHeaders);\n    try {\n      this.ws = Mr && !Wr ? t ? new Dt(e, t) : new Dt(e) : new Dt(e, t, r);\n    } catch (s) {\n      return this.emitReserved(\"error\", s);\n    }\n    this.ws.binaryType = this.socket.binaryType, this.addEventListeners();\n  }\n  addEventListeners() {\n    this.ws.onopen = () => {\n      this.opts.autoUnref && this.ws._socket.unref(), this.onOpen();\n    }, this.ws.onclose = (e) => this.onClose({\n      description: \"websocket connection closed\",\n      context: e\n    }), this.ws.onmessage = (e) => this.onData(e.data), this.ws.onerror = (e) => this.onError(\"websocket error\", e);\n  }\n  write(e) {\n    this.writable = !1;\n    for (let t = 0; t < e.length; t++) {\n      const r = e[t], s = t === e.length - 1;\n      Mn(r, this.supportsBinary, (i) => {\n        const o = {};\n        try {\n          Mr && this.ws.send(i);\n        } catch {\n        }\n        s && Jn(() => {\n          this.writable = !0, this.emitReserved(\"drain\");\n        }, this.setTimeoutFn);\n      });\n    }\n  }\n  doClose() {\n    typeof this.ws < \"u\" && (this.ws.close(), this.ws = null);\n  }\n  uri() {\n    const e = this.opts.secure ? \"wss\" : \"ws\", t = this.query || {};\n    return this.opts.timestampRequests && (t[this.opts.timestampParam] = As()), this.supportsBinary || (t.b64 = 1), this.createUri(e, t);\n  }\n  check() {\n    return !!Dt;\n  }\n}\nclass ca extends Hn {\n  get name() {\n    return \"webtransport\";\n  }\n  doOpen() {\n    typeof WebTransport == \"function\" && (this.transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]), this.transport.closed.then(() => {\n      this.onClose();\n    }).catch((e) => {\n      this.onError(\"webtransport error\", e);\n    }), this.transport.ready.then(() => {\n      this.transport.createBidirectionalStream().then((e) => {\n        const t = Jo(Number.MAX_SAFE_INTEGER, this.socket.binaryType), r = e.readable.pipeThrough(t).getReader(), s = Ho();\n        s.readable.pipeTo(e.writable), this.writer = s.writable.getWriter();\n        const i = () => {\n          r.read().then(({ done: u, value: l }) => {\n            u || (this.onPacket(l), i());\n          }).catch((u) => {\n          });\n        };\n        i();\n        const o = { type: \"open\" };\n        this.query.sid && (o.data = `{\"sid\":\"${this.query.sid}\"}`), this.writer.write(o).then(() => this.onOpen());\n      });\n    }));\n  }\n  write(e) {\n    this.writable = !1;\n    for (let t = 0; t < e.length; t++) {\n      const r = e[t], s = t === e.length - 1;\n      this.writer.write(r).then(() => {\n        s && Jn(() => {\n          this.writable = !0, this.emitReserved(\"drain\");\n        }, this.setTimeoutFn);\n      });\n    }\n  }\n  doClose() {\n    var e;\n    (e = this.transport) === null || e === void 0 || e.close();\n  }\n}\nconst la = {\n  websocket: ua,\n  webtransport: ca,\n  polling: oa\n}, fa = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/, ha = [\n  \"source\",\n  \"protocol\",\n  \"authority\",\n  \"userInfo\",\n  \"user\",\n  \"password\",\n  \"host\",\n  \"port\",\n  \"relative\",\n  \"path\",\n  \"directory\",\n  \"file\",\n  \"query\",\n  \"anchor\"\n];\nfunction kn(n) {\n  const e = n, t = n.indexOf(\"[\"), r = n.indexOf(\"]\");\n  t != -1 && r != -1 && (n = n.substring(0, t) + n.substring(t, r).replace(/:/g, \";\") + n.substring(r, n.length));\n  let s = fa.exec(n || \"\"), i = {}, o = 14;\n  for (; o--; )\n    i[ha[o]] = s[o] || \"\";\n  return t != -1 && r != -1 && (i.source = e, i.host = i.host.substring(1, i.host.length - 1).replace(/;/g, \":\"), i.authority = i.authority.replace(\"[\", \"\").replace(\"]\", \"\").replace(/;/g, \":\"), i.ipv6uri = !0), i.pathNames = da(i, i.path), i.queryKey = pa(i, i.query), i;\n}\nfunction da(n, e) {\n  const t = /\\/{2,9}/g, r = e.replace(t, \"/\").split(\"/\");\n  return (e.slice(0, 1) == \"/\" || e.length === 0) && r.splice(0, 1), e.slice(-1) == \"/\" && r.splice(r.length - 1, 1), r;\n}\nfunction pa(n, e) {\n  const t = {};\n  return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function(r, s, i) {\n    s && (t[s] = i);\n  }), t;\n}\nclass Ce extends K {\n  constructor(e, t = {}) {\n    super(), this.binaryType = aa, this.writeBuffer = [], e && typeof e == \"object\" && (t = e, e = null), e ? (e = kn(e), t.hostname = e.host, t.secure = e.protocol === \"https\" || e.protocol === \"wss\", t.port = e.port, e.query && (t.query = e.query)) : t.host && (t.hostname = kn(t.host).host), Mt(this, t), this.secure = t.secure != null ? t.secure : typeof location < \"u\" && location.protocol === \"https:\", t.hostname && !t.port && (t.port = this.secure ? \"443\" : \"80\"), this.hostname = t.hostname || (typeof location < \"u\" ? location.hostname : \"localhost\"), this.port = t.port || (typeof location < \"u\" && location.port ? location.port : this.secure ? \"443\" : \"80\"), this.transports = t.transports || [\n      \"polling\",\n      \"websocket\",\n      \"webtransport\"\n    ], this.writeBuffer = [], this.prevBufferLen = 0, this.opts = Object.assign({\n      path: \"/engine.io\",\n      agent: !1,\n      withCredentials: !1,\n      upgrade: !0,\n      timestampParam: \"t\",\n      rememberUpgrade: !1,\n      addTrailingSlash: !0,\n      rejectUnauthorized: !0,\n      perMessageDeflate: {\n        threshold: 1024\n      },\n      transportOptions: {},\n      closeOnBeforeunload: !1\n    }, t), this.opts.path = this.opts.path.replace(/\\/$/, \"\") + (this.opts.addTrailingSlash ? \"/\" : \"\"), typeof this.opts.query == \"string\" && (this.opts.query = ea(this.opts.query)), this.id = null, this.upgrades = null, this.pingInterval = null, this.pingTimeout = null, this.pingTimeoutTimer = null, typeof addEventListener == \"function\" && (this.opts.closeOnBeforeunload && (this.beforeunloadEventListener = () => {\n      this.transport && (this.transport.removeAllListeners(), this.transport.close());\n    }, addEventListener(\"beforeunload\", this.beforeunloadEventListener, !1)), this.hostname !== \"localhost\" && (this.offlineEventListener = () => {\n      this.onClose(\"transport close\", {\n        description: \"network connection lost\"\n      });\n    }, addEventListener(\"offline\", this.offlineEventListener, !1))), this.open();\n  }\n  createTransport(e) {\n    const t = Object.assign({}, this.opts.query);\n    t.EIO = Os, t.transport = e, this.id && (t.sid = this.id);\n    const r = Object.assign({}, this.opts, {\n      query: t,\n      socket: this,\n      hostname: this.hostname,\n      secure: this.secure,\n      port: this.port\n    }, this.opts.transportOptions[e]);\n    return new la[e](r);\n  }\n  open() {\n    let e;\n    if (this.opts.rememberUpgrade && Ce.priorWebsocketSuccess && this.transports.indexOf(\"websocket\") !== -1)\n      e = \"websocket\";\n    else if (this.transports.length === 0) {\n      this.setTimeoutFn(() => {\n        this.emitReserved(\"error\", \"No transports available\");\n      }, 0);\n      return;\n    } else\n      e = this.transports[0];\n    this.readyState = \"opening\";\n    try {\n      e = this.createTransport(e);\n    } catch {\n      this.transports.shift(), this.open();\n      return;\n    }\n    e.open(), this.setTransport(e);\n  }\n  setTransport(e) {\n    this.transport && this.transport.removeAllListeners(), this.transport = e, e.on(\"drain\", this.onDrain.bind(this)).on(\"packet\", this.onPacket.bind(this)).on(\"error\", this.onError.bind(this)).on(\"close\", (t) => this.onClose(\"transport close\", t));\n  }\n  probe(e) {\n    let t = this.createTransport(e), r = !1;\n    Ce.priorWebsocketSuccess = !1;\n    const s = () => {\n      r || (t.send([{ type: \"ping\", data: \"probe\" }]), t.once(\"packet\", (f) => {\n        if (!r)\n          if (f.type === \"pong\" && f.data === \"probe\") {\n            if (this.upgrading = !0, this.emitReserved(\"upgrading\", t), !t)\n              return;\n            Ce.priorWebsocketSuccess = t.name === \"websocket\", this.transport.pause(() => {\n              r || this.readyState !== \"closed\" && (h(), this.setTransport(t), t.send([{ type: \"upgrade\" }]), this.emitReserved(\"upgrade\", t), t = null, this.upgrading = !1, this.flush());\n            });\n          } else {\n            const p = new Error(\"probe error\");\n            p.transport = t.name, this.emitReserved(\"upgradeError\", p);\n          }\n      }));\n    };\n    function i() {\n      r || (r = !0, h(), t.close(), t = null);\n    }\n    const o = (f) => {\n      const p = new Error(\"probe error: \" + f);\n      p.transport = t.name, i(), this.emitReserved(\"upgradeError\", p);\n    };\n    function u() {\n      o(\"transport closed\");\n    }\n    function l() {\n      o(\"socket closed\");\n    }\n    function a(f) {\n      t && f.name !== t.name && i();\n    }\n    const h = () => {\n      t.removeListener(\"open\", s), t.removeListener(\"error\", o), t.removeListener(\"close\", u), this.off(\"close\", l), this.off(\"upgrading\", a);\n    };\n    t.once(\"open\", s), t.once(\"error\", o), t.once(\"close\", u), this.once(\"close\", l), this.once(\"upgrading\", a), this.upgrades.indexOf(\"webtransport\") !== -1 && e !== \"webtransport\" ? this.setTimeoutFn(() => {\n      r || t.open();\n    }, 200) : t.open();\n  }\n  onOpen() {\n    if (this.readyState = \"open\", Ce.priorWebsocketSuccess = this.transport.name === \"websocket\", this.emitReserved(\"open\"), this.flush(), this.readyState === \"open\" && this.opts.upgrade) {\n      let e = 0;\n      const t = this.upgrades.length;\n      for (; e < t; e++)\n        this.probe(this.upgrades[e]);\n    }\n  }\n  onPacket(e) {\n    if (this.readyState === \"opening\" || this.readyState === \"open\" || this.readyState === \"closing\")\n      switch (this.emitReserved(\"packet\", e), this.emitReserved(\"heartbeat\"), this.resetPingTimeout(), e.type) {\n        case \"open\":\n          this.onHandshake(JSON.parse(e.data));\n          break;\n        case \"ping\":\n          this.sendPacket(\"pong\"), this.emitReserved(\"ping\"), this.emitReserved(\"pong\");\n          break;\n        case \"error\":\n          const t = new Error(\"server error\");\n          t.code = e.data, this.onError(t);\n          break;\n        case \"message\":\n          this.emitReserved(\"data\", e.data), this.emitReserved(\"message\", e.data);\n          break;\n      }\n  }\n  onHandshake(e) {\n    this.emitReserved(\"handshake\", e), this.id = e.sid, this.transport.query.sid = e.sid, this.upgrades = this.filterUpgrades(e.upgrades), this.pingInterval = e.pingInterval, this.pingTimeout = e.pingTimeout, this.maxPayload = e.maxPayload, this.onOpen(), this.readyState !== \"closed\" && this.resetPingTimeout();\n  }\n  resetPingTimeout() {\n    this.clearTimeoutFn(this.pingTimeoutTimer), this.pingTimeoutTimer = this.setTimeoutFn(() => {\n      this.onClose(\"ping timeout\");\n    }, this.pingInterval + this.pingTimeout), this.opts.autoUnref && this.pingTimeoutTimer.unref();\n  }\n  onDrain() {\n    this.writeBuffer.splice(0, this.prevBufferLen), this.prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved(\"drain\") : this.flush();\n  }\n  flush() {\n    if (this.readyState !== \"closed\" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {\n      const e = this.getWritablePackets();\n      this.transport.send(e), this.prevBufferLen = e.length, this.emitReserved(\"flush\");\n    }\n  }\n  getWritablePackets() {\n    if (!(this.maxPayload && this.transport.name === \"polling\" && this.writeBuffer.length > 1))\n      return this.writeBuffer;\n    let t = 1;\n    for (let r = 0; r < this.writeBuffer.length; r++) {\n      const s = this.writeBuffer[r].data;\n      if (s && (t += Xo(s)), r > 0 && t > this.maxPayload)\n        return this.writeBuffer.slice(0, r);\n      t += 2;\n    }\n    return this.writeBuffer;\n  }\n  write(e, t, r) {\n    return this.sendPacket(\"message\", e, t, r), this;\n  }\n  send(e, t, r) {\n    return this.sendPacket(\"message\", e, t, r), this;\n  }\n  sendPacket(e, t, r, s) {\n    if (typeof t == \"function\" && (s = t, t = void 0), typeof r == \"function\" && (s = r, r = null), this.readyState === \"closing\" || this.readyState === \"closed\")\n      return;\n    r = r || {}, r.compress = r.compress !== !1;\n    const i = {\n      type: e,\n      data: t,\n      options: r\n    };\n    this.emitReserved(\"packetCreate\", i), this.writeBuffer.push(i), s && this.once(\"flush\", s), this.flush();\n  }\n  close() {\n    const e = () => {\n      this.onClose(\"forced close\"), this.transport.close();\n    }, t = () => {\n      this.off(\"upgrade\", t), this.off(\"upgradeError\", t), e();\n    }, r = () => {\n      this.once(\"upgrade\", t), this.once(\"upgradeError\", t);\n    };\n    return (this.readyState === \"opening\" || this.readyState === \"open\") && (this.readyState = \"closing\", this.writeBuffer.length ? this.once(\"drain\", () => {\n      this.upgrading ? r() : e();\n    }) : this.upgrading ? r() : e()), this;\n  }\n  onError(e) {\n    Ce.priorWebsocketSuccess = !1, this.emitReserved(\"error\", e), this.onClose(\"transport error\", e);\n  }\n  onClose(e, t) {\n    (this.readyState === \"opening\" || this.readyState === \"open\" || this.readyState === \"closing\") && (this.clearTimeoutFn(this.pingTimeoutTimer), this.transport.removeAllListeners(\"close\"), this.transport.close(), this.transport.removeAllListeners(), typeof removeEventListener == \"function\" && (removeEventListener(\"beforeunload\", this.beforeunloadEventListener, !1), removeEventListener(\"offline\", this.offlineEventListener, !1)), this.readyState = \"closed\", this.id = null, this.emitReserved(\"close\", e, t), this.writeBuffer = [], this.prevBufferLen = 0);\n  }\n  filterUpgrades(e) {\n    const t = [];\n    let r = 0;\n    const s = e.length;\n    for (; r < s; r++)\n      ~this.transports.indexOf(e[r]) && t.push(e[r]);\n    return t;\n  }\n}\nCe.protocol = Os;\nfunction va(n, e = \"\", t) {\n  let r = n;\n  t = t || typeof location < \"u\" && location, n == null && (n = t.protocol + \"//\" + t.host), typeof n == \"string\" && (n.charAt(0) === \"/\" && (n.charAt(1) === \"/\" ? n = t.protocol + n : n = t.host + n), /^(https?|wss?):\\/\\//.test(n) || (typeof t < \"u\" ? n = t.protocol + \"//\" + n : n = \"https://\" + n), r = kn(n)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = \"80\" : /^(http|ws)s$/.test(r.protocol) && (r.port = \"443\")), r.path = r.path || \"/\";\n  const i = r.host.indexOf(\":\") !== -1 ? \"[\" + r.host + \"]\" : r.host;\n  return r.id = r.protocol + \"://\" + i + \":\" + r.port + e, r.href = r.protocol + \"://\" + i + (t && t.port === r.port ? \"\" : \":\" + r.port), r;\n}\nconst ya = typeof ArrayBuffer == \"function\", ma = (n) => typeof ArrayBuffer.isView == \"function\" ? ArrayBuffer.isView(n) : n.buffer instanceof ArrayBuffer, Ls = Object.prototype.toString, ga = typeof Blob == \"function\" || typeof Blob < \"u\" && Ls.call(Blob) === \"[object BlobConstructor]\", _a = typeof File == \"function\" || typeof File < \"u\" && Ls.call(File) === \"[object FileConstructor]\";\nfunction Yn(n) {\n  return ya && (n instanceof ArrayBuffer || ma(n)) || ga && n instanceof Blob || _a && n instanceof File;\n}\nfunction Pt(n, e) {\n  if (!n || typeof n != \"object\")\n    return !1;\n  if (Array.isArray(n)) {\n    for (let t = 0, r = n.length; t < r; t++)\n      if (Pt(n[t]))\n        return !0;\n    return !1;\n  }\n  if (Yn(n))\n    return !0;\n  if (n.toJSON && typeof n.toJSON == \"function\" && arguments.length === 1)\n    return Pt(n.toJSON(), !0);\n  for (const t in n)\n    if (Object.prototype.hasOwnProperty.call(n, t) && Pt(n[t]))\n      return !0;\n  return !1;\n}\nfunction ba(n) {\n  const e = [], t = n.data, r = n;\n  return r.data = Ln(t, e), r.attachments = e.length, { packet: r, buffers: e };\n}\nfunction Ln(n, e) {\n  if (!n)\n    return n;\n  if (Yn(n)) {\n    const t = { _placeholder: !0, num: e.length };\n    return e.push(n), t;\n  } else if (Array.isArray(n)) {\n    const t = new Array(n.length);\n    for (let r = 0; r < n.length; r++)\n      t[r] = Ln(n[r], e);\n    return t;\n  } else if (typeof n == \"object\" && !(n instanceof Date)) {\n    const t = {};\n    for (const r in n)\n      Object.prototype.hasOwnProperty.call(n, r) && (t[r] = Ln(n[r], e));\n    return t;\n  }\n  return n;\n}\nfunction wa(n, e) {\n  return n.data = Nn(n.data, e), delete n.attachments, n;\n}\nfunction Nn(n, e) {\n  if (!n)\n    return n;\n  if (n && n._placeholder === !0) {\n    if (typeof n.num == \"number\" && n.num >= 0 && n.num < e.length)\n      return e[n.num];\n    throw new Error(\"illegal attachments\");\n  } else if (Array.isArray(n))\n    for (let t = 0; t < n.length; t++)\n      n[t] = Nn(n[t], e);\n  else if (typeof n == \"object\")\n    for (const t in n)\n      Object.prototype.hasOwnProperty.call(n, t) && (n[t] = Nn(n[t], e));\n  return n;\n}\nconst Ea = [\n  \"connect\",\n  \"connect_error\",\n  \"disconnect\",\n  \"disconnecting\",\n  \"newListener\",\n  \"removeListener\"\n], Ra = 5;\nvar O;\n(function(n) {\n  n[n.CONNECT = 0] = \"CONNECT\", n[n.DISCONNECT = 1] = \"DISCONNECT\", n[n.EVENT = 2] = \"EVENT\", n[n.ACK = 3] = \"ACK\", n[n.CONNECT_ERROR = 4] = \"CONNECT_ERROR\", n[n.BINARY_EVENT = 5] = \"BINARY_EVENT\", n[n.BINARY_ACK = 6] = \"BINARY_ACK\";\n})(O || (O = {}));\nclass Sa {\n  constructor(e) {\n    this.replacer = e;\n  }\n  encode(e) {\n    return (e.type === O.EVENT || e.type === O.ACK) && Pt(e) ? this.encodeAsBinary({\n      type: e.type === O.EVENT ? O.BINARY_EVENT : O.BINARY_ACK,\n      nsp: e.nsp,\n      data: e.data,\n      id: e.id\n    }) : [this.encodeAsString(e)];\n  }\n  encodeAsString(e) {\n    let t = \"\" + e.type;\n    return (e.type === O.BINARY_EVENT || e.type === O.BINARY_ACK) && (t += e.attachments + \"-\"), e.nsp && e.nsp !== \"/\" && (t += e.nsp + \",\"), e.id != null && (t += e.id), e.data != null && (t += JSON.stringify(e.data, this.replacer)), t;\n  }\n  encodeAsBinary(e) {\n    const t = ba(e), r = this.encodeAsString(t.packet), s = t.buffers;\n    return s.unshift(r), s;\n  }\n}\nfunction Hr(n) {\n  return Object.prototype.toString.call(n) === \"[object Object]\";\n}\nclass zn extends K {\n  constructor(e) {\n    super(), this.reviver = e;\n  }\n  add(e) {\n    let t;\n    if (typeof e == \"string\") {\n      if (this.reconstructor)\n        throw new Error(\"got plaintext data when reconstructing a packet\");\n      t = this.decodeString(e);\n      const r = t.type === O.BINARY_EVENT;\n      r || t.type === O.BINARY_ACK ? (t.type = r ? O.EVENT : O.ACK, this.reconstructor = new Ta(t), t.attachments === 0 && super.emitReserved(\"decoded\", t)) : super.emitReserved(\"decoded\", t);\n    } else if (Yn(e) || e.base64)\n      if (this.reconstructor)\n        t = this.reconstructor.takeBinaryData(e), t && (this.reconstructor = null, super.emitReserved(\"decoded\", t));\n      else\n        throw new Error(\"got binary data when not reconstructing a packet\");\n    else\n      throw new Error(\"Unknown type: \" + e);\n  }\n  decodeString(e) {\n    let t = 0;\n    const r = {\n      type: Number(e.charAt(0))\n    };\n    if (O[r.type] === void 0)\n      throw new Error(\"unknown packet type \" + r.type);\n    if (r.type === O.BINARY_EVENT || r.type === O.BINARY_ACK) {\n      const i = t + 1;\n      for (; e.charAt(++t) !== \"-\" && t != e.length; )\n        ;\n      const o = e.substring(i, t);\n      if (o != Number(o) || e.charAt(t) !== \"-\")\n        throw new Error(\"Illegal attachments\");\n      r.attachments = Number(o);\n    }\n    if (e.charAt(t + 1) === \"/\") {\n      const i = t + 1;\n      for (; ++t && !(e.charAt(t) === \",\" || t === e.length); )\n        ;\n      r.nsp = e.substring(i, t);\n    } else\n      r.nsp = \"/\";\n    const s = e.charAt(t + 1);\n    if (s !== \"\" && Number(s) == s) {\n      const i = t + 1;\n      for (; ++t; ) {\n        const o = e.charAt(t);\n        if (o == null || Number(o) != o) {\n          --t;\n          break;\n        }\n        if (t === e.length)\n          break;\n      }\n      r.id = Number(e.substring(i, t + 1));\n    }\n    if (e.charAt(++t)) {\n      const i = this.tryParse(e.substr(t));\n      if (zn.isPayloadValid(r.type, i))\n        r.data = i;\n      else\n        throw new Error(\"invalid payload\");\n    }\n    return r;\n  }\n  tryParse(e) {\n    try {\n      return JSON.parse(e, this.reviver);\n    } catch {\n      return !1;\n    }\n  }\n  static isPayloadValid(e, t) {\n    switch (e) {\n      case O.CONNECT:\n        return Hr(t);\n      case O.DISCONNECT:\n        return t === void 0;\n      case O.CONNECT_ERROR:\n        return typeof t == \"string\" || Hr(t);\n      case O.EVENT:\n      case O.BINARY_EVENT:\n        return Array.isArray(t) && (typeof t[0] == \"number\" || typeof t[0] == \"string\" && Ea.indexOf(t[0]) === -1);\n      case O.ACK:\n      case O.BINARY_ACK:\n        return Array.isArray(t);\n    }\n  }\n  destroy() {\n    this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null);\n  }\n}\nclass Ta {\n  constructor(e) {\n    this.packet = e, this.buffers = [], this.reconPack = e;\n  }\n  takeBinaryData(e) {\n    if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) {\n      const t = wa(this.reconPack, this.buffers);\n      return this.finishedReconstruction(), t;\n    }\n    return null;\n  }\n  finishedReconstruction() {\n    this.reconPack = null, this.buffers = [];\n  }\n}\nconst Oa = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  protocol: Ra,\n  get PacketType() {\n    return O;\n  },\n  Encoder: Sa,\n  Decoder: zn\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction pe(n, e, t) {\n  return n.on(e, t), function() {\n    n.off(e, t);\n  };\n}\nconst xa = Object.freeze({\n  connect: 1,\n  connect_error: 1,\n  disconnect: 1,\n  disconnecting: 1,\n  newListener: 1,\n  removeListener: 1\n});\nclass Ns extends K {\n  constructor(e, t, r) {\n    super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = t, r && r.auth && (this.auth = r.auth), this._opts = Object.assign({}, r), this.io._autoConnect && this.open();\n  }\n  get disconnected() {\n    return !this.connected;\n  }\n  subEvents() {\n    if (this.subs)\n      return;\n    const e = this.io;\n    this.subs = [\n      pe(e, \"open\", this.onopen.bind(this)),\n      pe(e, \"packet\", this.onpacket.bind(this)),\n      pe(e, \"error\", this.onerror.bind(this)),\n      pe(e, \"close\", this.onclose.bind(this))\n    ];\n  }\n  get active() {\n    return !!this.subs;\n  }\n  connect() {\n    return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === \"open\" && this.onopen(), this);\n  }\n  open() {\n    return this.connect();\n  }\n  send(...e) {\n    return e.unshift(\"message\"), this.emit.apply(this, e), this;\n  }\n  emit(e, ...t) {\n    if (xa.hasOwnProperty(e))\n      throw new Error('\"' + e.toString() + '\" is a reserved event name');\n    if (t.unshift(e), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile)\n      return this._addToQueue(t), this;\n    const r = {\n      type: O.EVENT,\n      data: t\n    };\n    if (r.options = {}, r.options.compress = this.flags.compress !== !1, typeof t[t.length - 1] == \"function\") {\n      const o = this.ids++, u = t.pop();\n      this._registerAckCallback(o, u), r.id = o;\n    }\n    const s = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;\n    return this.flags.volatile && (!s || !this.connected) || (this.connected ? (this.notifyOutgoingListeners(r), this.packet(r)) : this.sendBuffer.push(r)), this.flags = {}, this;\n  }\n  _registerAckCallback(e, t) {\n    var r;\n    const s = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout;\n    if (s === void 0) {\n      this.acks[e] = t;\n      return;\n    }\n    const i = this.io.setTimeoutFn(() => {\n      delete this.acks[e];\n      for (let o = 0; o < this.sendBuffer.length; o++)\n        this.sendBuffer[o].id === e && this.sendBuffer.splice(o, 1);\n      t.call(this, new Error(\"operation has timed out\"));\n    }, s);\n    this.acks[e] = (...o) => {\n      this.io.clearTimeoutFn(i), t.apply(this, [null, ...o]);\n    };\n  }\n  emitWithAck(e, ...t) {\n    const r = this.flags.timeout !== void 0 || this._opts.ackTimeout !== void 0;\n    return new Promise((s, i) => {\n      t.push((o, u) => r ? o ? i(o) : s(u) : s(o)), this.emit(e, ...t);\n    });\n  }\n  _addToQueue(e) {\n    let t;\n    typeof e[e.length - 1] == \"function\" && (t = e.pop());\n    const r = {\n      id: this._queueSeq++,\n      tryCount: 0,\n      pending: !1,\n      args: e,\n      flags: Object.assign({ fromQueue: !0 }, this.flags)\n    };\n    e.push((s, ...i) => r !== this._queue[0] ? void 0 : (s !== null ? r.tryCount > this._opts.retries && (this._queue.shift(), t && t(s)) : (this._queue.shift(), t && t(null, ...i)), r.pending = !1, this._drainQueue())), this._queue.push(r), this._drainQueue();\n  }\n  _drainQueue(e = !1) {\n    if (!this.connected || this._queue.length === 0)\n      return;\n    const t = this._queue[0];\n    t.pending && !e || (t.pending = !0, t.tryCount++, this.flags = t.flags, this.emit.apply(this, t.args));\n  }\n  packet(e) {\n    e.nsp = this.nsp, this.io._packet(e);\n  }\n  onopen() {\n    typeof this.auth == \"function\" ? this.auth((e) => {\n      this._sendConnectPacket(e);\n    }) : this._sendConnectPacket(this.auth);\n  }\n  _sendConnectPacket(e) {\n    this.packet({\n      type: O.CONNECT,\n      data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, e) : e\n    });\n  }\n  onerror(e) {\n    this.connected || this.emitReserved(\"connect_error\", e);\n  }\n  onclose(e, t) {\n    this.connected = !1, delete this.id, this.emitReserved(\"disconnect\", e, t);\n  }\n  onpacket(e) {\n    if (e.nsp === this.nsp)\n      switch (e.type) {\n        case O.CONNECT:\n          e.data && e.data.sid ? this.onconnect(e.data.sid, e.data.pid) : this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n          break;\n        case O.EVENT:\n        case O.BINARY_EVENT:\n          this.onevent(e);\n          break;\n        case O.ACK:\n        case O.BINARY_ACK:\n          this.onack(e);\n          break;\n        case O.DISCONNECT:\n          this.ondisconnect();\n          break;\n        case O.CONNECT_ERROR:\n          this.destroy();\n          const r = new Error(e.data.message);\n          r.data = e.data.data, this.emitReserved(\"connect_error\", r);\n          break;\n      }\n  }\n  onevent(e) {\n    const t = e.data || [];\n    e.id != null && t.push(this.ack(e.id)), this.connected ? this.emitEvent(t) : this.receiveBuffer.push(Object.freeze(t));\n  }\n  emitEvent(e) {\n    if (this._anyListeners && this._anyListeners.length) {\n      const t = this._anyListeners.slice();\n      for (const r of t)\n        r.apply(this, e);\n    }\n    super.emit.apply(this, e), this._pid && e.length && typeof e[e.length - 1] == \"string\" && (this._lastOffset = e[e.length - 1]);\n  }\n  ack(e) {\n    const t = this;\n    let r = !1;\n    return function(...s) {\n      r || (r = !0, t.packet({\n        type: O.ACK,\n        id: e,\n        data: s\n      }));\n    };\n  }\n  onack(e) {\n    const t = this.acks[e.id];\n    typeof t == \"function\" && (t.apply(this, e.data), delete this.acks[e.id]);\n  }\n  onconnect(e, t) {\n    this.id = e, this.recovered = t && this._pid === t, this._pid = t, this.connected = !0, this.emitBuffered(), this.emitReserved(\"connect\"), this._drainQueue(!0);\n  }\n  emitBuffered() {\n    this.receiveBuffer.forEach((e) => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach((e) => {\n      this.notifyOutgoingListeners(e), this.packet(e);\n    }), this.sendBuffer = [];\n  }\n  ondisconnect() {\n    this.destroy(), this.onclose(\"io server disconnect\");\n  }\n  destroy() {\n    this.subs && (this.subs.forEach((e) => e()), this.subs = void 0), this.io._destroy(this);\n  }\n  disconnect() {\n    return this.connected && this.packet({ type: O.DISCONNECT }), this.destroy(), this.connected && this.onclose(\"io client disconnect\"), this;\n  }\n  close() {\n    return this.disconnect();\n  }\n  compress(e) {\n    return this.flags.compress = e, this;\n  }\n  get volatile() {\n    return this.flags.volatile = !0, this;\n  }\n  timeout(e) {\n    return this.flags.timeout = e, this;\n  }\n  onAny(e) {\n    return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this;\n  }\n  prependAny(e) {\n    return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this;\n  }\n  offAny(e) {\n    if (!this._anyListeners)\n      return this;\n    if (e) {\n      const t = this._anyListeners;\n      for (let r = 0; r < t.length; r++)\n        if (e === t[r])\n          return t.splice(r, 1), this;\n    } else\n      this._anyListeners = [];\n    return this;\n  }\n  listenersAny() {\n    return this._anyListeners || [];\n  }\n  onAnyOutgoing(e) {\n    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e), this;\n  }\n  prependAnyOutgoing(e) {\n    return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e), this;\n  }\n  offAnyOutgoing(e) {\n    if (!this._anyOutgoingListeners)\n      return this;\n    if (e) {\n      const t = this._anyOutgoingListeners;\n      for (let r = 0; r < t.length; r++)\n        if (e === t[r])\n          return t.splice(r, 1), this;\n    } else\n      this._anyOutgoingListeners = [];\n    return this;\n  }\n  listenersAnyOutgoing() {\n    return this._anyOutgoingListeners || [];\n  }\n  notifyOutgoingListeners(e) {\n    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n      const t = this._anyOutgoingListeners.slice();\n      for (const r of t)\n        r.apply(this, e.data);\n    }\n  }\n}\nfunction Xe(n) {\n  n = n || {}, this.ms = n.min || 100, this.max = n.max || 1e4, this.factor = n.factor || 2, this.jitter = n.jitter > 0 && n.jitter <= 1 ? n.jitter : 0, this.attempts = 0;\n}\nXe.prototype.duration = function() {\n  var n = this.ms * Math.pow(this.factor, this.attempts++);\n  if (this.jitter) {\n    var e = Math.random(), t = Math.floor(e * this.jitter * n);\n    n = (Math.floor(e * 10) & 1) == 0 ? n - t : n + t;\n  }\n  return Math.min(n, this.max) | 0;\n};\nXe.prototype.reset = function() {\n  this.attempts = 0;\n};\nXe.prototype.setMin = function(n) {\n  this.ms = n;\n};\nXe.prototype.setMax = function(n) {\n  this.max = n;\n};\nXe.prototype.setJitter = function(n) {\n  this.jitter = n;\n};\nclass Pn extends K {\n  constructor(e, t) {\n    var r;\n    super(), this.nsps = {}, this.subs = [], e && typeof e == \"object\" && (t = e, e = void 0), t = t || {}, t.path = t.path || \"/socket.io\", this.opts = t, Mt(this, t), this.reconnection(t.reconnection !== !1), this.reconnectionAttempts(t.reconnectionAttempts || 1 / 0), this.reconnectionDelay(t.reconnectionDelay || 1e3), this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3), this.randomizationFactor((r = t.randomizationFactor) !== null && r !== void 0 ? r : 0.5), this.backoff = new Xe({\n      min: this.reconnectionDelay(),\n      max: this.reconnectionDelayMax(),\n      jitter: this.randomizationFactor()\n    }), this.timeout(t.timeout == null ? 2e4 : t.timeout), this._readyState = \"closed\", this.uri = e;\n    const s = t.parser || Oa;\n    this.encoder = new s.Encoder(), this.decoder = new s.Decoder(), this._autoConnect = t.autoConnect !== !1, this._autoConnect && this.open();\n  }\n  reconnection(e) {\n    return arguments.length ? (this._reconnection = !!e, this) : this._reconnection;\n  }\n  reconnectionAttempts(e) {\n    return e === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this);\n  }\n  reconnectionDelay(e) {\n    var t;\n    return e === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e, (t = this.backoff) === null || t === void 0 || t.setMin(e), this);\n  }\n  randomizationFactor(e) {\n    var t;\n    return e === void 0 ? this._randomizationFactor : (this._randomizationFactor = e, (t = this.backoff) === null || t === void 0 || t.setJitter(e), this);\n  }\n  reconnectionDelayMax(e) {\n    var t;\n    return e === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, (t = this.backoff) === null || t === void 0 || t.setMax(e), this);\n  }\n  timeout(e) {\n    return arguments.length ? (this._timeout = e, this) : this._timeout;\n  }\n  maybeReconnectOnOpen() {\n    !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect();\n  }\n  open(e) {\n    if (~this._readyState.indexOf(\"open\"))\n      return this;\n    this.engine = new Ce(this.uri, this.opts);\n    const t = this.engine, r = this;\n    this._readyState = \"opening\", this.skipReconnect = !1;\n    const s = pe(t, \"open\", function() {\n      r.onopen(), e && e();\n    }), i = (u) => {\n      this.cleanup(), this._readyState = \"closed\", this.emitReserved(\"error\", u), e ? e(u) : this.maybeReconnectOnOpen();\n    }, o = pe(t, \"error\", i);\n    if (this._timeout !== !1) {\n      const u = this._timeout, l = this.setTimeoutFn(() => {\n        s(), i(new Error(\"timeout\")), t.close();\n      }, u);\n      this.opts.autoUnref && l.unref(), this.subs.push(() => {\n        this.clearTimeoutFn(l);\n      });\n    }\n    return this.subs.push(s), this.subs.push(o), this;\n  }\n  connect(e) {\n    return this.open(e);\n  }\n  onopen() {\n    this.cleanup(), this._readyState = \"open\", this.emitReserved(\"open\");\n    const e = this.engine;\n    this.subs.push(pe(e, \"ping\", this.onping.bind(this)), pe(e, \"data\", this.ondata.bind(this)), pe(e, \"error\", this.onerror.bind(this)), pe(e, \"close\", this.onclose.bind(this)), pe(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n  }\n  onping() {\n    this.emitReserved(\"ping\");\n  }\n  ondata(e) {\n    try {\n      this.decoder.add(e);\n    } catch (t) {\n      this.onclose(\"parse error\", t);\n    }\n  }\n  ondecoded(e) {\n    Jn(() => {\n      this.emitReserved(\"packet\", e);\n    }, this.setTimeoutFn);\n  }\n  onerror(e) {\n    this.emitReserved(\"error\", e);\n  }\n  socket(e, t) {\n    let r = this.nsps[e];\n    return r ? this._autoConnect && !r.active && r.connect() : (r = new Ns(this, e, t), this.nsps[e] = r), r;\n  }\n  _destroy(e) {\n    const t = Object.keys(this.nsps);\n    for (const r of t)\n      if (this.nsps[r].active)\n        return;\n    this._close();\n  }\n  _packet(e) {\n    const t = this.encoder.encode(e);\n    for (let r = 0; r < t.length; r++)\n      this.engine.write(t[r], e.options);\n  }\n  cleanup() {\n    this.subs.forEach((e) => e()), this.subs.length = 0, this.decoder.destroy();\n  }\n  _close() {\n    this.skipReconnect = !0, this._reconnecting = !1, this.onclose(\"forced close\"), this.engine && this.engine.close();\n  }\n  disconnect() {\n    return this._close();\n  }\n  onclose(e, t) {\n    this.cleanup(), this.backoff.reset(), this._readyState = \"closed\", this.emitReserved(\"close\", e, t), this._reconnection && !this.skipReconnect && this.reconnect();\n  }\n  reconnect() {\n    if (this._reconnecting || this.skipReconnect)\n      return this;\n    const e = this;\n    if (this.backoff.attempts >= this._reconnectionAttempts)\n      this.backoff.reset(), this.emitReserved(\"reconnect_failed\"), this._reconnecting = !1;\n    else {\n      const t = this.backoff.duration();\n      this._reconnecting = !0;\n      const r = this.setTimeoutFn(() => {\n        e.skipReconnect || (this.emitReserved(\"reconnect_attempt\", e.backoff.attempts), !e.skipReconnect && e.open((s) => {\n          s ? (e._reconnecting = !1, e.reconnect(), this.emitReserved(\"reconnect_error\", s)) : e.onreconnect();\n        }));\n      }, t);\n      this.opts.autoUnref && r.unref(), this.subs.push(() => {\n        this.clearTimeoutFn(r);\n      });\n    }\n  }\n  onreconnect() {\n    const e = this.backoff.attempts;\n    this._reconnecting = !1, this.backoff.reset(), this.emitReserved(\"reconnect\", e);\n  }\n}\nconst it = {};\nfunction Bt(n, e) {\n  typeof n == \"object\" && (e = n, n = void 0), e = e || {};\n  const t = va(n, e.path || \"/socket.io\"), r = t.source, s = t.id, i = t.path, o = it[s] && i in it[s].nsps, u = e.forceNew || e[\"force new connection\"] || e.multiplex === !1 || o;\n  let l;\n  return u ? l = new Pn(r, e) : (it[s] || (it[s] = new Pn(r, e)), l = it[s]), t.query && !e.query && (e.query = t.queryKey), l.socket(t.path, e);\n}\nObject.assign(Bt, {\n  Manager: Pn,\n  Socket: Ns,\n  io: Bt,\n  connect: Bt\n});\nclass Ca {\n  constructor(e, t, r, s) {\n    xe(this, \"socket_port\");\n    xe(this, \"host\");\n    xe(this, \"port\");\n    xe(this, \"protocol\");\n    xe(this, \"url\");\n    xe(this, \"site_name\");\n    xe(this, \"socket\");\n    var i, o;\n    if (this.socket_port = r != null ? r : \"9000\", this.host = (i = window.location) == null ? void 0 : i.hostname, this.port = (o = window.location) != null && o.port ? `:${this.socket_port}` : \"\", this.protocol = this.port ? \"http\" : \"https\", e) {\n      let u = new URL(e);\n      u.port = \"\", r ? (u.port = r, this.url = u.toString()) : this.url = u.toString();\n    } else\n      this.url = `${this.protocol}://${this.host}${this.port}/`;\n    t && (this.url = `${this.url}${t}`), this.site_name = t, this.socket = Bt(`${this.url}`, {\n      withCredentials: !0,\n      secure: this.protocol === \"https\",\n      extraHeaders: s && s.useToken === !0 ? {\n        Authorization: `${s.type} ${s.token}`\n      } : {}\n    });\n  }\n}\nvar Ps = { exports: {} }, ot = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Jr;\nfunction Aa() {\n  if (Jr)\n    return ot;\n  Jr = 1;\n  var n = (react__WEBPACK_IMPORTED_MODULE_0___default()), e = Symbol.for(\"react.element\"), t = Symbol.for(\"react.fragment\"), r = Object.prototype.hasOwnProperty, s = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function o(u, l, a) {\n    var h, f = {}, p = null, m = null;\n    a !== void 0 && (p = \"\" + a), l.key !== void 0 && (p = \"\" + l.key), l.ref !== void 0 && (m = l.ref);\n    for (h in l)\n      r.call(l, h) && !i.hasOwnProperty(h) && (f[h] = l[h]);\n    if (u && u.defaultProps)\n      for (h in l = u.defaultProps, l)\n        f[h] === void 0 && (f[h] = l[h]);\n    return { $$typeof: e, type: u, key: p, ref: m, props: f, _owner: s.current };\n  }\n  return ot.Fragment = t, ot.jsx = o, ot.jsxs = o, ot;\n}\nvar at = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Yr;\nfunction Da() {\n  return Yr || (Yr = 1,  true && function() {\n    var n = (react__WEBPACK_IMPORTED_MODULE_0___default()), e = Symbol.for(\"react.element\"), t = Symbol.for(\"react.portal\"), r = Symbol.for(\"react.fragment\"), s = Symbol.for(\"react.strict_mode\"), i = Symbol.for(\"react.profiler\"), o = Symbol.for(\"react.provider\"), u = Symbol.for(\"react.context\"), l = Symbol.for(\"react.forward_ref\"), a = Symbol.for(\"react.suspense\"), h = Symbol.for(\"react.suspense_list\"), f = Symbol.for(\"react.memo\"), p = Symbol.for(\"react.lazy\"), m = Symbol.for(\"react.offscreen\"), g = Symbol.iterator, b = \"@@iterator\";\n    function E(c) {\n      if (c === null || typeof c != \"object\")\n        return null;\n      var d = g && c[g] || c[b];\n      return typeof d == \"function\" ? d : null;\n    }\n    var _ = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function S(c) {\n      {\n        for (var d = arguments.length, v = new Array(d > 1 ? d - 1 : 0), w = 1; w < d; w++)\n          v[w - 1] = arguments[w];\n        k(\"error\", c, v);\n      }\n    }\n    function k(c, d, v) {\n      {\n        var w = _.ReactDebugCurrentFrame, A = w.getStackAddendum();\n        A !== \"\" && (d += \"%s\", v = v.concat([A]));\n        var q = v.map(function(x) {\n          return String(x);\n        });\n        q.unshift(\"Warning: \" + d), Function.prototype.apply.call(console[c], console, q);\n      }\n    }\n    var y = !1, M = !1, T = !1, V = !1, D = !1, j;\n    j = Symbol.for(\"react.module.reference\");\n    function L(c) {\n      return !!(typeof c == \"string\" || typeof c == \"function\" || c === r || c === i || D || c === s || c === a || c === h || V || c === m || y || M || T || typeof c == \"object\" && c !== null && (c.$$typeof === p || c.$$typeof === f || c.$$typeof === o || c.$$typeof === u || c.$$typeof === l || c.$$typeof === j || c.getModuleId !== void 0));\n    }\n    function Q(c, d, v) {\n      var w = c.displayName;\n      if (w)\n        return w;\n      var A = d.displayName || d.name || \"\";\n      return A !== \"\" ? v + \"(\" + A + \")\" : v;\n    }\n    function ne(c) {\n      return c.displayName || \"Context\";\n    }\n    function G(c) {\n      if (c == null)\n        return null;\n      if (typeof c.tag == \"number\" && S(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof c == \"function\")\n        return c.displayName || c.name || null;\n      if (typeof c == \"string\")\n        return c;\n      switch (c) {\n        case r:\n          return \"Fragment\";\n        case t:\n          return \"Portal\";\n        case i:\n          return \"Profiler\";\n        case s:\n          return \"StrictMode\";\n        case a:\n          return \"Suspense\";\n        case h:\n          return \"SuspenseList\";\n      }\n      if (typeof c == \"object\")\n        switch (c.$$typeof) {\n          case u:\n            var d = c;\n            return ne(d) + \".Consumer\";\n          case o:\n            var v = c;\n            return ne(v._context) + \".Provider\";\n          case l:\n            return Q(c, c.render, \"ForwardRef\");\n          case f:\n            var w = c.displayName || null;\n            return w !== null ? w : G(c.type) || \"Memo\";\n          case p: {\n            var A = c, q = A._payload, x = A._init;\n            try {\n              return G(x(q));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var F = Object.assign, Le = 0, Qe, Ze, be, et, yt, we, Ee;\n    function Ne() {\n    }\n    Ne.__reactDisabledLog = !0;\n    function mt() {\n      {\n        if (Le === 0) {\n          Qe = console.log, Ze = console.info, be = console.warn, et = console.error, yt = console.group, we = console.groupCollapsed, Ee = console.groupEnd;\n          var c = {\n            configurable: !0,\n            enumerable: !0,\n            value: Ne,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: c,\n            log: c,\n            warn: c,\n            error: c,\n            group: c,\n            groupCollapsed: c,\n            groupEnd: c\n          });\n        }\n        Le++;\n      }\n    }\n    function Ie() {\n      {\n        if (Le--, Le === 0) {\n          var c = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: F({}, c, {\n              value: Qe\n            }),\n            info: F({}, c, {\n              value: Ze\n            }),\n            warn: F({}, c, {\n              value: be\n            }),\n            error: F({}, c, {\n              value: et\n            }),\n            group: F({}, c, {\n              value: yt\n            }),\n            groupCollapsed: F({}, c, {\n              value: we\n            }),\n            groupEnd: F({}, c, {\n              value: Ee\n            })\n          });\n        }\n        Le < 0 && S(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var Ve = _.ReactCurrentDispatcher, je;\n    function $e(c, d, v) {\n      {\n        if (je === void 0)\n          try {\n            throw Error();\n          } catch (A) {\n            var w = A.stack.trim().match(/\\n( *(at )?)/);\n            je = w && w[1] || \"\";\n          }\n        return `\n` + je + c;\n      }\n    }\n    var tt = !1, ve;\n    {\n      var gt = typeof WeakMap == \"function\" ? WeakMap : Map;\n      ve = new gt();\n    }\n    function N(c, d) {\n      if (!c || tt)\n        return \"\";\n      {\n        var v = ve.get(c);\n        if (v !== void 0)\n          return v;\n      }\n      var w;\n      tt = !0;\n      var A = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var q;\n      q = Ve.current, Ve.current = null, mt();\n      try {\n        if (d) {\n          var x = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(x.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(x, []);\n            } catch (Se) {\n              w = Se;\n            }\n            Reflect.construct(c, [], x);\n          } else {\n            try {\n              x.call();\n            } catch (Se) {\n              w = Se;\n            }\n            c.call(x.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (Se) {\n            w = Se;\n          }\n          c();\n        }\n      } catch (Se) {\n        if (Se && w && typeof Se.stack == \"string\") {\n          for (var R = Se.stack.split(`\n`), se = w.stack.split(`\n`), W = R.length - 1, Y = se.length - 1; W >= 1 && Y >= 0 && R[W] !== se[Y]; )\n            Y--;\n          for (; W >= 1 && Y >= 0; W--, Y--)\n            if (R[W] !== se[Y]) {\n              if (W !== 1 || Y !== 1)\n                do\n                  if (W--, Y--, Y < 0 || R[W] !== se[Y]) {\n                    var le = `\n` + R[W].replace(\" at new \", \" at \");\n                    return c.displayName && le.includes(\"<anonymous>\") && (le = le.replace(\"<anonymous>\", c.displayName)), typeof c == \"function\" && ve.set(c, le), le;\n                  }\n                while (W >= 1 && Y >= 0);\n              break;\n            }\n        }\n      } finally {\n        tt = !1, Ve.current = q, Ie(), Error.prepareStackTrace = A;\n      }\n      var Je = c ? c.displayName || c.name : \"\", rr = Je ? $e(Je) : \"\";\n      return typeof c == \"function\" && ve.set(c, rr), rr;\n    }\n    function U(c, d, v) {\n      return N(c, !1);\n    }\n    function X(c) {\n      var d = c.prototype;\n      return !!(d && d.isReactComponent);\n    }\n    function I(c, d, v) {\n      if (c == null)\n        return \"\";\n      if (typeof c == \"function\")\n        return N(c, X(c));\n      if (typeof c == \"string\")\n        return $e(c);\n      switch (c) {\n        case a:\n          return $e(\"Suspense\");\n        case h:\n          return $e(\"SuspenseList\");\n      }\n      if (typeof c == \"object\")\n        switch (c.$$typeof) {\n          case l:\n            return U(c.render);\n          case f:\n            return I(c.type, d, v);\n          case p: {\n            var w = c, A = w._payload, q = w._init;\n            try {\n              return I(q(A), d, v);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var re = Object.prototype.hasOwnProperty, Re = {}, H = _.ReactDebugCurrentFrame;\n    function J(c) {\n      if (c) {\n        var d = c._owner, v = I(c.type, c._source, d ? d.type : null);\n        H.setExtraStackFrame(v);\n      } else\n        H.setExtraStackFrame(null);\n    }\n    function de(c, d, v, w, A) {\n      {\n        var q = Function.call.bind(re);\n        for (var x in c)\n          if (q(c, x)) {\n            var R = void 0;\n            try {\n              if (typeof c[x] != \"function\") {\n                var se = Error((w || \"React class\") + \": \" + v + \" type `\" + x + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof c[x] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw se.name = \"Invariant Violation\", se;\n              }\n              R = c[x](d, x, w, v, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (W) {\n              R = W;\n            }\n            R && !(R instanceof Error) && (J(A), S(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", w || \"React class\", v, x, typeof R), J(null)), R instanceof Error && !(R.message in Re) && (Re[R.message] = !0, J(A), S(\"Failed %s type: %s\", v, R.message), J(null));\n          }\n      }\n    }\n    var _t = Array.isArray;\n    function Me(c) {\n      return _t(c);\n    }\n    function bt(c) {\n      {\n        var d = typeof Symbol == \"function\" && Symbol.toStringTag, v = d && c[Symbol.toStringTag] || c.constructor.name || \"Object\";\n        return v;\n      }\n    }\n    function ie(c) {\n      try {\n        return ce(c), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function ce(c) {\n      return \"\" + c;\n    }\n    function We(c) {\n      if (ie(c))\n        return S(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", bt(c)), ce(c);\n    }\n    var Pe = _.ReactCurrentOwner, nt = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, Kn, Gn, Wt;\n    Wt = {};\n    function Us(c) {\n      if (re.call(c, \"ref\")) {\n        var d = Object.getOwnPropertyDescriptor(c, \"ref\").get;\n        if (d && d.isReactWarning)\n          return !1;\n      }\n      return c.ref !== void 0;\n    }\n    function qs(c) {\n      if (re.call(c, \"key\")) {\n        var d = Object.getOwnPropertyDescriptor(c, \"key\").get;\n        if (d && d.isReactWarning)\n          return !1;\n      }\n      return c.key !== void 0;\n    }\n    function Is(c, d) {\n      if (typeof c.ref == \"string\" && Pe.current && d && Pe.current.stateNode !== d) {\n        var v = G(Pe.current.type);\n        Wt[v] || (S('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', G(Pe.current.type), c.ref), Wt[v] = !0);\n      }\n    }\n    function Vs(c, d) {\n      {\n        var v = function() {\n          Kn || (Kn = !0, S(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", d));\n        };\n        v.isReactWarning = !0, Object.defineProperty(c, \"key\", {\n          get: v,\n          configurable: !0\n        });\n      }\n    }\n    function js(c, d) {\n      {\n        var v = function() {\n          Gn || (Gn = !0, S(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", d));\n        };\n        v.isReactWarning = !0, Object.defineProperty(c, \"ref\", {\n          get: v,\n          configurable: !0\n        });\n      }\n    }\n    var $s = function(c, d, v, w, A, q, x) {\n      var R = {\n        $$typeof: e,\n        type: c,\n        key: d,\n        ref: v,\n        props: x,\n        _owner: q\n      };\n      return R._store = {}, Object.defineProperty(R._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(R, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: w\n      }), Object.defineProperty(R, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: A\n      }), Object.freeze && (Object.freeze(R.props), Object.freeze(R)), R;\n    };\n    function Ms(c, d, v, w, A) {\n      {\n        var q, x = {}, R = null, se = null;\n        v !== void 0 && (We(v), R = \"\" + v), qs(d) && (We(d.key), R = \"\" + d.key), Us(d) && (se = d.ref, Is(d, A));\n        for (q in d)\n          re.call(d, q) && !nt.hasOwnProperty(q) && (x[q] = d[q]);\n        if (c && c.defaultProps) {\n          var W = c.defaultProps;\n          for (q in W)\n            x[q] === void 0 && (x[q] = W[q]);\n        }\n        if (R || se) {\n          var Y = typeof c == \"function\" ? c.displayName || c.name || \"Unknown\" : c;\n          R && Vs(x, Y), se && js(x, Y);\n        }\n        return $s(c, R, se, A, w, Pe.current, x);\n      }\n    }\n    var Ht = _.ReactCurrentOwner, Xn = _.ReactDebugCurrentFrame;\n    function He(c) {\n      if (c) {\n        var d = c._owner, v = I(c.type, c._source, d ? d.type : null);\n        Xn.setExtraStackFrame(v);\n      } else\n        Xn.setExtraStackFrame(null);\n    }\n    var Jt;\n    Jt = !1;\n    function Yt(c) {\n      return typeof c == \"object\" && c !== null && c.$$typeof === e;\n    }\n    function Qn() {\n      {\n        if (Ht.current) {\n          var c = G(Ht.current.type);\n          if (c)\n            return `\n\nCheck the render method of \\`` + c + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function Ws(c) {\n      {\n        if (c !== void 0) {\n          var d = c.fileName.replace(/^.*[\\\\\\/]/, \"\"), v = c.lineNumber;\n          return `\n\nCheck your code at ` + d + \":\" + v + \".\";\n        }\n        return \"\";\n      }\n    }\n    var Zn = {};\n    function Hs(c) {\n      {\n        var d = Qn();\n        if (!d) {\n          var v = typeof c == \"string\" ? c : c.displayName || c.name;\n          v && (d = `\n\nCheck the top-level render call using <` + v + \">.\");\n        }\n        return d;\n      }\n    }\n    function er(c, d) {\n      {\n        if (!c._store || c._store.validated || c.key != null)\n          return;\n        c._store.validated = !0;\n        var v = Hs(d);\n        if (Zn[v])\n          return;\n        Zn[v] = !0;\n        var w = \"\";\n        c && c._owner && c._owner !== Ht.current && (w = \" It was passed a child from \" + G(c._owner.type) + \".\"), He(c), S('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', v, w), He(null);\n      }\n    }\n    function tr(c, d) {\n      {\n        if (typeof c != \"object\")\n          return;\n        if (Me(c))\n          for (var v = 0; v < c.length; v++) {\n            var w = c[v];\n            Yt(w) && er(w, d);\n          }\n        else if (Yt(c))\n          c._store && (c._store.validated = !0);\n        else if (c) {\n          var A = E(c);\n          if (typeof A == \"function\" && A !== c.entries)\n            for (var q = A.call(c), x; !(x = q.next()).done; )\n              Yt(x.value) && er(x.value, d);\n        }\n      }\n    }\n    function Js(c) {\n      {\n        var d = c.type;\n        if (d == null || typeof d == \"string\")\n          return;\n        var v;\n        if (typeof d == \"function\")\n          v = d.propTypes;\n        else if (typeof d == \"object\" && (d.$$typeof === l || d.$$typeof === f))\n          v = d.propTypes;\n        else\n          return;\n        if (v) {\n          var w = G(d);\n          de(v, c.props, \"prop\", w, c);\n        } else if (d.PropTypes !== void 0 && !Jt) {\n          Jt = !0;\n          var A = G(d);\n          S(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", A || \"Unknown\");\n        }\n        typeof d.getDefaultProps == \"function\" && !d.getDefaultProps.isReactClassApproved && S(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function Ys(c) {\n      {\n        for (var d = Object.keys(c.props), v = 0; v < d.length; v++) {\n          var w = d[v];\n          if (w !== \"children\" && w !== \"key\") {\n            He(c), S(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", w), He(null);\n            break;\n          }\n        }\n        c.ref !== null && (He(c), S(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), He(null));\n      }\n    }\n    function nr(c, d, v, w, A, q) {\n      {\n        var x = L(c);\n        if (!x) {\n          var R = \"\";\n          (c === void 0 || typeof c == \"object\" && c !== null && Object.keys(c).length === 0) && (R += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var se = Ws(A);\n          se ? R += se : R += Qn();\n          var W;\n          c === null ? W = \"null\" : Me(c) ? W = \"array\" : c !== void 0 && c.$$typeof === e ? (W = \"<\" + (G(c.type) || \"Unknown\") + \" />\", R = \" Did you accidentally export a JSX literal instead of a component?\") : W = typeof c, S(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", W, R);\n        }\n        var Y = Ms(c, d, v, A, q);\n        if (Y == null)\n          return Y;\n        if (x) {\n          var le = d.children;\n          if (le !== void 0)\n            if (w)\n              if (Me(le)) {\n                for (var Je = 0; Je < le.length; Je++)\n                  tr(le[Je], c);\n                Object.freeze && Object.freeze(le);\n              } else\n                S(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              tr(le, c);\n        }\n        return c === r ? Ys(Y) : Js(Y), Y;\n      }\n    }\n    function zs(c, d, v) {\n      return nr(c, d, v, !0);\n    }\n    function Ks(c, d, v) {\n      return nr(c, d, v, !1);\n    }\n    var Gs = Ks, Xs = zs;\n    at.Fragment = r, at.jsx = Gs, at.jsxs = Xs;\n  }()), at;\n}\n(function(n) {\n   false ? 0 : n.exports = Da();\n})(Ps);\nconst ka = Ps.exports.jsx, te = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null), Ua = ({\n  url: n = \"\",\n  tokenParams: e,\n  socketPort: t,\n  siteName: r,\n  enableSocket: s = !0,\n  children: i\n}) => {\n  const o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n    const u = new oo.FrappeApp(n, e);\n    return {\n      url: n,\n      tokenParams: e,\n      app: u,\n      auth: u.auth(),\n      db: u.db(),\n      call: u.call(),\n      file: u.file(),\n      socket: s ? new Ca(n, r, t, e).socket : void 0,\n      enableSocket: s,\n      socketPort: t\n    };\n  }, [n, e, t, s]);\n  return /* @__PURE__ */ ka(te.Provider, {\n    value: o,\n    children: i\n  });\n}, qa = (n) => {\n  const {\n    url: e,\n    auth: t,\n    tokenParams: r\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(te), [s, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(), o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    const g = document.cookie.split(\";\").find((b) => b.trim().startsWith(\"user_id=\"));\n    if (g) {\n      const b = g.split(\"=\")[1];\n      i(b && b !== \"Guest\" ? b : null);\n    } else\n      i(null);\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    r && r.useToken ? i(null) : o();\n  }, []);\n  const {\n    data: u,\n    error: l,\n    isLoading: a,\n    isValidating: h,\n    mutate: f\n  } = vt(() => r && r.useToken || s ? `${e}/api/method/frappe.auth.get_logged_user` : null, () => t.getLoggedInUser(), {\n    onError: () => {\n      i(null);\n    },\n    shouldRetryOnError: !1,\n    revalidateOnFocus: !1,\n    ...n\n  }), p = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (g, b) => t.loginWithUsernamePassword({\n    username: g,\n    password: b\n  }).then((E) => {\n    o();\n  }), []), m = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => t.logout().then(() => f(null)).then(() => i(null)), []);\n  return {\n    isLoading: s === void 0 || a,\n    currentUser: u,\n    isValidating: h,\n    error: l,\n    login: p,\n    logout: m,\n    updateCurrentUser: f,\n    getUserCookie: o\n  };\n}, Bs = (n, e, t) => {\n  let r = `${e}/api/resource/`;\n  return t ? r += `${n}/${t}` : r += `${n}`, r;\n}, Ia = (n, e, t, r) => {\n  const {\n    url: s,\n    db: i\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(te);\n  return {\n    ...vt(t === void 0 ? Bs(n, s, e) : t, () => i.getDoc(n, e), r)\n  };\n}, La = (n) => {\n  var t, r, s;\n  let e = \"\";\n  if (n != null && n.fields && (e += \"fields=\" + JSON.stringify(n == null ? void 0 : n.fields) + \"&\"), n != null && n.filters && (e += \"filters=\" + JSON.stringify(n == null ? void 0 : n.filters) + \"&\"), n != null && n.orFilters && (e += \"or_filters=\" + JSON.stringify(n == null ? void 0 : n.orFilters) + \"&\"), n != null && n.limit_start && (e += \"limit_start=\" + JSON.stringify(n == null ? void 0 : n.limit_start) + \"&\"), n != null && n.limit && (e += \"limit=\" + JSON.stringify(n == null ? void 0 : n.limit) + \"&\"), n != null && n.groupBy && (e += \"group_by=\" + String(n.groupBy) + \"&\"), n != null && n.orderBy) {\n    const i = `${String((t = n.orderBy) == null ? void 0 : t.field)} ${(s = (r = n.orderBy) == null ? void 0 : r.order) != null ? s : \"asc\"}`;\n    e += \"order_by=\" + i + \"&\";\n  }\n  return n != null && n.asDict && (e += \"as_dict=\" + n.asDict), e;\n}, Va = (n, e, t, r) => {\n  const {\n    url: s,\n    db: i\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(te);\n  return {\n    ...vt(t === void 0 ? `${Bs(n, s)}?${La(e)}` : t, () => i.getDocList(n, e), r)\n  };\n}, ja = () => {\n  const {\n    db: n\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(te), [e, t] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [r, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [i, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    t(!1), s(null), o(!1);\n  }, []);\n  return {\n    createDoc: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (a, h) => (s(null), o(!1), t(!0), n.createDoc(a, h).then((f) => (t(!1), o(!0), f)).catch((f) => {\n      throw t(!1), o(!1), s(f), f;\n    })), []),\n    loading: e,\n    error: r,\n    isCompleted: i,\n    reset: u\n  };\n}, $a = () => {\n  const {\n    db: n\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(te), [e, t] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [r, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [i, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    t(!1), s(null), o(!1);\n  }, []);\n  return {\n    updateDoc: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (a, h, f) => (s(null), o(!1), t(!0), n.updateDoc(a, h, f).then((p) => (t(!1), o(!0), p)).catch((p) => {\n      throw t(!1), o(!1), s(p), p;\n    })), []),\n    loading: e,\n    error: r,\n    reset: u,\n    isCompleted: i\n  };\n}, Ma = () => {\n  const {\n    db: n\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(te), [e, t] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [r, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [i, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    t(!1), s(null), o(!1);\n  }, []);\n  return {\n    deleteDoc: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (a, h) => (s(null), o(!1), t(!0), n.deleteDoc(a, h).then((f) => (t(!1), o(!0), f)).catch((f) => {\n      throw t(!1), o(!1), s(f), f;\n    })), []),\n    loading: e,\n    error: r,\n    reset: u,\n    isCompleted: i\n  };\n};\nfunction Fs(n) {\n  const e = [];\n  for (let t in n)\n    e.push(encodeURIComponent(t) + \"=\" + encodeURIComponent(n[t]));\n  return e.join(\"&\");\n}\nconst Wa = (n, e, t = !1, r = !1, s, i) => {\n  const {\n    url: o,\n    db: u\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(te);\n  return {\n    ...vt(s === void 0 ? (() => {\n      const h = Fs(t ? {\n        doctype: n,\n        filters: e != null ? e : [],\n        cache: t,\n        debug: r\n      } : {\n        doctype: n,\n        filters: e != null ? e : [],\n        debug: r\n      });\n      return `${o}/api/method/frappe.client.get_count?${h}`;\n    })() : s, () => u.getCount(n, e, t, r), i)\n  };\n}, Na = (n, e, t, r) => {\n  const {\n    call: s\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(te), i = Fs(e != null ? e : {}), o = `${n}?${i}`;\n  return {\n    ...vt(t === void 0 ? o : t, () => s.get(n, e), r)\n  };\n}, Ha = (n) => {\n  const {\n    call: e\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(te), [t, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [s, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [o, u] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [l, a] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    r(null), i(!1), u(null), a(!1);\n  }, []);\n  return {\n    call: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (p) => (u(null), a(!1), i(!0), r(null), e.post(n, p).then((m) => (r(m), i(!1), a(!0), m)).catch((m) => {\n      throw i(!1), a(!1), u(m), m;\n    })), []),\n    result: t,\n    loading: s,\n    error: o,\n    reset: h,\n    isCompleted: l\n  };\n}, Ja = (n) => {\n  const {\n    call: e\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(te), [t, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [s, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [o, u] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [l, a] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    r(null), i(!1), u(null), a(!1);\n  }, []);\n  return {\n    call: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (p) => (u(null), a(!1), i(!0), r(null), e.put(n, p).then((m) => (r(m), i(!1), a(!0), m)).catch((m) => {\n      throw i(!1), a(!1), u(m), m;\n    })), []),\n    result: t,\n    loading: s,\n    error: o,\n    reset: h,\n    isCompleted: l\n  };\n}, Ya = (n) => {\n  const {\n    call: e\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(te), [t, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [s, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [o, u] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [l, a] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    r(null), i(!1), u(null), a(!1);\n  }, []);\n  return {\n    call: (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (p) => (u(null), a(!1), i(!0), r(null), e.delete(n, p).then((m) => (r(m), i(!1), a(!0), m)).catch((m) => {\n      throw i(!1), a(!1), u(m), m;\n    })), []),\n    result: t,\n    loading: s,\n    error: o,\n    reset: h,\n    isCompleted: l\n  };\n}, za = () => {\n  const {\n    file: n\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(te), [e, t] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), [r, s] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [i, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [u, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (f, p, m) => (h(), s(!0), n.uploadFile(f, p, (g, b) => t(Math.round(g / b * 100)), m).then((g) => (l(!0), t(100), s(!1), g.data.message)).catch((g) => {\n    throw console.error(g), o(g), s(!1), g;\n  })), []), h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    t(0), s(!1), o(null), l(!1);\n  }, []);\n  return {\n    upload: a,\n    progress: e,\n    loading: r,\n    isCompleted: u,\n    error: i,\n    reset: h\n  };\n}, Ka = (n, e, t = [], r = 20, s = 250) => {\n  const i = Pa(e, s);\n  return Na(\"frappe.desk.search.search_link\", {\n    doctype: n,\n    page_length: r,\n    txt: i,\n    filters: JSON.stringify(t != null ? t : [])\n  });\n}, Pa = (n, e) => {\n  const [t, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(n);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    const s = setTimeout(() => {\n      r(n);\n    }, e);\n    return () => {\n      clearTimeout(s);\n    };\n  }, [n, e]), t;\n}, Bn = (n, e) => {\n  const {\n    socket: t\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(te);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    t === void 0 && console.warn(\"Socket is not enabled. Please enable socket in FrappeProvider.\");\n    let r = t == null ? void 0 : t.on(n, e);\n    return () => {\n      r == null || r.off(n);\n    };\n  }, [n, e]);\n}, Ga = (n, e, t, r = !0) => {\n  const {\n    socket: s\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(te), [i, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => (s === void 0 && console.warn(\"Socket is not enabled. Please enable socket in FrappeProvider.\"), s == null || s.emit(\"doc_subscribe\", n, e), r && (s == null || s.emit(\"doc_open\", n, e)), () => {\n    s == null || s.emit(\"doc_unsubscribe\", n, e), r && (s == null || s.emit(\"doc_close\", n, e));\n  }), [n, e, r]), Bn(\"doc_update\", t);\n  const u = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    s == null || s.emit(\"doc_open\", n, e);\n  }, [n, e]), l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    s == null || s.emit(\"doc_close\", n, e);\n  }, [n, e]), a = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((h) => {\n    h.doctype === n && h.docname === e && o(h.users);\n  }, [n, e]);\n  return Bn(\"doc_viewers\", a), {\n    viewers: i,\n    emitDocOpen: u,\n    emitDocClose: l\n  };\n}, Xa = (n, e) => {\n  const {\n    socket: t\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(te);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => (t === void 0 && console.warn(\"Socket is not enabled. Please enable socket in FrappeProvider.\"), t == null || t.emit(\"doctype_subscribe\", n), () => {\n    t == null || t.emit(\"doctype_unsubscribe\", n);\n  }), [n]), Bn(\"list_update\", e);\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZnJhcHBlLXJlYWN0LXNkay9kaXN0L2ZyYXBwZS1yZWFjdC1zZGsuZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSwwQ0FBMEMsMERBQTBEO0FBQ3BHO0FBQzZMO0FBQzdMLDBJQUEwSSxTQUFTLFNBQVMsU0FBUztBQUNySztBQUNBLDZDQUE2QyxPQUFPO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUcscUJBQXFCO0FBQ3hCLGVBQWUsdUNBQXVDO0FBQ3REO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFdBQVc7QUFDekU7QUFDQSxTQUFTO0FBQ1Q7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QUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBQQUEwUDtBQUMxUCxPQUFPO0FBQ1A7QUFDQSxzREFBc0QscUJBQXFCO0FBQzNFO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNRQUFzUTtBQUN0USxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSwwR0FBMEc7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7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Q0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtFQUErRTtBQUMxRztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0JBQWdCO0FBQ2pE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QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBLElBQUksRUFBRSxpREFBRSxlQUFlLCtDQUFDO0FBQ3hCLEVBQUUsZ0RBQUU7QUFDSjtBQUNBLEdBQUc7QUFDSCxZQUFZLGtEQUFDO0FBQ2I7QUFDQSxHQUFHLGVBQWUsa0RBQUM7QUFDbkI7QUFDQSxHQUFHLGVBQWUsa0RBQUM7QUFDbkI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsSUFBSSxFQUFFLGlEQUFFO0FBQ1IsRUFBRSxnREFBRTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBd0JFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYmxvZ2NyZWF0b3IvLi9ub2RlX21vZHVsZXMvZnJhcHBlLXJlYWN0LXNkay9kaXN0L2ZyYXBwZS1yZWFjdC1zZGsuZXMuanM/MDQ3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgWnMgPSAobiwgZSwgdCkgPT4gZSBpbiBuID8gUXMobiwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogdCB9KSA6IG5bZV0gPSB0O1xudmFyIHhlID0gKG4sIGUsIHQpID0+IChacyhuLCB0eXBlb2YgZSAhPSBcInN5bWJvbFwiID8gZSArIFwiXCIgOiBlLCB0KSwgdCk7XG5pbXBvcnQgcWUsIHsgY3JlYXRlQ29udGV4dCBhcyB6ciwgdXNlQ29udGV4dCBhcyBlZSwgdXNlRWZmZWN0IGFzIEdlLCB1c2VMYXlvdXRFZmZlY3QgYXMgZWksIHVzZVJlZiBhcyBCZSwgdXNlTWVtbyBhcyBLciwgdXNlQ2FsbGJhY2sgYXMgJCwgdXNlRGVidWdWYWx1ZSBhcyB0aSwgdXNlU3RhdGUgYXMgUCB9IGZyb20gXCJyZWFjdFwiO1xudmFyIEIgPSB0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgPCBcInVcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmIDwgXCJ1XCIgPyBzZWxmIDoge30sIHp0ID0ge30sIHJ0ID0ge30sIGZ0ID0ge30sIGZlID0gQiAmJiBCLl9fYXNzaWduIHx8IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZmUgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKG4pIHtcbiAgICBmb3IgKHZhciBlLCB0ID0gMSwgciA9IGFyZ3VtZW50cy5sZW5ndGg7IHQgPCByOyB0KyspIHtcbiAgICAgIGUgPSBhcmd1bWVudHNbdF07XG4gICAgICBmb3IgKHZhciBzIGluIGUpXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCBzKSAmJiAobltzXSA9IGVbc10pO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfSwgZmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0sIHd0ID0gQiAmJiBCLl9fYXdhaXRlciB8fCBmdW5jdGlvbihuLCBlLCB0LCByKSB7XG4gIGZ1bmN0aW9uIHMoaSkge1xuICAgIHJldHVybiBpIGluc3RhbmNlb2YgdCA/IGkgOiBuZXcgdChmdW5jdGlvbihvKSB7XG4gICAgICBvKGkpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXcgKHQgfHwgKHQgPSBQcm9taXNlKSkoZnVuY3Rpb24oaSwgbykge1xuICAgIGZ1bmN0aW9uIHUoaCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYShyLm5leHQoaCkpO1xuICAgICAgfSBjYXRjaCAoZikge1xuICAgICAgICBvKGYpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsKGgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGEoci50aHJvdyhoKSk7XG4gICAgICB9IGNhdGNoIChmKSB7XG4gICAgICAgIG8oZik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGEoaCkge1xuICAgICAgaC5kb25lID8gaShoLnZhbHVlKSA6IHMoaC52YWx1ZSkudGhlbih1LCBsKTtcbiAgICB9XG4gICAgYSgociA9IHIuYXBwbHkobiwgZSB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufSwgRXQgPSBCICYmIEIuX19nZW5lcmF0b3IgfHwgZnVuY3Rpb24obiwgZSkge1xuICB2YXIgdCA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmIChpWzBdICYgMSlcbiAgICAgIHRocm93IGlbMV07XG4gICAgcmV0dXJuIGlbMV07XG4gIH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIHIsIHMsIGksIG87XG4gIHJldHVybiBvID0geyBuZXh0OiB1KDApLCB0aHJvdzogdSgxKSwgcmV0dXJuOiB1KDIpIH0sIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIChvW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIG87XG4gIGZ1bmN0aW9uIHUoYSkge1xuICAgIHJldHVybiBmdW5jdGlvbihoKSB7XG4gICAgICByZXR1cm4gbChbYSwgaF0pO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gbChhKSB7XG4gICAgaWYgKHIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICBmb3IgKDsgdDsgKVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHIgPSAxLCBzICYmIChpID0gYVswXSAmIDIgPyBzLnJldHVybiA6IGFbMF0gPyBzLnRocm93IHx8ICgoaSA9IHMucmV0dXJuKSAmJiBpLmNhbGwocyksIDApIDogcy5uZXh0KSAmJiAhKGkgPSBpLmNhbGwocywgYVsxXSkpLmRvbmUpXG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIHN3aXRjaCAocyA9IDAsIGkgJiYgKGEgPSBbYVswXSAmIDIsIGkudmFsdWVdKSwgYVswXSkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBpID0gYTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiB0LmxhYmVsKyssIHsgdmFsdWU6IGFbMV0sIGRvbmU6ICExIH07XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdC5sYWJlbCsrLCBzID0gYVsxXSwgYSA9IFswXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGEgPSB0Lm9wcy5wb3AoKSwgdC50cnlzLnBvcCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChpID0gdC50cnlzLCAhKGkgPSBpLmxlbmd0aCA+IDAgJiYgaVtpLmxlbmd0aCAtIDFdKSAmJiAoYVswXSA9PT0gNiB8fCBhWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICB0ID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYVswXSA9PT0gMyAmJiAoIWkgfHwgYVsxXSA+IGlbMF0gJiYgYVsxXSA8IGlbM10pKSB7XG4gICAgICAgICAgICAgIHQubGFiZWwgPSBhWzFdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhWzBdID09PSA2ICYmIHQubGFiZWwgPCBpWzFdKSB7XG4gICAgICAgICAgICAgIHQubGFiZWwgPSBpWzFdLCBpID0gYTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSAmJiB0LmxhYmVsIDwgaVsyXSkge1xuICAgICAgICAgICAgICB0LmxhYmVsID0gaVsyXSwgdC5vcHMucHVzaChhKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpWzJdICYmIHQub3BzLnBvcCgpLCB0LnRyeXMucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBhID0gZS5jYWxsKG4sIHQpO1xuICAgICAgfSBjYXRjaCAoaCkge1xuICAgICAgICBhID0gWzYsIGhdLCBzID0gMDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHIgPSBpID0gMDtcbiAgICAgIH1cbiAgICBpZiAoYVswXSAmIDUpXG4gICAgICB0aHJvdyBhWzFdO1xuICAgIHJldHVybiB7IHZhbHVlOiBhWzBdID8gYVsxXSA6IHZvaWQgMCwgZG9uZTogITAgfTtcbiAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShmdCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuZnQuRnJhcHBlQ2FsbCA9IHZvaWQgMDtcbnZhciBuaSA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBuKGUsIHQsIHIsIHMsIGkpIHtcbiAgICB0aGlzLmFwcFVSTCA9IGUsIHRoaXMuYXhpb3MgPSB0LCB0aGlzLnVzZVRva2VuID0gciAhPSBudWxsID8gciA6ICExLCB0aGlzLnRva2VuID0gcywgdGhpcy50b2tlblR5cGUgPSBpO1xuICB9XG4gIHJldHVybiBuLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgcmV0dXJuIHd0KHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBFdCh0aGlzLCBmdW5jdGlvbihyKSB7XG4gICAgICAgIHJldHVybiBbMiwgdGhpcy5heGlvcy5nZXQoXCIvYXBpL21ldGhvZC9cIi5jb25jYXQoZSksIHsgcGFyYW1zOiB0IH0pLnRoZW4oZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiBzLmRhdGE7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICB2YXIgaSwgbztcbiAgICAgICAgICB0aHJvdyBmZShmZSh7fSwgcy5yZXNwb25zZS5kYXRhKSwgeyBodHRwU3RhdHVzOiBzLnJlc3BvbnNlLnN0YXR1cywgaHR0cFN0YXR1c1RleHQ6IHMucmVzcG9uc2Uuc3RhdHVzVGV4dCwgbWVzc2FnZTogKGkgPSBzLnJlc3BvbnNlLmRhdGEubWVzc2FnZSkgIT09IG51bGwgJiYgaSAhPT0gdm9pZCAwID8gaSA6IFwiVGhlcmUgd2FzIGFuIGVycm9yLlwiLCBleGNlcHRpb246IChvID0gcy5yZXNwb25zZS5kYXRhLmV4Y2VwdGlvbikgIT09IG51bGwgJiYgbyAhPT0gdm9pZCAwID8gbyA6IFwiXCIgfSk7XG4gICAgICAgIH0pXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCBuLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24oZSwgdCkge1xuICAgIHJldHVybiB3dCh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRXQodGhpcywgZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gWzIsIHRoaXMuYXhpb3MucG9zdChcIi9hcGkvbWV0aG9kL1wiLmNvbmNhdChlKSwgZmUoe30sIHQpKS50aGVuKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICByZXR1cm4gcy5kYXRhO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihzKSB7XG4gICAgICAgICAgdmFyIGksIG87XG4gICAgICAgICAgdGhyb3cgZmUoZmUoe30sIHMucmVzcG9uc2UuZGF0YSksIHsgaHR0cFN0YXR1czogcy5yZXNwb25zZS5zdGF0dXMsIGh0dHBTdGF0dXNUZXh0OiBzLnJlc3BvbnNlLnN0YXR1c1RleHQsIG1lc3NhZ2U6IChpID0gcy5yZXNwb25zZS5kYXRhLm1lc3NhZ2UpICE9PSBudWxsICYmIGkgIT09IHZvaWQgMCA/IGkgOiBcIlRoZXJlIHdhcyBhbiBlcnJvci5cIiwgZXhjZXB0aW9uOiAobyA9IHMucmVzcG9uc2UuZGF0YS5leGNlcHRpb24pICE9PSBudWxsICYmIG8gIT09IHZvaWQgMCA/IG8gOiBcIlwiIH0pO1xuICAgICAgICB9KV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgbi5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24oZSwgdCkge1xuICAgIHJldHVybiB3dCh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRXQodGhpcywgZnVuY3Rpb24ocikge1xuICAgICAgICByZXR1cm4gWzIsIHRoaXMuYXhpb3MucHV0KFwiL2FwaS9tZXRob2QvXCIuY29uY2F0KGUpLCBmZSh7fSwgdCkpLnRoZW4oZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiBzLmRhdGE7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICB2YXIgaSwgbztcbiAgICAgICAgICB0aHJvdyBmZShmZSh7fSwgcy5yZXNwb25zZS5kYXRhKSwgeyBodHRwU3RhdHVzOiBzLnJlc3BvbnNlLnN0YXR1cywgaHR0cFN0YXR1c1RleHQ6IHMucmVzcG9uc2Uuc3RhdHVzVGV4dCwgbWVzc2FnZTogKGkgPSBzLnJlc3BvbnNlLmRhdGEubWVzc2FnZSkgIT09IG51bGwgJiYgaSAhPT0gdm9pZCAwID8gaSA6IFwiVGhlcmUgd2FzIGFuIGVycm9yLlwiLCBleGNlcHRpb246IChvID0gcy5yZXNwb25zZS5kYXRhLmV4Y2VwdGlvbikgIT09IG51bGwgJiYgbyAhPT0gdm9pZCAwID8gbyA6IFwiXCIgfSk7XG4gICAgICAgIH0pXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCBuLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgcmV0dXJuIHd0KHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBFdCh0aGlzLCBmdW5jdGlvbihyKSB7XG4gICAgICAgIHJldHVybiBbMiwgdGhpcy5heGlvcy5kZWxldGUoXCIvYXBpL21ldGhvZC9cIi5jb25jYXQoZSksIHsgcGFyYW1zOiB0IH0pLnRoZW4oZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiBzLmRhdGE7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICB2YXIgaSwgbztcbiAgICAgICAgICB0aHJvdyBmZShmZSh7fSwgcy5yZXNwb25zZS5kYXRhKSwgeyBodHRwU3RhdHVzOiBzLnJlc3BvbnNlLnN0YXR1cywgaHR0cFN0YXR1c1RleHQ6IHMucmVzcG9uc2Uuc3RhdHVzVGV4dCwgbWVzc2FnZTogKGkgPSBzLnJlc3BvbnNlLmRhdGEubWVzc2FnZSkgIT09IG51bGwgJiYgaSAhPT0gdm9pZCAwID8gaSA6IFwiVGhlcmUgd2FzIGFuIGVycm9yLlwiLCBleGNlcHRpb246IChvID0gcy5yZXNwb25zZS5kYXRhLmV4Y2VwdGlvbikgIT09IG51bGwgJiYgbyAhPT0gdm9pZCAwID8gbyA6IFwiXCIgfSk7XG4gICAgICAgIH0pXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCBuO1xufSgpO1xuZnQuRnJhcHBlQ2FsbCA9IG5pO1xudmFyIGh0ID0ge30sIHogPSBCICYmIEIuX19hc3NpZ24gfHwgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB6ID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbihuKSB7XG4gICAgZm9yICh2YXIgZSwgdCA9IDEsIHIgPSBhcmd1bWVudHMubGVuZ3RoOyB0IDwgcjsgdCsrKSB7XG4gICAgICBlID0gYXJndW1lbnRzW3RdO1xuICAgICAgZm9yICh2YXIgcyBpbiBlKVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgcykgJiYgKG5bc10gPSBlW3NdKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH0sIHouYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0sIEZlID0gQiAmJiBCLl9fYXdhaXRlciB8fCBmdW5jdGlvbihuLCBlLCB0LCByKSB7XG4gIGZ1bmN0aW9uIHMoaSkge1xuICAgIHJldHVybiBpIGluc3RhbmNlb2YgdCA/IGkgOiBuZXcgdChmdW5jdGlvbihvKSB7XG4gICAgICBvKGkpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuZXcgKHQgfHwgKHQgPSBQcm9taXNlKSkoZnVuY3Rpb24oaSwgbykge1xuICAgIGZ1bmN0aW9uIHUoaCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYShyLm5leHQoaCkpO1xuICAgICAgfSBjYXRjaCAoZikge1xuICAgICAgICBvKGYpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsKGgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGEoci50aHJvdyhoKSk7XG4gICAgICB9IGNhdGNoIChmKSB7XG4gICAgICAgIG8oZik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGEoaCkge1xuICAgICAgaC5kb25lID8gaShoLnZhbHVlKSA6IHMoaC52YWx1ZSkudGhlbih1LCBsKTtcbiAgICB9XG4gICAgYSgociA9IHIuYXBwbHkobiwgZSB8fCBbXSkpLm5leHQoKSk7XG4gIH0pO1xufSwgVWUgPSBCICYmIEIuX19nZW5lcmF0b3IgfHwgZnVuY3Rpb24obiwgZSkge1xuICB2YXIgdCA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmIChpWzBdICYgMSlcbiAgICAgIHRocm93IGlbMV07XG4gICAgcmV0dXJuIGlbMV07XG4gIH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIHIsIHMsIGksIG87XG4gIHJldHVybiBvID0geyBuZXh0OiB1KDApLCB0aHJvdzogdSgxKSwgcmV0dXJuOiB1KDIpIH0sIHR5cGVvZiBTeW1ib2wgPT0gXCJmdW5jdGlvblwiICYmIChvW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSksIG87XG4gIGZ1bmN0aW9uIHUoYSkge1xuICAgIHJldHVybiBmdW5jdGlvbihoKSB7XG4gICAgICByZXR1cm4gbChbYSwgaF0pO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gbChhKSB7XG4gICAgaWYgKHIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICBmb3IgKDsgdDsgKVxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHIgPSAxLCBzICYmIChpID0gYVswXSAmIDIgPyBzLnJldHVybiA6IGFbMF0gPyBzLnRocm93IHx8ICgoaSA9IHMucmV0dXJuKSAmJiBpLmNhbGwocyksIDApIDogcy5uZXh0KSAmJiAhKGkgPSBpLmNhbGwocywgYVsxXSkpLmRvbmUpXG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIHN3aXRjaCAocyA9IDAsIGkgJiYgKGEgPSBbYVswXSAmIDIsIGkudmFsdWVdKSwgYVswXSkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBpID0gYTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiB0LmxhYmVsKyssIHsgdmFsdWU6IGFbMV0sIGRvbmU6ICExIH07XG4gICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdC5sYWJlbCsrLCBzID0gYVsxXSwgYSA9IFswXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGEgPSB0Lm9wcy5wb3AoKSwgdC50cnlzLnBvcCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChpID0gdC50cnlzLCAhKGkgPSBpLmxlbmd0aCA+IDAgJiYgaVtpLmxlbmd0aCAtIDFdKSAmJiAoYVswXSA9PT0gNiB8fCBhWzBdID09PSAyKSkge1xuICAgICAgICAgICAgICB0ID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYVswXSA9PT0gMyAmJiAoIWkgfHwgYVsxXSA+IGlbMF0gJiYgYVsxXSA8IGlbM10pKSB7XG4gICAgICAgICAgICAgIHQubGFiZWwgPSBhWzFdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhWzBdID09PSA2ICYmIHQubGFiZWwgPCBpWzFdKSB7XG4gICAgICAgICAgICAgIHQubGFiZWwgPSBpWzFdLCBpID0gYTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSAmJiB0LmxhYmVsIDwgaVsyXSkge1xuICAgICAgICAgICAgICB0LmxhYmVsID0gaVsyXSwgdC5vcHMucHVzaChhKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpWzJdICYmIHQub3BzLnBvcCgpLCB0LnRyeXMucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBhID0gZS5jYWxsKG4sIHQpO1xuICAgICAgfSBjYXRjaCAoaCkge1xuICAgICAgICBhID0gWzYsIGhdLCBzID0gMDtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHIgPSBpID0gMDtcbiAgICAgIH1cbiAgICBpZiAoYVswXSAmIDUpXG4gICAgICB0aHJvdyBhWzFdO1xuICAgIHJldHVybiB7IHZhbHVlOiBhWzBdID8gYVsxXSA6IHZvaWQgMCwgZG9uZTogITAgfTtcbiAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShodCwgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6ICEwIH0pO1xuaHQuRnJhcHBlREIgPSB2b2lkIDA7XG52YXIgcmkgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gbihlLCB0LCByLCBzLCBpKSB7XG4gICAgdGhpcy5hcHBVUkwgPSBlLCB0aGlzLmF4aW9zID0gdCwgdGhpcy51c2VUb2tlbiA9IHIgIT0gbnVsbCA/IHIgOiAhMSwgdGhpcy50b2tlbiA9IHMsIHRoaXMudG9rZW5UeXBlID0gaTtcbiAgfVxuICByZXR1cm4gbi5wcm90b3R5cGUuZ2V0RG9jID0gZnVuY3Rpb24oZSwgdCkge1xuICAgIHJldHVybiB0ID09PSB2b2lkIDAgJiYgKHQgPSBcIlwiKSwgRmUodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFVlKHRoaXMsIGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmF4aW9zLmdldChcIi9hcGkvcmVzb3VyY2UvXCIuY29uY2F0KGUsIFwiL1wiKS5jb25jYXQodCkpLnRoZW4oZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiBzLmRhdGEuZGF0YTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24ocykge1xuICAgICAgICAgIHZhciBpLCBvO1xuICAgICAgICAgIHRocm93IHooeih7fSwgcy5yZXNwb25zZS5kYXRhKSwgeyBodHRwU3RhdHVzOiBzLnJlc3BvbnNlLnN0YXR1cywgaHR0cFN0YXR1c1RleHQ6IHMucmVzcG9uc2Uuc3RhdHVzVGV4dCwgbWVzc2FnZTogXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZmV0Y2hpbmcgdGhlIGRvY3VtZW50LlwiLCBleGNlcHRpb246IChvID0gKGkgPSBzLnJlc3BvbnNlLmRhdGEuZXhjZXB0aW9uKSAhPT0gbnVsbCAmJiBpICE9PSB2b2lkIDAgPyBpIDogcy5yZXNwb25zZS5kYXRhLmV4Y190eXBlKSAhPT0gbnVsbCAmJiBvICE9PSB2b2lkIDAgPyBvIDogXCJcIiB9KTtcbiAgICAgICAgfSldO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIG4ucHJvdG90eXBlLmdldERvY0xpc3QgPSBmdW5jdGlvbihlLCB0KSB7XG4gICAgdmFyIHI7XG4gICAgcmV0dXJuIEZlKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzLCBpLCBvLCB1LCBsLCBhLCBoLCBmLCBwLCBtLCBnO1xuICAgICAgcmV0dXJuIFVlKHRoaXMsIGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgcmV0dXJuIHMgPSB7fSwgdCAmJiAoaSA9IHQuZmllbGRzLCBvID0gdC5maWx0ZXJzLCB1ID0gdC5vckZpbHRlcnMsIGwgPSB0Lm9yZGVyQnksIGEgPSB0LmxpbWl0LCBoID0gdC5saW1pdF9zdGFydCwgZiA9IHQuZ3JvdXBCeSwgcCA9IHQuYXNEaWN0LCBtID0gcCA9PT0gdm9pZCAwID8gITAgOiBwLCBnID0gbCA/IFwiXCIuY29uY2F0KFN0cmluZyhsID09IG51bGwgPyB2b2lkIDAgOiBsLmZpZWxkKSwgXCIgXCIpLmNvbmNhdCgociA9IGwgPT0gbnVsbCA/IHZvaWQgMCA6IGwub3JkZXIpICE9PSBudWxsICYmIHIgIT09IHZvaWQgMCA/IHIgOiBcImFzY1wiKSA6IFwiXCIsIHMgPSB7XG4gICAgICAgICAgZmllbGRzOiBpID8gSlNPTi5zdHJpbmdpZnkoaSkgOiB2b2lkIDAsXG4gICAgICAgICAgZmlsdGVyczogbyA/IEpTT04uc3RyaW5naWZ5KG8pIDogdm9pZCAwLFxuICAgICAgICAgIG9yX2ZpbHRlcnM6IHUgPyBKU09OLnN0cmluZ2lmeSh1KSA6IHZvaWQgMCxcbiAgICAgICAgICBvcmRlcl9ieTogZyxcbiAgICAgICAgICBncm91cF9ieTogZixcbiAgICAgICAgICBsaW1pdDogYSxcbiAgICAgICAgICBsaW1pdF9zdGFydDogaCxcbiAgICAgICAgICBhc19kaWN0OiBtXG4gICAgICAgIH0pLCBbMiwgdGhpcy5heGlvcy5nZXQoXCIvYXBpL3Jlc291cmNlL1wiLmNvbmNhdChlKSwgeyBwYXJhbXM6IHMgfSkudGhlbihmdW5jdGlvbihFKSB7XG4gICAgICAgICAgcmV0dXJuIEUuZGF0YS5kYXRhO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihFKSB7XG4gICAgICAgICAgdmFyIF8sIFM7XG4gICAgICAgICAgdGhyb3cgeih6KHt9LCBFLnJlc3BvbnNlLmRhdGEpLCB7IGh0dHBTdGF0dXM6IEUucmVzcG9uc2Uuc3RhdHVzLCBodHRwU3RhdHVzVGV4dDogRS5yZXNwb25zZS5zdGF0dXNUZXh0LCBtZXNzYWdlOiBcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBmZXRjaGluZyB0aGUgZG9jdW1lbnRzLlwiLCBleGNlcHRpb246IChTID0gKF8gPSBFLnJlc3BvbnNlLmRhdGEuZXhjZXB0aW9uKSAhPT0gbnVsbCAmJiBfICE9PSB2b2lkIDAgPyBfIDogRS5yZXNwb25zZS5kYXRhLmV4Y190eXBlKSAhPT0gbnVsbCAmJiBTICE9PSB2b2lkIDAgPyBTIDogXCJcIiB9KTtcbiAgICAgICAgfSldO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIG4ucHJvdG90eXBlLmNyZWF0ZURvYyA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICByZXR1cm4gRmUodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFVlKHRoaXMsIGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmF4aW9zLnBvc3QoXCIvYXBpL3Jlc291cmNlL1wiLmNvbmNhdChlKSwgeih7fSwgdCkpLnRoZW4oZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiBzLmRhdGEuZGF0YTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24ocykge1xuICAgICAgICAgIHZhciBpLCBvLCB1O1xuICAgICAgICAgIHRocm93IHooeih7fSwgcy5yZXNwb25zZS5kYXRhKSwgeyBodHRwU3RhdHVzOiBzLnJlc3BvbnNlLnN0YXR1cywgaHR0cFN0YXR1c1RleHQ6IHMucmVzcG9uc2Uuc3RhdHVzVGV4dCwgbWVzc2FnZTogKGkgPSBzLnJlc3BvbnNlLmRhdGEubWVzc2FnZSkgIT09IG51bGwgJiYgaSAhPT0gdm9pZCAwID8gaSA6IFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGNyZWF0aW5nIHRoZSBkb2N1bWVudC5cIiwgZXhjZXB0aW9uOiAodSA9IChvID0gcy5yZXNwb25zZS5kYXRhLmV4Y2VwdGlvbikgIT09IG51bGwgJiYgbyAhPT0gdm9pZCAwID8gbyA6IHMucmVzcG9uc2UuZGF0YS5leGNfdHlwZSkgIT09IG51bGwgJiYgdSAhPT0gdm9pZCAwID8gdSA6IFwiXCIgfSk7XG4gICAgICAgIH0pXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCBuLnByb3RvdHlwZS51cGRhdGVEb2MgPSBmdW5jdGlvbihlLCB0LCByKSB7XG4gICAgcmV0dXJuIEZlKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBVZSh0aGlzLCBmdW5jdGlvbihzKSB7XG4gICAgICAgIHJldHVybiBbMiwgdGhpcy5heGlvcy5wdXQoXCIvYXBpL3Jlc291cmNlL1wiLmNvbmNhdChlLCBcIi9cIikuY29uY2F0KHQpLCB6KHt9LCByKSkudGhlbihmdW5jdGlvbihpKSB7XG4gICAgICAgICAgcmV0dXJuIGkuZGF0YS5kYXRhO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgdmFyIG8sIHUsIGw7XG4gICAgICAgICAgdGhyb3cgeih6KHt9LCBpLnJlc3BvbnNlLmRhdGEpLCB7IGh0dHBTdGF0dXM6IGkucmVzcG9uc2Uuc3RhdHVzLCBodHRwU3RhdHVzVGV4dDogaS5yZXNwb25zZS5zdGF0dXNUZXh0LCBtZXNzYWdlOiAobyA9IGkucmVzcG9uc2UuZGF0YS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBvICE9PSB2b2lkIDAgPyBvIDogXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgdXBkYXRpbmcgdGhlIGRvY3VtZW50LlwiLCBleGNlcHRpb246IChsID0gKHUgPSBpLnJlc3BvbnNlLmRhdGEuZXhjZXB0aW9uKSAhPT0gbnVsbCAmJiB1ICE9PSB2b2lkIDAgPyB1IDogaS5yZXNwb25zZS5kYXRhLmV4Y190eXBlKSAhPT0gbnVsbCAmJiBsICE9PSB2b2lkIDAgPyBsIDogXCJcIiB9KTtcbiAgICAgICAgfSldO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIG4ucHJvdG90eXBlLmRlbGV0ZURvYyA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICByZXR1cm4gRmUodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFVlKHRoaXMsIGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmF4aW9zLmRlbGV0ZShcIi9hcGkvcmVzb3VyY2UvXCIuY29uY2F0KGUsIFwiL1wiKS5jb25jYXQodCkpLnRoZW4oZnVuY3Rpb24ocykge1xuICAgICAgICAgIHJldHVybiBzLmRhdGE7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKHMpIHtcbiAgICAgICAgICB2YXIgaSwgbztcbiAgICAgICAgICB0aHJvdyB6KHooe30sIHMucmVzcG9uc2UuZGF0YSksIHsgaHR0cFN0YXR1czogcy5yZXNwb25zZS5zdGF0dXMsIGh0dHBTdGF0dXNUZXh0OiBzLnJlc3BvbnNlLnN0YXR1c1RleHQsIG1lc3NhZ2U6IFwiVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGRlbGV0aW5nIHRoZSBkb2N1bWVudC5cIiwgZXhjZXB0aW9uOiAobyA9IChpID0gcy5yZXNwb25zZS5kYXRhLmV4Y2VwdGlvbikgIT09IG51bGwgJiYgaSAhPT0gdm9pZCAwID8gaSA6IHMucmVzcG9uc2UuZGF0YS5leGNfdHlwZSkgIT09IG51bGwgJiYgbyAhPT0gdm9pZCAwID8gbyA6IFwiXCIgfSk7XG4gICAgICAgIH0pXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCBuLnByb3RvdHlwZS5nZXRDb3VudCA9IGZ1bmN0aW9uKGUsIHQsIHIsIHMpIHtcbiAgICByZXR1cm4gciA9PT0gdm9pZCAwICYmIChyID0gITEpLCBzID09PSB2b2lkIDAgJiYgKHMgPSAhMSksIEZlKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpO1xuICAgICAgcmV0dXJuIFVlKHRoaXMsIGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgcmV0dXJuIGkgPSB7XG4gICAgICAgICAgZG9jdHlwZTogZSxcbiAgICAgICAgICBmaWx0ZXJzOiBbXVxuICAgICAgICB9LCByICYmIChpLmNhY2hlID0gciksIHMgJiYgKGkuZGVidWcgPSBzKSwgdCAmJiAoaS5maWx0ZXJzID0gdCA/IEpTT04uc3RyaW5naWZ5KHQpIDogdm9pZCAwKSwgWzIsIHRoaXMuYXhpb3MuZ2V0KFwiL2FwaS9tZXRob2QvZnJhcHBlLmNsaWVudC5nZXRfY291bnRcIiwgeyBwYXJhbXM6IGkgfSkudGhlbihmdW5jdGlvbih1KSB7XG4gICAgICAgICAgcmV0dXJuIHUuZGF0YS5tZXNzYWdlO1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbih1KSB7XG4gICAgICAgICAgdmFyIGwsIGE7XG4gICAgICAgICAgdGhyb3cgeih6KHt9LCB1LnJlc3BvbnNlLmRhdGEpLCB7IGh0dHBTdGF0dXM6IHUucmVzcG9uc2Uuc3RhdHVzLCBodHRwU3RhdHVzVGV4dDogdS5yZXNwb25zZS5zdGF0dXNUZXh0LCBtZXNzYWdlOiBcIlRoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBnZXR0aW5nIHRoZSBjb3VudC5cIiwgZXhjZXB0aW9uOiAoYSA9IChsID0gdS5yZXNwb25zZS5kYXRhLmV4Y2VwdGlvbikgIT09IG51bGwgJiYgbCAhPT0gdm9pZCAwID8gbCA6IHUucmVzcG9uc2UuZGF0YS5leGNfdHlwZSkgIT09IG51bGwgJiYgYSAhPT0gdm9pZCAwID8gYSA6IFwiXCIgfSk7XG4gICAgICAgIH0pXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCBuLnByb3RvdHlwZS5nZXRMYXN0RG9jID0gZnVuY3Rpb24oZSwgdCkge1xuICAgIHJldHVybiBGZSh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgciwgcztcbiAgICAgIHJldHVybiBVZSh0aGlzLCBmdW5jdGlvbihpKSB7XG4gICAgICAgIHN3aXRjaCAoaS5sYWJlbCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiByID0ge1xuICAgICAgICAgICAgICBvcmRlckJ5OiB7XG4gICAgICAgICAgICAgICAgZmllbGQ6IFwiY3JlYXRpb25cIixcbiAgICAgICAgICAgICAgICBvcmRlcjogXCJkZXNjXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdCAmJiAociA9IHooeih7fSwgciksIHQpKSwgWzQsIHRoaXMuZ2V0RG9jTGlzdChlLCB6KHooe30sIHIpLCB7IGxpbWl0OiAxLCBmaWVsZHM6IFtcIm5hbWVcIl0gfSkpXTtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gcyA9IGkuc2VudCgpLCBzLmxlbmd0aCA+IDAgPyBbMiwgdGhpcy5nZXREb2MoZSwgc1swXS5uYW1lKV0gOiBbMiwge31dO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgbjtcbn0oKTtcbmh0LkZyYXBwZURCID0gcmk7XG52YXIgZHQgPSB7fSwgRnQgPSBCICYmIEIuX19hc3NpZ24gfHwgZnVuY3Rpb24oKSB7XG4gIHJldHVybiBGdCA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24obikge1xuICAgIGZvciAodmFyIGUsIHQgPSAxLCByID0gYXJndW1lbnRzLmxlbmd0aDsgdCA8IHI7IHQrKykge1xuICAgICAgZSA9IGFyZ3VtZW50c1t0XTtcbiAgICAgIGZvciAodmFyIHMgaW4gZSlcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHMpICYmIChuW3NdID0gZVtzXSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9LCBGdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSwgc2kgPSBCICYmIEIuX19hd2FpdGVyIHx8IGZ1bmN0aW9uKG4sIGUsIHQsIHIpIHtcbiAgZnVuY3Rpb24gcyhpKSB7XG4gICAgcmV0dXJuIGkgaW5zdGFuY2VvZiB0ID8gaSA6IG5ldyB0KGZ1bmN0aW9uKG8pIHtcbiAgICAgIG8oaSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIG5ldyAodCB8fCAodCA9IFByb21pc2UpKShmdW5jdGlvbihpLCBvKSB7XG4gICAgZnVuY3Rpb24gdShoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhKHIubmV4dChoKSk7XG4gICAgICB9IGNhdGNoIChmKSB7XG4gICAgICAgIG8oZik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGwoaCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYShyLnRocm93KGgpKTtcbiAgICAgIH0gY2F0Y2ggKGYpIHtcbiAgICAgICAgbyhmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYShoKSB7XG4gICAgICBoLmRvbmUgPyBpKGgudmFsdWUpIDogcyhoLnZhbHVlKS50aGVuKHUsIGwpO1xuICAgIH1cbiAgICBhKChyID0gci5hcHBseShuLCBlIHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59LCBpaSA9IEIgJiYgQi5fX2dlbmVyYXRvciB8fCBmdW5jdGlvbihuLCBlKSB7XG4gIHZhciB0ID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKGlbMF0gJiAxKVxuICAgICAgdGhyb3cgaVsxXTtcbiAgICByZXR1cm4gaVsxXTtcbiAgfSwgdHJ5czogW10sIG9wczogW10gfSwgciwgcywgaSwgbztcbiAgcmV0dXJuIG8gPSB7IG5leHQ6IHUoMCksIHRocm93OiB1KDEpLCByZXR1cm46IHUoMikgfSwgdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgKG9bU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgbztcbiAgZnVuY3Rpb24gdShhKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGgpIHtcbiAgICAgIHJldHVybiBsKFthLCBoXSk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBsKGEpIHtcbiAgICBpZiAocilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgIGZvciAoOyB0OyApXG4gICAgICB0cnkge1xuICAgICAgICBpZiAociA9IDEsIHMgJiYgKGkgPSBhWzBdICYgMiA/IHMucmV0dXJuIDogYVswXSA/IHMudGhyb3cgfHwgKChpID0gcy5yZXR1cm4pICYmIGkuY2FsbChzKSwgMCkgOiBzLm5leHQpICYmICEoaSA9IGkuY2FsbChzLCBhWzFdKSkuZG9uZSlcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgc3dpdGNoIChzID0gMCwgaSAmJiAoYSA9IFthWzBdICYgMiwgaS52YWx1ZV0pLCBhWzBdKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGkgPSBhO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIHQubGFiZWwrKywgeyB2YWx1ZTogYVsxXSwgZG9uZTogITEgfTtcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICB0LmxhYmVsKyssIHMgPSBhWzFdLCBhID0gWzBdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgYSA9IHQub3BzLnBvcCgpLCB0LnRyeXMucG9wKCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKGkgPSB0LnRyeXMsICEoaSA9IGkubGVuZ3RoID4gMCAmJiBpW2kubGVuZ3RoIC0gMV0pICYmIChhWzBdID09PSA2IHx8IGFbMF0gPT09IDIpKSB7XG4gICAgICAgICAgICAgIHQgPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhWzBdID09PSAzICYmICghaSB8fCBhWzFdID4gaVswXSAmJiBhWzFdIDwgaVszXSkpIHtcbiAgICAgICAgICAgICAgdC5sYWJlbCA9IGFbMV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFbMF0gPT09IDYgJiYgdC5sYWJlbCA8IGlbMV0pIHtcbiAgICAgICAgICAgICAgdC5sYWJlbCA9IGlbMV0sIGkgPSBhO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpICYmIHQubGFiZWwgPCBpWzJdKSB7XG4gICAgICAgICAgICAgIHQubGFiZWwgPSBpWzJdLCB0Lm9wcy5wdXNoKGEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlbMl0gJiYgdC5vcHMucG9wKCksIHQudHJ5cy5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGEgPSBlLmNhbGwobiwgdCk7XG4gICAgICB9IGNhdGNoIChoKSB7XG4gICAgICAgIGEgPSBbNiwgaF0sIHMgPSAwO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgciA9IGkgPSAwO1xuICAgICAgfVxuICAgIGlmIChhWzBdICYgNSlcbiAgICAgIHRocm93IGFbMV07XG4gICAgcmV0dXJuIHsgdmFsdWU6IGFbMF0gPyBhWzFdIDogdm9pZCAwLCBkb25lOiAhMCB9O1xuICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGR0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSk7XG5kdC5GcmFwcGVGaWxlVXBsb2FkID0gdm9pZCAwO1xudmFyIG9pID0gZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG4oZSwgdCwgciwgcywgaSkge1xuICAgIHRoaXMuYXBwVVJMID0gZSwgdGhpcy5heGlvcyA9IHQsIHRoaXMudXNlVG9rZW4gPSByICE9IG51bGwgPyByIDogITEsIHRoaXMudG9rZW4gPSBzLCB0aGlzLnRva2VuVHlwZSA9IGk7XG4gIH1cbiAgcmV0dXJuIG4ucHJvdG90eXBlLnVwbG9hZEZpbGUgPSBmdW5jdGlvbihlLCB0LCByLCBzKSB7XG4gICAgcmV0dXJuIHMgPT09IHZvaWQgMCAmJiAocyA9IFwidXBsb2FkX2ZpbGVcIiksIHNpKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpLCBvLCB1LCBsLCBhLCBoLCBmLCBwO1xuICAgICAgcmV0dXJuIGlpKHRoaXMsIGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgcmV0dXJuIGkgPSBuZXcgRm9ybURhdGEoKSwgZSAmJiBpLmFwcGVuZChcImZpbGVcIiwgZSwgZS5uYW1lKSwgbyA9IHQuaXNQcml2YXRlLCB1ID0gdC5mb2xkZXIsIGwgPSB0LmZpbGVfdXJsLCBhID0gdC5kb2N0eXBlLCBoID0gdC5kb2NuYW1lLCBmID0gdC5maWVsZG5hbWUsIHAgPSB0Lm90aGVyRGF0YSwgbyAmJiBpLmFwcGVuZChcImlzX3ByaXZhdGVcIiwgXCIxXCIpLCB1ICYmIGkuYXBwZW5kKFwiZm9sZGVyXCIsIHUpLCBsICYmIGkuYXBwZW5kKFwiZmlsZV91cmxcIiwgbCksIGEgJiYgaCAmJiAoaS5hcHBlbmQoXCJkb2N0eXBlXCIsIGEpLCBpLmFwcGVuZChcImRvY25hbWVcIiwgaCksIGYgJiYgaS5hcHBlbmQoXCJmaWVsZG5hbWVcIiwgZikpLCBwICYmIE9iamVjdC5rZXlzKHApLmZvckVhY2goZnVuY3Rpb24oZykge1xuICAgICAgICAgIHZhciBiID0gcFtnXTtcbiAgICAgICAgICBpLmFwcGVuZChnLCBiKTtcbiAgICAgICAgfSksIFsyLCB0aGlzLmF4aW9zLnBvc3QoXCIvYXBpL21ldGhvZC9cIi5jb25jYXQocyksIGksIHtcbiAgICAgICAgICBvblVwbG9hZFByb2dyZXNzOiBmdW5jdGlvbihnKSB7XG4gICAgICAgICAgICByICYmIHIoZy5sb2FkZWQsIGcudG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZykge1xuICAgICAgICAgIHZhciBiLCBFO1xuICAgICAgICAgIHRocm93IEZ0KEZ0KHt9LCBnLnJlc3BvbnNlLmRhdGEpLCB7IGh0dHBTdGF0dXM6IGcucmVzcG9uc2Uuc3RhdHVzLCBodHRwU3RhdHVzVGV4dDogZy5yZXNwb25zZS5zdGF0dXNUZXh0LCBtZXNzYWdlOiAoYiA9IGcucmVzcG9uc2UuZGF0YS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBiICE9PSB2b2lkIDAgPyBiIDogXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgdXBsb2FkaW5nIHRoZSBmaWxlLlwiLCBleGNlcHRpb246IChFID0gZy5yZXNwb25zZS5kYXRhLmV4Y2VwdGlvbikgIT09IG51bGwgJiYgRSAhPT0gdm9pZCAwID8gRSA6IFwiXCIgfSk7XG4gICAgICAgIH0pXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCBuO1xufSgpO1xuZHQuRnJhcHBlRmlsZVVwbG9hZCA9IG9pO1xudmFyIEtlID0ge30sIEdyID0geyBleHBvcnRzOiB7fSB9LCBGbiA9IHsgZXhwb3J0czoge30gfSwgWHIgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpLCBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspXG4gICAgICBzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIHJldHVybiBlLmFwcGx5KHQsIHMpO1xuICB9O1xufSwgYWkgPSBYciwga2UgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuZnVuY3Rpb24gVW4obikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShuKTtcbn1cbmZ1bmN0aW9uIEVuKG4pIHtcbiAgcmV0dXJuIHR5cGVvZiBuID4gXCJ1XCI7XG59XG5mdW5jdGlvbiB1aShuKSB7XG4gIHJldHVybiBuICE9PSBudWxsICYmICFFbihuKSAmJiBuLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFFbihuLmNvbnN0cnVjdG9yKSAmJiB0eXBlb2Ygbi5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PSBcImZ1bmN0aW9uXCIgJiYgbi5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihuKTtcbn1cbmZ1bmN0aW9uIFFyKG4pIHtcbiAgcmV0dXJuIGtlLmNhbGwobikgPT09IFwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIjtcbn1cbmZ1bmN0aW9uIGNpKG4pIHtcbiAgcmV0dXJuIGtlLmNhbGwobikgPT09IFwiW29iamVjdCBGb3JtRGF0YV1cIjtcbn1cbmZ1bmN0aW9uIGxpKG4pIHtcbiAgdmFyIGU7XG4gIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIgPCBcInVcIiAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcgPyBlID0gQXJyYXlCdWZmZXIuaXNWaWV3KG4pIDogZSA9IG4gJiYgbi5idWZmZXIgJiYgUXIobi5idWZmZXIpLCBlO1xufVxuZnVuY3Rpb24gZmkobikge1xuICByZXR1cm4gdHlwZW9mIG4gPT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGhpKG4pIHtcbiAgcmV0dXJuIHR5cGVvZiBuID09IFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiBacihuKSB7XG4gIHJldHVybiBuICE9PSBudWxsICYmIHR5cGVvZiBuID09IFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBrdChuKSB7XG4gIGlmIChrZS5jYWxsKG4pICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKVxuICAgIHJldHVybiAhMTtcbiAgdmFyIGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobik7XG4gIHJldHVybiBlID09PSBudWxsIHx8IGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5mdW5jdGlvbiBkaShuKSB7XG4gIHJldHVybiBrZS5jYWxsKG4pID09PSBcIltvYmplY3QgRGF0ZV1cIjtcbn1cbmZ1bmN0aW9uIHBpKG4pIHtcbiAgcmV0dXJuIGtlLmNhbGwobikgPT09IFwiW29iamVjdCBGaWxlXVwiO1xufVxuZnVuY3Rpb24gdmkobikge1xuICByZXR1cm4ga2UuY2FsbChuKSA9PT0gXCJbb2JqZWN0IEJsb2JdXCI7XG59XG5mdW5jdGlvbiBlcyhuKSB7XG4gIHJldHVybiBrZS5jYWxsKG4pID09PSBcIltvYmplY3QgRnVuY3Rpb25dXCI7XG59XG5mdW5jdGlvbiB5aShuKSB7XG4gIHJldHVybiBacihuKSAmJiBlcyhuLnBpcGUpO1xufVxuZnVuY3Rpb24gbWkobikge1xuICByZXR1cm4ga2UuY2FsbChuKSA9PT0gXCJbb2JqZWN0IFVSTFNlYXJjaFBhcmFtc11cIjtcbn1cbmZ1bmN0aW9uIGdpKG4pIHtcbiAgcmV0dXJuIG4udHJpbSA/IG4udHJpbSgpIDogbi5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCBcIlwiKTtcbn1cbmZ1bmN0aW9uIF9pKCkge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciA8IFwidVwiICYmIChuYXZpZ2F0b3IucHJvZHVjdCA9PT0gXCJSZWFjdE5hdGl2ZVwiIHx8IG5hdmlnYXRvci5wcm9kdWN0ID09PSBcIk5hdGl2ZVNjcmlwdFwiIHx8IG5hdmlnYXRvci5wcm9kdWN0ID09PSBcIk5TXCIpID8gITEgOiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgdHlwZW9mIGRvY3VtZW50IDwgXCJ1XCI7XG59XG5mdW5jdGlvbiBxbihuLCBlKSB7XG4gIGlmICghKG4gPT09IG51bGwgfHwgdHlwZW9mIG4gPiBcInVcIikpXG4gICAgaWYgKHR5cGVvZiBuICE9IFwib2JqZWN0XCIgJiYgKG4gPSBbbl0pLCBVbihuKSlcbiAgICAgIGZvciAodmFyIHQgPSAwLCByID0gbi5sZW5ndGg7IHQgPCByOyB0KyspXG4gICAgICAgIGUuY2FsbChudWxsLCBuW3RdLCB0LCBuKTtcbiAgICBlbHNlXG4gICAgICBmb3IgKHZhciBzIGluIG4pXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCBzKSAmJiBlLmNhbGwobnVsbCwgbltzXSwgcywgbik7XG59XG5mdW5jdGlvbiBSbigpIHtcbiAgdmFyIG4gPSB7fTtcbiAgZnVuY3Rpb24gZShzLCBpKSB7XG4gICAga3QobltpXSkgJiYga3QocykgPyBuW2ldID0gUm4obltpXSwgcykgOiBrdChzKSA/IG5baV0gPSBSbih7fSwgcykgOiBVbihzKSA/IG5baV0gPSBzLnNsaWNlKCkgOiBuW2ldID0gcztcbiAgfVxuICBmb3IgKHZhciB0ID0gMCwgciA9IGFyZ3VtZW50cy5sZW5ndGg7IHQgPCByOyB0KyspXG4gICAgcW4oYXJndW1lbnRzW3RdLCBlKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBiaShuLCBlLCB0KSB7XG4gIHJldHVybiBxbihlLCBmdW5jdGlvbihzLCBpKSB7XG4gICAgdCAmJiB0eXBlb2YgcyA9PSBcImZ1bmN0aW9uXCIgPyBuW2ldID0gYWkocywgdCkgOiBuW2ldID0gcztcbiAgfSksIG47XG59XG5mdW5jdGlvbiB3aShuKSB7XG4gIHJldHVybiBuLmNoYXJDb2RlQXQoMCkgPT09IDY1Mjc5ICYmIChuID0gbi5zbGljZSgxKSksIG47XG59XG52YXIgYWUgPSB7XG4gIGlzQXJyYXk6IFVuLFxuICBpc0FycmF5QnVmZmVyOiBRcixcbiAgaXNCdWZmZXI6IHVpLFxuICBpc0Zvcm1EYXRhOiBjaSxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGxpLFxuICBpc1N0cmluZzogZmksXG4gIGlzTnVtYmVyOiBoaSxcbiAgaXNPYmplY3Q6IFpyLFxuICBpc1BsYWluT2JqZWN0OiBrdCxcbiAgaXNVbmRlZmluZWQ6IEVuLFxuICBpc0RhdGU6IGRpLFxuICBpc0ZpbGU6IHBpLFxuICBpc0Jsb2I6IHZpLFxuICBpc0Z1bmN0aW9uOiBlcyxcbiAgaXNTdHJlYW06IHlpLFxuICBpc1VSTFNlYXJjaFBhcmFtczogbWksXG4gIGlzU3RhbmRhcmRCcm93c2VyRW52OiBfaSxcbiAgZm9yRWFjaDogcW4sXG4gIG1lcmdlOiBSbixcbiAgZXh0ZW5kOiBiaSxcbiAgdHJpbTogZ2ksXG4gIHN0cmlwQk9NOiB3aVxufSwgWWUgPSBhZTtcbmZ1bmN0aW9uIHNyKG4pIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChuKS5yZXBsYWNlKC8lM0EvZ2ksIFwiOlwiKS5yZXBsYWNlKC8lMjQvZywgXCIkXCIpLnJlcGxhY2UoLyUyQy9naSwgXCIsXCIpLnJlcGxhY2UoLyUyMC9nLCBcIitcIikucmVwbGFjZSgvJTVCL2dpLCBcIltcIikucmVwbGFjZSgvJTVEL2dpLCBcIl1cIik7XG59XG52YXIgdHMgPSBmdW5jdGlvbihlLCB0LCByKSB7XG4gIGlmICghdClcbiAgICByZXR1cm4gZTtcbiAgdmFyIHM7XG4gIGlmIChyKVxuICAgIHMgPSByKHQpO1xuICBlbHNlIGlmIChZZS5pc1VSTFNlYXJjaFBhcmFtcyh0KSlcbiAgICBzID0gdC50b1N0cmluZygpO1xuICBlbHNlIHtcbiAgICB2YXIgaSA9IFtdO1xuICAgIFllLmZvckVhY2godCwgZnVuY3Rpb24obCwgYSkge1xuICAgICAgbCA9PT0gbnVsbCB8fCB0eXBlb2YgbCA+IFwidVwiIHx8IChZZS5pc0FycmF5KGwpID8gYSA9IGEgKyBcIltdXCIgOiBsID0gW2xdLCBZZS5mb3JFYWNoKGwsIGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgWWUuaXNEYXRlKGYpID8gZiA9IGYudG9JU09TdHJpbmcoKSA6IFllLmlzT2JqZWN0KGYpICYmIChmID0gSlNPTi5zdHJpbmdpZnkoZikpLCBpLnB1c2goc3IoYSkgKyBcIj1cIiArIHNyKGYpKTtcbiAgICAgIH0pKTtcbiAgICB9KSwgcyA9IGkuam9pbihcIiZcIik7XG4gIH1cbiAgaWYgKHMpIHtcbiAgICB2YXIgbyA9IGUuaW5kZXhPZihcIiNcIik7XG4gICAgbyAhPT0gLTEgJiYgKGUgPSBlLnNsaWNlKDAsIG8pKSwgZSArPSAoZS5pbmRleE9mKFwiP1wiKSA9PT0gLTEgPyBcIj9cIiA6IFwiJlwiKSArIHM7XG4gIH1cbiAgcmV0dXJuIGU7XG59LCBFaSA9IGFlO1xuZnVuY3Rpb24gVXQoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblV0LnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbihlLCB0LCByKSB7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZSxcbiAgICByZWplY3RlZDogdCxcbiAgICBzeW5jaHJvbm91czogciA/IHIuc3luY2hyb25vdXMgOiAhMSxcbiAgICBydW5XaGVuOiByID8gci5ydW5XaGVuIDogbnVsbFxuICB9KSwgdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xufTtcblV0LnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uKGUpIHtcbiAgdGhpcy5oYW5kbGVyc1tlXSAmJiAodGhpcy5oYW5kbGVyc1tlXSA9IG51bGwpO1xufTtcblV0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oZSkge1xuICBFaS5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uKHIpIHtcbiAgICByICE9PSBudWxsICYmIGUocik7XG4gIH0pO1xufTtcbnZhciBSaSA9IFV0LCBTaSA9IGFlLCBUaSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgU2kuZm9yRWFjaChlLCBmdW5jdGlvbihzLCBpKSB7XG4gICAgaSAhPT0gdCAmJiBpLnRvVXBwZXJDYXNlKCkgPT09IHQudG9VcHBlckNhc2UoKSAmJiAoZVt0XSA9IHMsIGRlbGV0ZSBlW2ldKTtcbiAgfSk7XG59LCBucyA9IGZ1bmN0aW9uKGUsIHQsIHIsIHMsIGkpIHtcbiAgcmV0dXJuIGUuY29uZmlnID0gdCwgciAmJiAoZS5jb2RlID0gciksIGUucmVxdWVzdCA9IHMsIGUucmVzcG9uc2UgPSBpLCBlLmlzQXhpb3NFcnJvciA9ICEwLCBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBzdGF0dXM6IHRoaXMucmVzcG9uc2UgJiYgdGhpcy5yZXNwb25zZS5zdGF0dXMgPyB0aGlzLnJlc3BvbnNlLnN0YXR1cyA6IG51bGxcbiAgICB9O1xuICB9LCBlO1xufSwgcnMgPSB7XG4gIHNpbGVudEpTT05QYXJzaW5nOiAhMCxcbiAgZm9yY2VkSlNPTlBhcnNpbmc6ICEwLFxuICBjbGFyaWZ5VGltZW91dEVycm9yOiAhMVxufSwgS3QsIGlyO1xuZnVuY3Rpb24gc3MoKSB7XG4gIGlmIChpcilcbiAgICByZXR1cm4gS3Q7XG4gIGlyID0gMTtcbiAgdmFyIG4gPSBucztcbiAgcmV0dXJuIEt0ID0gZnVuY3Rpb24odCwgciwgcywgaSwgbykge1xuICAgIHZhciB1ID0gbmV3IEVycm9yKHQpO1xuICAgIHJldHVybiBuKHUsIHIsIHMsIGksIG8pO1xuICB9LCBLdDtcbn1cbnZhciBHdCwgb3I7XG5mdW5jdGlvbiBPaSgpIHtcbiAgaWYgKG9yKVxuICAgIHJldHVybiBHdDtcbiAgb3IgPSAxO1xuICB2YXIgbiA9IHNzKCk7XG4gIHJldHVybiBHdCA9IGZ1bmN0aW9uKHQsIHIsIHMpIHtcbiAgICB2YXIgaSA9IHMuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICAgICFzLnN0YXR1cyB8fCAhaSB8fCBpKHMuc3RhdHVzKSA/IHQocykgOiByKG4oXG4gICAgICBcIlJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgXCIgKyBzLnN0YXR1cyxcbiAgICAgIHMuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHMucmVxdWVzdCxcbiAgICAgIHNcbiAgICApKTtcbiAgfSwgR3Q7XG59XG52YXIgWHQsIGFyO1xuZnVuY3Rpb24geGkoKSB7XG4gIGlmIChhcilcbiAgICByZXR1cm4gWHQ7XG4gIGFyID0gMTtcbiAgdmFyIG4gPSBhZTtcbiAgcmV0dXJuIFh0ID0gbi5pc1N0YW5kYXJkQnJvd3NlckVudigpID8gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbihyLCBzLCBpLCBvLCB1LCBsKSB7XG4gICAgICAgIHZhciBhID0gW107XG4gICAgICAgIGEucHVzaChyICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQocykpLCBuLmlzTnVtYmVyKGkpICYmIGEucHVzaChcImV4cGlyZXM9XCIgKyBuZXcgRGF0ZShpKS50b0dNVFN0cmluZygpKSwgbi5pc1N0cmluZyhvKSAmJiBhLnB1c2goXCJwYXRoPVwiICsgbyksIG4uaXNTdHJpbmcodSkgJiYgYS5wdXNoKFwiZG9tYWluPVwiICsgdSksIGwgPT09ICEwICYmIGEucHVzaChcInNlY3VyZVwiKSwgZG9jdW1lbnQuY29va2llID0gYS5qb2luKFwiOyBcIik7XG4gICAgICB9LFxuICAgICAgcmVhZDogZnVuY3Rpb24ocikge1xuICAgICAgICB2YXIgcyA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKFwiKF58O1xcXFxzKikoXCIgKyByICsgXCIpPShbXjtdKilcIikpO1xuICAgICAgICByZXR1cm4gcyA/IGRlY29kZVVSSUNvbXBvbmVudChzWzNdKSA6IG51bGw7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbihyKSB7XG4gICAgICAgIHRoaXMud3JpdGUociwgXCJcIiwgRGF0ZS5ub3coKSAtIDg2NGU1KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KCkgOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgfSxcbiAgICAgIHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgfVxuICAgIH07XG4gIH0oKSwgWHQ7XG59XG52YXIgUXQsIHVyO1xuZnVuY3Rpb24gQ2koKSB7XG4gIHJldHVybiB1ciB8fCAodXIgPSAxLCBRdCA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gL14oW2Etel1bYS16XFxkK1xcLS5dKjopP1xcL1xcLy9pLnRlc3QoZSk7XG4gIH0pLCBRdDtcbn1cbnZhciBadCwgY3I7XG5mdW5jdGlvbiBBaSgpIHtcbiAgcmV0dXJuIGNyIHx8IChjciA9IDEsIFp0ID0gZnVuY3Rpb24oZSwgdCkge1xuICAgIHJldHVybiB0ID8gZS5yZXBsYWNlKC9cXC8rJC8sIFwiXCIpICsgXCIvXCIgKyB0LnJlcGxhY2UoL15cXC8rLywgXCJcIikgOiBlO1xuICB9KSwgWnQ7XG59XG52YXIgZW4sIGxyO1xuZnVuY3Rpb24gRGkoKSB7XG4gIGlmIChscilcbiAgICByZXR1cm4gZW47XG4gIGxyID0gMTtcbiAgdmFyIG4gPSBDaSgpLCBlID0gQWkoKTtcbiAgcmV0dXJuIGVuID0gZnVuY3Rpb24ociwgcykge1xuICAgIHJldHVybiByICYmICFuKHMpID8gZShyLCBzKSA6IHM7XG4gIH0sIGVuO1xufVxudmFyIHRuLCBmcjtcbmZ1bmN0aW9uIGtpKCkge1xuICBpZiAoZnIpXG4gICAgcmV0dXJuIHRuO1xuICBmciA9IDE7XG4gIHZhciBuID0gYWUsIGUgPSBbXG4gICAgXCJhZ2VcIixcbiAgICBcImF1dGhvcml6YXRpb25cIixcbiAgICBcImNvbnRlbnQtbGVuZ3RoXCIsXG4gICAgXCJjb250ZW50LXR5cGVcIixcbiAgICBcImV0YWdcIixcbiAgICBcImV4cGlyZXNcIixcbiAgICBcImZyb21cIixcbiAgICBcImhvc3RcIixcbiAgICBcImlmLW1vZGlmaWVkLXNpbmNlXCIsXG4gICAgXCJpZi11bm1vZGlmaWVkLXNpbmNlXCIsXG4gICAgXCJsYXN0LW1vZGlmaWVkXCIsXG4gICAgXCJsb2NhdGlvblwiLFxuICAgIFwibWF4LWZvcndhcmRzXCIsXG4gICAgXCJwcm94eS1hdXRob3JpemF0aW9uXCIsXG4gICAgXCJyZWZlcmVyXCIsXG4gICAgXCJyZXRyeS1hZnRlclwiLFxuICAgIFwidXNlci1hZ2VudFwiXG4gIF07XG4gIHJldHVybiB0biA9IGZ1bmN0aW9uKHIpIHtcbiAgICB2YXIgcyA9IHt9LCBpLCBvLCB1O1xuICAgIHJldHVybiByICYmIG4uZm9yRWFjaChyLnNwbGl0KGBcbmApLCBmdW5jdGlvbihhKSB7XG4gICAgICBpZiAodSA9IGEuaW5kZXhPZihcIjpcIiksIGkgPSBuLnRyaW0oYS5zdWJzdHIoMCwgdSkpLnRvTG93ZXJDYXNlKCksIG8gPSBuLnRyaW0oYS5zdWJzdHIodSArIDEpKSwgaSkge1xuICAgICAgICBpZiAoc1tpXSAmJiBlLmluZGV4T2YoaSkgPj0gMClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGkgPT09IFwic2V0LWNvb2tpZVwiID8gc1tpXSA9IChzW2ldID8gc1tpXSA6IFtdKS5jb25jYXQoW29dKSA6IHNbaV0gPSBzW2ldID8gc1tpXSArIFwiLCBcIiArIG8gOiBvO1xuICAgICAgfVxuICAgIH0pLCBzO1xuICB9LCB0bjtcbn1cbnZhciBubiwgaHI7XG5mdW5jdGlvbiBMaSgpIHtcbiAgaWYgKGhyKVxuICAgIHJldHVybiBubjtcbiAgaHIgPSAxO1xuICB2YXIgbiA9IGFlO1xuICByZXR1cm4gbm4gPSBuLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgPyBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksIHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKSwgcztcbiAgICBmdW5jdGlvbiBpKG8pIHtcbiAgICAgIHZhciB1ID0gbztcbiAgICAgIHJldHVybiB0ICYmIChyLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgdSksIHUgPSByLmhyZWYpLCByLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgdSksIHtcbiAgICAgICAgaHJlZjogci5ocmVmLFxuICAgICAgICBwcm90b2NvbDogci5wcm90b2NvbCA/IHIucHJvdG9jb2wucmVwbGFjZSgvOiQvLCBcIlwiKSA6IFwiXCIsXG4gICAgICAgIGhvc3Q6IHIuaG9zdCxcbiAgICAgICAgc2VhcmNoOiByLnNlYXJjaCA/IHIuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCBcIlwiKSA6IFwiXCIsXG4gICAgICAgIGhhc2g6IHIuaGFzaCA/IHIuaGFzaC5yZXBsYWNlKC9eIy8sIFwiXCIpIDogXCJcIixcbiAgICAgICAgaG9zdG5hbWU6IHIuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHIucG9ydCxcbiAgICAgICAgcGF0aG5hbWU6IHIucGF0aG5hbWUuY2hhckF0KDApID09PSBcIi9cIiA/IHIucGF0aG5hbWUgOiBcIi9cIiArIHIucGF0aG5hbWVcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBzID0gaSh3aW5kb3cubG9jYXRpb24uaHJlZiksIGZ1bmN0aW9uKHUpIHtcbiAgICAgIHZhciBsID0gbi5pc1N0cmluZyh1KSA/IGkodSkgOiB1O1xuICAgICAgcmV0dXJuIGwucHJvdG9jb2wgPT09IHMucHJvdG9jb2wgJiYgbC5ob3N0ID09PSBzLmhvc3Q7XG4gICAgfTtcbiAgfSgpIDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICEwO1xuICAgIH07XG4gIH0oKSwgbm47XG59XG52YXIgcm4sIGRyO1xuZnVuY3Rpb24gcXQoKSB7XG4gIGlmIChkcilcbiAgICByZXR1cm4gcm47XG4gIGRyID0gMTtcbiAgZnVuY3Rpb24gbihlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gZTtcbiAgfVxuICByZXR1cm4gbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJDYW5jZWxcIiArICh0aGlzLm1lc3NhZ2UgPyBcIjogXCIgKyB0aGlzLm1lc3NhZ2UgOiBcIlwiKTtcbiAgfSwgbi5wcm90b3R5cGUuX19DQU5DRUxfXyA9ICEwLCBybiA9IG4sIHJuO1xufVxudmFyIHNuLCBwcjtcbmZ1bmN0aW9uIHZyKCkge1xuICBpZiAocHIpXG4gICAgcmV0dXJuIHNuO1xuICBwciA9IDE7XG4gIHZhciBuID0gYWUsIGUgPSBPaSgpLCB0ID0geGkoKSwgciA9IHRzLCBzID0gRGkoKSwgaSA9IGtpKCksIG8gPSBMaSgpLCB1ID0gc3MoKSwgbCA9IHJzLCBhID0gcXQoKTtcbiAgcmV0dXJuIHNuID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihtLCBnKSB7XG4gICAgICB2YXIgYiA9IGYuZGF0YSwgRSA9IGYuaGVhZGVycywgXyA9IGYucmVzcG9uc2VUeXBlLCBTO1xuICAgICAgZnVuY3Rpb24gaygpIHtcbiAgICAgICAgZi5jYW5jZWxUb2tlbiAmJiBmLmNhbmNlbFRva2VuLnVuc3Vic2NyaWJlKFMpLCBmLnNpZ25hbCAmJiBmLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgUyk7XG4gICAgICB9XG4gICAgICBuLmlzRm9ybURhdGEoYikgJiYgZGVsZXRlIEVbXCJDb250ZW50LVR5cGVcIl07XG4gICAgICB2YXIgeSA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgaWYgKGYuYXV0aCkge1xuICAgICAgICB2YXIgTSA9IGYuYXV0aC51c2VybmFtZSB8fCBcIlwiLCBUID0gZi5hdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGYuYXV0aC5wYXNzd29yZCkpIDogXCJcIjtcbiAgICAgICAgRS5BdXRob3JpemF0aW9uID0gXCJCYXNpYyBcIiArIGJ0b2EoTSArIFwiOlwiICsgVCk7XG4gICAgICB9XG4gICAgICB2YXIgViA9IHMoZi5iYXNlVVJMLCBmLnVybCk7XG4gICAgICB5Lm9wZW4oZi5tZXRob2QudG9VcHBlckNhc2UoKSwgcihWLCBmLnBhcmFtcywgZi5wYXJhbXNTZXJpYWxpemVyKSwgITApLCB5LnRpbWVvdXQgPSBmLnRpbWVvdXQ7XG4gICAgICBmdW5jdGlvbiBEKCkge1xuICAgICAgICBpZiAoISF5KSB7XG4gICAgICAgICAgdmFyIEwgPSBcImdldEFsbFJlc3BvbnNlSGVhZGVyc1wiIGluIHkgPyBpKHkuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbCwgUSA9ICFfIHx8IF8gPT09IFwidGV4dFwiIHx8IF8gPT09IFwianNvblwiID8geS5yZXNwb25zZVRleHQgOiB5LnJlc3BvbnNlLCBuZSA9IHtcbiAgICAgICAgICAgIGRhdGE6IFEsXG4gICAgICAgICAgICBzdGF0dXM6IHkuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogeS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgaGVhZGVyczogTCxcbiAgICAgICAgICAgIGNvbmZpZzogZixcbiAgICAgICAgICAgIHJlcXVlc3Q6IHlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGUoZnVuY3Rpb24oRikge1xuICAgICAgICAgICAgbShGKSwgaygpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKEYpIHtcbiAgICAgICAgICAgIGcoRiksIGsoKTtcbiAgICAgICAgICB9LCBuZSksIHkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoXCJvbmxvYWRlbmRcIiBpbiB5ID8geS5vbmxvYWRlbmQgPSBEIDogeS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgIXkgfHwgeS5yZWFkeVN0YXRlICE9PSA0IHx8IHkuc3RhdHVzID09PSAwICYmICEoeS5yZXNwb25zZVVSTCAmJiB5LnJlc3BvbnNlVVJMLmluZGV4T2YoXCJmaWxlOlwiKSA9PT0gMCkgfHwgc2V0VGltZW91dChEKTtcbiAgICAgIH0sIHkub25hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAheSB8fCAoZyh1KFwiUmVxdWVzdCBhYm9ydGVkXCIsIGYsIFwiRUNPTk5BQk9SVEVEXCIsIHkpKSwgeSA9IG51bGwpO1xuICAgICAgfSwgeS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGcodShcIk5ldHdvcmsgRXJyb3JcIiwgZiwgbnVsbCwgeSkpLCB5ID0gbnVsbDtcbiAgICAgIH0sIHkub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBRID0gZi50aW1lb3V0ID8gXCJ0aW1lb3V0IG9mIFwiICsgZi50aW1lb3V0ICsgXCJtcyBleGNlZWRlZFwiIDogXCJ0aW1lb3V0IGV4Y2VlZGVkXCIsIG5lID0gZi50cmFuc2l0aW9uYWwgfHwgbDtcbiAgICAgICAgZi50aW1lb3V0RXJyb3JNZXNzYWdlICYmIChRID0gZi50aW1lb3V0RXJyb3JNZXNzYWdlKSwgZyh1KFxuICAgICAgICAgIFEsXG4gICAgICAgICAgZixcbiAgICAgICAgICBuZS5jbGFyaWZ5VGltZW91dEVycm9yID8gXCJFVElNRURPVVRcIiA6IFwiRUNPTk5BQk9SVEVEXCIsXG4gICAgICAgICAgeVxuICAgICAgICApKSwgeSA9IG51bGw7XG4gICAgICB9LCBuLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgICAgdmFyIGogPSAoZi53aXRoQ3JlZGVudGlhbHMgfHwgbyhWKSkgJiYgZi54c3JmQ29va2llTmFtZSA/IHQucmVhZChmLnhzcmZDb29raWVOYW1lKSA6IHZvaWQgMDtcbiAgICAgICAgaiAmJiAoRVtmLnhzcmZIZWFkZXJOYW1lXSA9IGopO1xuICAgICAgfVxuICAgICAgXCJzZXRSZXF1ZXN0SGVhZGVyXCIgaW4geSAmJiBuLmZvckVhY2goRSwgZnVuY3Rpb24oUSwgbmUpIHtcbiAgICAgICAgdHlwZW9mIGIgPiBcInVcIiAmJiBuZS50b0xvd2VyQ2FzZSgpID09PSBcImNvbnRlbnQtdHlwZVwiID8gZGVsZXRlIEVbbmVdIDogeS5zZXRSZXF1ZXN0SGVhZGVyKG5lLCBRKTtcbiAgICAgIH0pLCBuLmlzVW5kZWZpbmVkKGYud2l0aENyZWRlbnRpYWxzKSB8fCAoeS53aXRoQ3JlZGVudGlhbHMgPSAhIWYud2l0aENyZWRlbnRpYWxzKSwgXyAmJiBfICE9PSBcImpzb25cIiAmJiAoeS5yZXNwb25zZVR5cGUgPSBmLnJlc3BvbnNlVHlwZSksIHR5cGVvZiBmLm9uRG93bmxvYWRQcm9ncmVzcyA9PSBcImZ1bmN0aW9uXCIgJiYgeS5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgZi5vbkRvd25sb2FkUHJvZ3Jlc3MpLCB0eXBlb2YgZi5vblVwbG9hZFByb2dyZXNzID09IFwiZnVuY3Rpb25cIiAmJiB5LnVwbG9hZCAmJiB5LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgZi5vblVwbG9hZFByb2dyZXNzKSwgKGYuY2FuY2VsVG9rZW4gfHwgZi5zaWduYWwpICYmIChTID0gZnVuY3Rpb24oTCkge1xuICAgICAgICAheSB8fCAoZyghTCB8fCBMICYmIEwudHlwZSA/IG5ldyBhKFwiY2FuY2VsZWRcIikgOiBMKSwgeS5hYm9ydCgpLCB5ID0gbnVsbCk7XG4gICAgICB9LCBmLmNhbmNlbFRva2VuICYmIGYuY2FuY2VsVG9rZW4uc3Vic2NyaWJlKFMpLCBmLnNpZ25hbCAmJiAoZi5zaWduYWwuYWJvcnRlZCA/IFMoKSA6IGYuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBTKSkpLCBiIHx8IChiID0gbnVsbCksIHkuc2VuZChiKTtcbiAgICB9KTtcbiAgfSwgc247XG59XG52YXIgWiA9IGFlLCB5ciA9IFRpLCBOaSA9IG5zLCBQaSA9IHJzLCBCaSA9IHtcbiAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxufTtcbmZ1bmN0aW9uIG1yKG4sIGUpIHtcbiAgIVouaXNVbmRlZmluZWQobikgJiYgWi5pc1VuZGVmaW5lZChuW1wiQ29udGVudC1UeXBlXCJdKSAmJiAobltcIkNvbnRlbnQtVHlwZVwiXSA9IGUpO1xufVxuZnVuY3Rpb24gRmkoKSB7XG4gIHZhciBuO1xuICByZXR1cm4gKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA8IFwidVwiIHx8IHR5cGVvZiBwcm9jZXNzIDwgXCJ1XCIgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikgJiYgKG4gPSB2cigpKSwgbjtcbn1cbmZ1bmN0aW9uIFVpKG4sIGUsIHQpIHtcbiAgaWYgKFouaXNTdHJpbmcobikpXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZSB8fCBKU09OLnBhcnNlKShuKSwgWi50cmltKG4pO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIGlmIChyLm5hbWUgIT09IFwiU3ludGF4RXJyb3JcIilcbiAgICAgICAgdGhyb3cgcjtcbiAgICB9XG4gIHJldHVybiAodCB8fCBKU09OLnN0cmluZ2lmeSkobik7XG59XG52YXIgSXQgPSB7XG4gIHRyYW5zaXRpb25hbDogUGksXG4gIGFkYXB0ZXI6IEZpKCksXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbihlLCB0KSB7XG4gICAgcmV0dXJuIHlyKHQsIFwiQWNjZXB0XCIpLCB5cih0LCBcIkNvbnRlbnQtVHlwZVwiKSwgWi5pc0Zvcm1EYXRhKGUpIHx8IFouaXNBcnJheUJ1ZmZlcihlKSB8fCBaLmlzQnVmZmVyKGUpIHx8IFouaXNTdHJlYW0oZSkgfHwgWi5pc0ZpbGUoZSkgfHwgWi5pc0Jsb2IoZSkgPyBlIDogWi5pc0FycmF5QnVmZmVyVmlldyhlKSA/IGUuYnVmZmVyIDogWi5pc1VSTFNlYXJjaFBhcmFtcyhlKSA/IChtcih0LCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04XCIpLCBlLnRvU3RyaW5nKCkpIDogWi5pc09iamVjdChlKSB8fCB0ICYmIHRbXCJDb250ZW50LVR5cGVcIl0gPT09IFwiYXBwbGljYXRpb24vanNvblwiID8gKG1yKHQsIFwiYXBwbGljYXRpb24vanNvblwiKSwgVWkoZSkpIDogZTtcbiAgfV0sXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24oZSkge1xuICAgIHZhciB0ID0gdGhpcy50cmFuc2l0aW9uYWwgfHwgSXQudHJhbnNpdGlvbmFsLCByID0gdCAmJiB0LnNpbGVudEpTT05QYXJzaW5nLCBzID0gdCAmJiB0LmZvcmNlZEpTT05QYXJzaW5nLCBpID0gIXIgJiYgdGhpcy5yZXNwb25zZVR5cGUgPT09IFwianNvblwiO1xuICAgIGlmIChpIHx8IHMgJiYgWi5pc1N0cmluZyhlKSAmJiBlLmxlbmd0aClcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGUpO1xuICAgICAgfSBjYXRjaCAobykge1xuICAgICAgICBpZiAoaSlcbiAgICAgICAgICB0aHJvdyBvLm5hbWUgPT09IFwiU3ludGF4RXJyb3JcIiA/IE5pKG8sIHRoaXMsIFwiRV9KU09OX1BBUlNFXCIpIDogbztcbiAgICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfV0sXG4gIHRpbWVvdXQ6IDAsXG4gIHhzcmZDb29raWVOYW1lOiBcIlhTUkYtVE9LRU5cIixcbiAgeHNyZkhlYWRlck5hbWU6IFwiWC1YU1JGLVRPS0VOXCIsXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuICBtYXhCb2R5TGVuZ3RoOiAtMSxcbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gZSA+PSAyMDAgJiYgZSA8IDMwMDtcbiAgfSxcbiAgaGVhZGVyczoge1xuICAgIGNvbW1vbjoge1xuICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKlwiXG4gICAgfVxuICB9XG59O1xuWi5mb3JFYWNoKFtcImRlbGV0ZVwiLCBcImdldFwiLCBcImhlYWRcIl0sIGZ1bmN0aW9uKGUpIHtcbiAgSXQuaGVhZGVyc1tlXSA9IHt9O1xufSk7XG5aLmZvckVhY2goW1wicG9zdFwiLCBcInB1dFwiLCBcInBhdGNoXCJdLCBmdW5jdGlvbihlKSB7XG4gIEl0LmhlYWRlcnNbZV0gPSBaLm1lcmdlKEJpKTtcbn0pO1xudmFyIEluID0gSXQsIHFpID0gYWUsIElpID0gSW4sIFZpID0gZnVuY3Rpb24oZSwgdCwgcikge1xuICB2YXIgcyA9IHRoaXMgfHwgSWk7XG4gIHJldHVybiBxaS5mb3JFYWNoKHIsIGZ1bmN0aW9uKG8pIHtcbiAgICBlID0gby5jYWxsKHMsIGUsIHQpO1xuICB9KSwgZTtcbn0sIG9uLCBncjtcbmZ1bmN0aW9uIGlzKCkge1xuICByZXR1cm4gZ3IgfHwgKGdyID0gMSwgb24gPSBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuICEhKGUgJiYgZS5fX0NBTkNFTF9fKTtcbiAgfSksIG9uO1xufVxudmFyIF9yID0gYWUsIGFuID0gVmksIGppID0gaXMoKSwgJGkgPSBJbiwgTWkgPSBxdCgpO1xuZnVuY3Rpb24gdW4obikge1xuICBpZiAobi5jYW5jZWxUb2tlbiAmJiBuLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKSwgbi5zaWduYWwgJiYgbi5zaWduYWwuYWJvcnRlZClcbiAgICB0aHJvdyBuZXcgTWkoXCJjYW5jZWxlZFwiKTtcbn1cbnZhciBXaSA9IGZ1bmN0aW9uKGUpIHtcbiAgdW4oZSksIGUuaGVhZGVycyA9IGUuaGVhZGVycyB8fCB7fSwgZS5kYXRhID0gYW4uY2FsbChcbiAgICBlLFxuICAgIGUuZGF0YSxcbiAgICBlLmhlYWRlcnMsXG4gICAgZS50cmFuc2Zvcm1SZXF1ZXN0XG4gICksIGUuaGVhZGVycyA9IF9yLm1lcmdlKFxuICAgIGUuaGVhZGVycy5jb21tb24gfHwge30sXG4gICAgZS5oZWFkZXJzW2UubWV0aG9kXSB8fCB7fSxcbiAgICBlLmhlYWRlcnNcbiAgKSwgX3IuZm9yRWFjaChcbiAgICBbXCJkZWxldGVcIiwgXCJnZXRcIiwgXCJoZWFkXCIsIFwicG9zdFwiLCBcInB1dFwiLCBcInBhdGNoXCIsIFwiY29tbW9uXCJdLFxuICAgIGZ1bmN0aW9uKHMpIHtcbiAgICAgIGRlbGV0ZSBlLmhlYWRlcnNbc107XG4gICAgfVxuICApO1xuICB2YXIgdCA9IGUuYWRhcHRlciB8fCAkaS5hZGFwdGVyO1xuICByZXR1cm4gdChlKS50aGVuKGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gdW4oZSksIHMuZGF0YSA9IGFuLmNhbGwoXG4gICAgICBlLFxuICAgICAgcy5kYXRhLFxuICAgICAgcy5oZWFkZXJzLFxuICAgICAgZS50cmFuc2Zvcm1SZXNwb25zZVxuICAgICksIHM7XG4gIH0sIGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gamkocykgfHwgKHVuKGUpLCBzICYmIHMucmVzcG9uc2UgJiYgKHMucmVzcG9uc2UuZGF0YSA9IGFuLmNhbGwoXG4gICAgICBlLFxuICAgICAgcy5yZXNwb25zZS5kYXRhLFxuICAgICAgcy5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgZS50cmFuc2Zvcm1SZXNwb25zZVxuICAgICkpKSwgUHJvbWlzZS5yZWplY3Qocyk7XG4gIH0pO1xufSwgdWUgPSBhZSwgb3MgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHQgPSB0IHx8IHt9O1xuICB2YXIgciA9IHt9O1xuICBmdW5jdGlvbiBzKGgsIGYpIHtcbiAgICByZXR1cm4gdWUuaXNQbGFpbk9iamVjdChoKSAmJiB1ZS5pc1BsYWluT2JqZWN0KGYpID8gdWUubWVyZ2UoaCwgZikgOiB1ZS5pc1BsYWluT2JqZWN0KGYpID8gdWUubWVyZ2Uoe30sIGYpIDogdWUuaXNBcnJheShmKSA/IGYuc2xpY2UoKSA6IGY7XG4gIH1cbiAgZnVuY3Rpb24gaShoKSB7XG4gICAgaWYgKHVlLmlzVW5kZWZpbmVkKHRbaF0pKSB7XG4gICAgICBpZiAoIXVlLmlzVW5kZWZpbmVkKGVbaF0pKVxuICAgICAgICByZXR1cm4gcyh2b2lkIDAsIGVbaF0pO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHMoZVtoXSwgdFtoXSk7XG4gIH1cbiAgZnVuY3Rpb24gbyhoKSB7XG4gICAgaWYgKCF1ZS5pc1VuZGVmaW5lZCh0W2hdKSlcbiAgICAgIHJldHVybiBzKHZvaWQgMCwgdFtoXSk7XG4gIH1cbiAgZnVuY3Rpb24gdShoKSB7XG4gICAgaWYgKHVlLmlzVW5kZWZpbmVkKHRbaF0pKSB7XG4gICAgICBpZiAoIXVlLmlzVW5kZWZpbmVkKGVbaF0pKVxuICAgICAgICByZXR1cm4gcyh2b2lkIDAsIGVbaF0pO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHModm9pZCAwLCB0W2hdKTtcbiAgfVxuICBmdW5jdGlvbiBsKGgpIHtcbiAgICBpZiAoaCBpbiB0KVxuICAgICAgcmV0dXJuIHMoZVtoXSwgdFtoXSk7XG4gICAgaWYgKGggaW4gZSlcbiAgICAgIHJldHVybiBzKHZvaWQgMCwgZVtoXSk7XG4gIH1cbiAgdmFyIGEgPSB7XG4gICAgdXJsOiBvLFxuICAgIG1ldGhvZDogbyxcbiAgICBkYXRhOiBvLFxuICAgIGJhc2VVUkw6IHUsXG4gICAgdHJhbnNmb3JtUmVxdWVzdDogdSxcbiAgICB0cmFuc2Zvcm1SZXNwb25zZTogdSxcbiAgICBwYXJhbXNTZXJpYWxpemVyOiB1LFxuICAgIHRpbWVvdXQ6IHUsXG4gICAgdGltZW91dE1lc3NhZ2U6IHUsXG4gICAgd2l0aENyZWRlbnRpYWxzOiB1LFxuICAgIGFkYXB0ZXI6IHUsXG4gICAgcmVzcG9uc2VUeXBlOiB1LFxuICAgIHhzcmZDb29raWVOYW1lOiB1LFxuICAgIHhzcmZIZWFkZXJOYW1lOiB1LFxuICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IHUsXG4gICAgb25Eb3dubG9hZFByb2dyZXNzOiB1LFxuICAgIGRlY29tcHJlc3M6IHUsXG4gICAgbWF4Q29udGVudExlbmd0aDogdSxcbiAgICBtYXhCb2R5TGVuZ3RoOiB1LFxuICAgIHRyYW5zcG9ydDogdSxcbiAgICBodHRwQWdlbnQ6IHUsXG4gICAgaHR0cHNBZ2VudDogdSxcbiAgICBjYW5jZWxUb2tlbjogdSxcbiAgICBzb2NrZXRQYXRoOiB1LFxuICAgIHJlc3BvbnNlRW5jb2Rpbmc6IHUsXG4gICAgdmFsaWRhdGVTdGF0dXM6IGxcbiAgfTtcbiAgcmV0dXJuIHVlLmZvckVhY2goT2JqZWN0LmtleXMoZSkuY29uY2F0KE9iamVjdC5rZXlzKHQpKSwgZnVuY3Rpb24oZikge1xuICAgIHZhciBwID0gYVtmXSB8fCBpLCBtID0gcChmKTtcbiAgICB1ZS5pc1VuZGVmaW5lZChtKSAmJiBwICE9PSBsIHx8IChyW2ZdID0gbSk7XG4gIH0pLCByO1xufSwgY24sIGJyO1xuZnVuY3Rpb24gYXMoKSB7XG4gIHJldHVybiBiciB8fCAoYnIgPSAxLCBjbiA9IHtcbiAgICB2ZXJzaW9uOiBcIjAuMjYuMVwiXG4gIH0pLCBjbjtcbn1cbnZhciBIaSA9IGFzKCkudmVyc2lvbiwgVm4gPSB7fTtcbltcIm9iamVjdFwiLCBcImJvb2xlYW5cIiwgXCJudW1iZXJcIiwgXCJmdW5jdGlvblwiLCBcInN0cmluZ1wiLCBcInN5bWJvbFwiXS5mb3JFYWNoKGZ1bmN0aW9uKG4sIGUpIHtcbiAgVm5bbl0gPSBmdW5jdGlvbihyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiByID09PSBuIHx8IFwiYVwiICsgKGUgPCAxID8gXCJuIFwiIDogXCIgXCIpICsgbjtcbiAgfTtcbn0pO1xudmFyIHdyID0ge307XG5Wbi50cmFuc2l0aW9uYWwgPSBmdW5jdGlvbihlLCB0LCByKSB7XG4gIGZ1bmN0aW9uIHMoaSwgbykge1xuICAgIHJldHVybiBcIltBeGlvcyB2XCIgKyBIaSArIFwiXSBUcmFuc2l0aW9uYWwgb3B0aW9uICdcIiArIGkgKyBcIidcIiArIG8gKyAociA/IFwiLiBcIiArIHIgOiBcIlwiKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oaSwgbywgdSkge1xuICAgIGlmIChlID09PSAhMSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihzKG8sIFwiIGhhcyBiZWVuIHJlbW92ZWRcIiArICh0ID8gXCIgaW4gXCIgKyB0IDogXCJcIikpKTtcbiAgICByZXR1cm4gdCAmJiAhd3Jbb10gJiYgKHdyW29dID0gITAsIGNvbnNvbGUud2FybihcbiAgICAgIHMoXG4gICAgICAgIG8sXG4gICAgICAgIFwiIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdlwiICsgdCArIFwiIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5lYXIgZnV0dXJlXCJcbiAgICAgIClcbiAgICApKSwgZSA/IGUoaSwgbywgdSkgOiAhMDtcbiAgfTtcbn07XG5mdW5jdGlvbiBKaShuLCBlLCB0KSB7XG4gIGlmICh0eXBlb2YgbiAhPSBcIm9iamVjdFwiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBmb3IgKHZhciByID0gT2JqZWN0LmtleXMobiksIHMgPSByLmxlbmd0aDsgcy0tID4gMDsgKSB7XG4gICAgdmFyIGkgPSByW3NdLCBvID0gZVtpXTtcbiAgICBpZiAobykge1xuICAgICAgdmFyIHUgPSBuW2ldLCBsID0gdSA9PT0gdm9pZCAwIHx8IG8odSwgaSwgbik7XG4gICAgICBpZiAobCAhPT0gITApXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb24gXCIgKyBpICsgXCIgbXVzdCBiZSBcIiArIGwpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0ICE9PSAhMClcbiAgICAgIHRocm93IEVycm9yKFwiVW5rbm93biBvcHRpb24gXCIgKyBpKTtcbiAgfVxufVxudmFyIFlpID0ge1xuICBhc3NlcnRPcHRpb25zOiBKaSxcbiAgdmFsaWRhdG9yczogVm5cbn0sIHVzID0gYWUsIHppID0gdHMsIEVyID0gUmksIFJyID0gV2ksIFZ0ID0gb3MsIGNzID0gWWksIHplID0gY3MudmFsaWRhdG9ycztcbmZ1bmN0aW9uIHB0KG4pIHtcbiAgdGhpcy5kZWZhdWx0cyA9IG4sIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBFcigpLFxuICAgIHJlc3BvbnNlOiBuZXcgRXIoKVxuICB9O1xufVxucHQucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihlLCB0KSB7XG4gIHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyAodCA9IHQgfHwge30sIHQudXJsID0gZSkgOiB0ID0gZSB8fCB7fSwgdCA9IFZ0KHRoaXMuZGVmYXVsdHMsIHQpLCB0Lm1ldGhvZCA/IHQubWV0aG9kID0gdC5tZXRob2QudG9Mb3dlckNhc2UoKSA6IHRoaXMuZGVmYXVsdHMubWV0aG9kID8gdC5tZXRob2QgPSB0aGlzLmRlZmF1bHRzLm1ldGhvZC50b0xvd2VyQ2FzZSgpIDogdC5tZXRob2QgPSBcImdldFwiO1xuICB2YXIgciA9IHQudHJhbnNpdGlvbmFsO1xuICByICE9PSB2b2lkIDAgJiYgY3MuYXNzZXJ0T3B0aW9ucyhyLCB7XG4gICAgc2lsZW50SlNPTlBhcnNpbmc6IHplLnRyYW5zaXRpb25hbCh6ZS5ib29sZWFuKSxcbiAgICBmb3JjZWRKU09OUGFyc2luZzogemUudHJhbnNpdGlvbmFsKHplLmJvb2xlYW4pLFxuICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHplLnRyYW5zaXRpb25hbCh6ZS5ib29sZWFuKVxuICB9LCAhMSk7XG4gIHZhciBzID0gW10sIGkgPSAhMDtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uKG0pIHtcbiAgICB0eXBlb2YgbS5ydW5XaGVuID09IFwiZnVuY3Rpb25cIiAmJiBtLnJ1bldoZW4odCkgPT09ICExIHx8IChpID0gaSAmJiBtLnN5bmNocm9ub3VzLCBzLnVuc2hpZnQobS5mdWxmaWxsZWQsIG0ucmVqZWN0ZWQpKTtcbiAgfSk7XG4gIHZhciBvID0gW107XG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24obSkge1xuICAgIG8ucHVzaChtLmZ1bGZpbGxlZCwgbS5yZWplY3RlZCk7XG4gIH0pO1xuICB2YXIgdTtcbiAgaWYgKCFpKSB7XG4gICAgdmFyIGwgPSBbUnIsIHZvaWQgMF07XG4gICAgZm9yIChBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShsLCBzKSwgbCA9IGwuY29uY2F0KG8pLCB1ID0gUHJvbWlzZS5yZXNvbHZlKHQpOyBsLmxlbmd0aDsgKVxuICAgICAgdSA9IHUudGhlbihsLnNoaWZ0KCksIGwuc2hpZnQoKSk7XG4gICAgcmV0dXJuIHU7XG4gIH1cbiAgZm9yICh2YXIgYSA9IHQ7IHMubGVuZ3RoOyApIHtcbiAgICB2YXIgaCA9IHMuc2hpZnQoKSwgZiA9IHMuc2hpZnQoKTtcbiAgICB0cnkge1xuICAgICAgYSA9IGgoYSk7XG4gICAgfSBjYXRjaCAocCkge1xuICAgICAgZihwKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB0cnkge1xuICAgIHUgPSBScihhKTtcbiAgfSBjYXRjaCAocCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChwKTtcbiAgfVxuICBmb3IgKDsgby5sZW5ndGg7IClcbiAgICB1ID0gdS50aGVuKG8uc2hpZnQoKSwgby5zaGlmdCgpKTtcbiAgcmV0dXJuIHU7XG59O1xucHQucHJvdG90eXBlLmdldFVyaSA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIGUgPSBWdCh0aGlzLmRlZmF1bHRzLCBlKSwgemkoZS51cmwsIGUucGFyYW1zLCBlLnBhcmFtc1NlcmlhbGl6ZXIpLnJlcGxhY2UoL15cXD8vLCBcIlwiKTtcbn07XG51cy5mb3JFYWNoKFtcImRlbGV0ZVwiLCBcImdldFwiLCBcImhlYWRcIiwgXCJvcHRpb25zXCJdLCBmdW5jdGlvbihlKSB7XG4gIHB0LnByb3RvdHlwZVtlXSA9IGZ1bmN0aW9uKHQsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFZ0KHIgfHwge30sIHtcbiAgICAgIG1ldGhvZDogZSxcbiAgICAgIHVybDogdCxcbiAgICAgIGRhdGE6IChyIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG51cy5mb3JFYWNoKFtcInBvc3RcIiwgXCJwdXRcIiwgXCJwYXRjaFwiXSwgZnVuY3Rpb24oZSkge1xuICBwdC5wcm90b3R5cGVbZV0gPSBmdW5jdGlvbih0LCByLCBzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChWdChzIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IGUsXG4gICAgICB1cmw6IHQsXG4gICAgICBkYXRhOiByXG4gICAgfSkpO1xuICB9O1xufSk7XG52YXIgS2kgPSBwdCwgbG4sIFNyO1xuZnVuY3Rpb24gR2koKSB7XG4gIGlmIChTcilcbiAgICByZXR1cm4gbG47XG4gIFNyID0gMTtcbiAgdmFyIG4gPSBxdCgpO1xuICBmdW5jdGlvbiBlKHQpIHtcbiAgICBpZiAodHlwZW9mIHQgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImV4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XG4gICAgdmFyIHI7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24obykge1xuICAgICAgciA9IG87XG4gICAgfSk7XG4gICAgdmFyIHMgPSB0aGlzO1xuICAgIHRoaXMucHJvbWlzZS50aGVuKGZ1bmN0aW9uKGkpIHtcbiAgICAgIGlmICghIXMuX2xpc3RlbmVycykge1xuICAgICAgICB2YXIgbywgdSA9IHMuX2xpc3RlbmVycy5sZW5ndGg7XG4gICAgICAgIGZvciAobyA9IDA7IG8gPCB1OyBvKyspXG4gICAgICAgICAgcy5fbGlzdGVuZXJzW29dKGkpO1xuICAgICAgICBzLl9saXN0ZW5lcnMgPSBudWxsO1xuICAgICAgfVxuICAgIH0pLCB0aGlzLnByb21pc2UudGhlbiA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciBvLCB1ID0gbmV3IFByb21pc2UoZnVuY3Rpb24obCkge1xuICAgICAgICBzLnN1YnNjcmliZShsKSwgbyA9IGw7XG4gICAgICB9KS50aGVuKGkpO1xuICAgICAgcmV0dXJuIHUuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHMudW5zdWJzY3JpYmUobyk7XG4gICAgICB9LCB1O1xuICAgIH0sIHQoZnVuY3Rpb24obykge1xuICAgICAgcy5yZWFzb24gfHwgKHMucmVhc29uID0gbmV3IG4obyksIHIocy5yZWFzb24pKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZS5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnJlYXNvbilcbiAgICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9LCBlLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbihyKSB7XG4gICAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgICByKHRoaXMucmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fbGlzdGVuZXJzID8gdGhpcy5fbGlzdGVuZXJzLnB1c2gocikgOiB0aGlzLl9saXN0ZW5lcnMgPSBbcl07XG4gIH0sIGUucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24ocikge1xuICAgIGlmICghIXRoaXMuX2xpc3RlbmVycykge1xuICAgICAgdmFyIHMgPSB0aGlzLl9saXN0ZW5lcnMuaW5kZXhPZihyKTtcbiAgICAgIHMgIT09IC0xICYmIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UocywgMSk7XG4gICAgfVxuICB9LCBlLnNvdXJjZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByLCBzID0gbmV3IGUoZnVuY3Rpb24obykge1xuICAgICAgciA9IG87XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRva2VuOiBzLFxuICAgICAgY2FuY2VsOiByXG4gICAgfTtcbiAgfSwgbG4gPSBlLCBsbjtcbn1cbnZhciBmbiwgVHI7XG5mdW5jdGlvbiBYaSgpIHtcbiAgcmV0dXJuIFRyIHx8IChUciA9IDEsIGZuID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihyKSB7XG4gICAgICByZXR1cm4gZS5hcHBseShudWxsLCByKTtcbiAgICB9O1xuICB9KSwgZm47XG59XG52YXIgaG4sIE9yO1xuZnVuY3Rpb24gUWkoKSB7XG4gIGlmIChPcilcbiAgICByZXR1cm4gaG47XG4gIE9yID0gMTtcbiAgdmFyIG4gPSBhZTtcbiAgcmV0dXJuIGhuID0gZnVuY3Rpb24odCkge1xuICAgIHJldHVybiBuLmlzT2JqZWN0KHQpICYmIHQuaXNBeGlvc0Vycm9yID09PSAhMDtcbiAgfSwgaG47XG59XG52YXIgeHIgPSBhZSwgWmkgPSBYciwgTHQgPSBLaSwgZW8gPSBvcywgdG8gPSBJbjtcbmZ1bmN0aW9uIGxzKG4pIHtcbiAgdmFyIGUgPSBuZXcgTHQobiksIHQgPSBaaShMdC5wcm90b3R5cGUucmVxdWVzdCwgZSk7XG4gIHJldHVybiB4ci5leHRlbmQodCwgTHQucHJvdG90eXBlLCBlKSwgeHIuZXh0ZW5kKHQsIGUpLCB0LmNyZWF0ZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICByZXR1cm4gbHMoZW8obiwgcykpO1xuICB9LCB0O1xufVxudmFyIF9lID0gbHModG8pO1xuX2UuQXhpb3MgPSBMdDtcbl9lLkNhbmNlbCA9IHF0KCk7XG5fZS5DYW5jZWxUb2tlbiA9IEdpKCk7XG5fZS5pc0NhbmNlbCA9IGlzKCk7XG5fZS5WRVJTSU9OID0gYXMoKS52ZXJzaW9uO1xuX2UuYWxsID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gUHJvbWlzZS5hbGwoZSk7XG59O1xuX2Uuc3ByZWFkID0gWGkoKTtcbl9lLmlzQXhpb3NFcnJvciA9IFFpKCk7XG5Gbi5leHBvcnRzID0gX2U7XG5Gbi5leHBvcnRzLmRlZmF1bHQgPSBfZTtcbihmdW5jdGlvbihuKSB7XG4gIG4uZXhwb3J0cyA9IEZuLmV4cG9ydHM7XG59KShHcik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoS2UsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbktlLmdldFJlcXVlc3RIZWFkZXJzID0gS2UuZ2V0QXhpb3NDbGllbnQgPSB2b2lkIDA7XG52YXIgbm8gPSBHci5leHBvcnRzO1xuZnVuY3Rpb24gcm8obiwgZSwgdCwgcikge1xuICByZXR1cm4gbm8uZGVmYXVsdC5jcmVhdGUoe1xuICAgIGJhc2VVUkw6IG4sXG4gICAgaGVhZGVyczogZnMoZSwgciwgdCksXG4gICAgd2l0aENyZWRlbnRpYWxzOiAhMFxuICB9KTtcbn1cbktlLmdldEF4aW9zQ2xpZW50ID0gcm87XG5mdW5jdGlvbiBmcyhuLCBlLCB0KSB7XG4gIG4gPT09IHZvaWQgMCAmJiAobiA9ICExKTtcbiAgdmFyIHIgPSB7XG4gICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICB9O1xuICByZXR1cm4gbiAmJiBlICYmIHQgJiYgKHIuQXV0aG9yaXphdGlvbiA9IFwiXCIuY29uY2F0KGUsIFwiIFwiKS5jb25jYXQodCgpKSksIHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB0eXBlb2YgZG9jdW1lbnQgPCBcInVcIiAmJiAod2luZG93LmxvY2F0aW9uICYmIChyW1wiWC1GcmFwcGUtU2l0ZS1OYW1lXCJdID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKSwgd2luZG93LmNzcmZfdG9rZW4gJiYgd2luZG93LmNzcmZfdG9rZW4gIT09IFwie3sgY3NyZl90b2tlbiB9fVwiICYmIChyW1wiWC1GcmFwcGUtQ1NSRi1Ub2tlblwiXSA9IHdpbmRvdy5jc3JmX3Rva2VuKSksIHI7XG59XG5LZS5nZXRSZXF1ZXN0SGVhZGVycyA9IGZzO1xudmFyIENyO1xuZnVuY3Rpb24gc28oKSB7XG4gIGlmIChDcilcbiAgICByZXR1cm4gcnQ7XG4gIENyID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJ0LCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIHJ0LkZyYXBwZUFwcCA9IHZvaWQgMDtcbiAgdmFyIG4gPSBocygpLCBlID0gZnQsIHQgPSBodCwgciA9IGR0LCBzID0gS2UsIGkgPSBmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBvKHUsIGwsIGEpIHtcbiAgICAgIHZhciBoLCBmO1xuICAgICAgdGhpcy51cmwgPSB1LCB0aGlzLm5hbWUgPSBhICE9IG51bGwgPyBhIDogXCJGcmFwcGVBcHBcIiwgdGhpcy51c2VUb2tlbiA9IChoID0gbCA9PSBudWxsID8gdm9pZCAwIDogbC51c2VUb2tlbikgIT09IG51bGwgJiYgaCAhPT0gdm9pZCAwID8gaCA6ICExLCB0aGlzLnRva2VuID0gbCA9PSBudWxsID8gdm9pZCAwIDogbC50b2tlbiwgdGhpcy50b2tlblR5cGUgPSAoZiA9IGwgPT0gbnVsbCA/IHZvaWQgMCA6IGwudHlwZSkgIT09IG51bGwgJiYgZiAhPT0gdm9pZCAwID8gZiA6IFwiQmVhcmVyXCIsIHRoaXMuYXhpb3MgPSAoMCwgcy5nZXRBeGlvc0NsaWVudCkodGhpcy51cmwsIHRoaXMudXNlVG9rZW4sIHRoaXMudG9rZW4sIHRoaXMudG9rZW5UeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIG8ucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgbi5GcmFwcGVBdXRoKHRoaXMudXJsLCB0aGlzLmF4aW9zLCB0aGlzLnVzZVRva2VuLCB0aGlzLnRva2VuLCB0aGlzLnRva2VuVHlwZSk7XG4gICAgfSwgby5wcm90b3R5cGUuZGIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgdC5GcmFwcGVEQih0aGlzLnVybCwgdGhpcy5heGlvcywgdGhpcy51c2VUb2tlbiwgdGhpcy50b2tlbiwgdGhpcy50b2tlblR5cGUpO1xuICAgIH0sIG8ucHJvdG90eXBlLmZpbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgci5GcmFwcGVGaWxlVXBsb2FkKHRoaXMudXJsLCB0aGlzLmF4aW9zLCB0aGlzLnVzZVRva2VuLCB0aGlzLnRva2VuLCB0aGlzLnRva2VuVHlwZSk7XG4gICAgfSwgby5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBlLkZyYXBwZUNhbGwodGhpcy51cmwsIHRoaXMuYXhpb3MsIHRoaXMudXNlVG9rZW4sIHRoaXMudG9rZW4sIHRoaXMudG9rZW5UeXBlKTtcbiAgICB9LCBvO1xuICB9KCk7XG4gIHJldHVybiBydC5GcmFwcGVBcHAgPSBpLCBydDtcbn1cbnZhciBqdCA9IHt9LCB5ZSA9IEIgJiYgQi5fX2Fzc2lnbiB8fCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHllID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbihuKSB7XG4gICAgZm9yICh2YXIgZSwgdCA9IDEsIHIgPSBhcmd1bWVudHMubGVuZ3RoOyB0IDwgcjsgdCsrKSB7XG4gICAgICBlID0gYXJndW1lbnRzW3RdO1xuICAgICAgZm9yICh2YXIgcyBpbiBlKVxuICAgICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSwgcykgJiYgKG5bc10gPSBlW3NdKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH0sIHllLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59LCBSdCA9IEIgJiYgQi5fX2F3YWl0ZXIgfHwgZnVuY3Rpb24obiwgZSwgdCwgcikge1xuICBmdW5jdGlvbiBzKGkpIHtcbiAgICByZXR1cm4gaSBpbnN0YW5jZW9mIHQgPyBpIDogbmV3IHQoZnVuY3Rpb24obykge1xuICAgICAgbyhpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbmV3ICh0IHx8ICh0ID0gUHJvbWlzZSkpKGZ1bmN0aW9uKGksIG8pIHtcbiAgICBmdW5jdGlvbiB1KGgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGEoci5uZXh0KGgpKTtcbiAgICAgIH0gY2F0Y2ggKGYpIHtcbiAgICAgICAgbyhmKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gbChoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhKHIudGhyb3coaCkpO1xuICAgICAgfSBjYXRjaCAoZikge1xuICAgICAgICBvKGYpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhKGgpIHtcbiAgICAgIGguZG9uZSA/IGkoaC52YWx1ZSkgOiBzKGgudmFsdWUpLnRoZW4odSwgbCk7XG4gICAgfVxuICAgIGEoKHIgPSByLmFwcGx5KG4sIGUgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn0sIFN0ID0gQiAmJiBCLl9fZ2VuZXJhdG9yIHx8IGZ1bmN0aW9uKG4sIGUpIHtcbiAgdmFyIHQgPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoaVswXSAmIDEpXG4gICAgICB0aHJvdyBpWzFdO1xuICAgIHJldHVybiBpWzFdO1xuICB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCByLCBzLCBpLCBvO1xuICByZXR1cm4gbyA9IHsgbmV4dDogdSgwKSwgdGhyb3c6IHUoMSksIHJldHVybjogdSgyKSB9LCB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiAob1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLCBvO1xuICBmdW5jdGlvbiB1KGEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oaCkge1xuICAgICAgcmV0dXJuIGwoW2EsIGhdKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGwoYSkge1xuICAgIGlmIChyKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgZm9yICg7IHQ7IClcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChyID0gMSwgcyAmJiAoaSA9IGFbMF0gJiAyID8gcy5yZXR1cm4gOiBhWzBdID8gcy50aHJvdyB8fCAoKGkgPSBzLnJldHVybikgJiYgaS5jYWxsKHMpLCAwKSA6IHMubmV4dCkgJiYgIShpID0gaS5jYWxsKHMsIGFbMV0pKS5kb25lKVxuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICBzd2l0Y2ggKHMgPSAwLCBpICYmIChhID0gW2FbMF0gJiAyLCBpLnZhbHVlXSksIGFbMF0pIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaSA9IGE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gdC5sYWJlbCsrLCB7IHZhbHVlOiBhWzFdLCBkb25lOiAhMSB9O1xuICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIHQubGFiZWwrKywgcyA9IGFbMV0sIGEgPSBbMF07XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBhID0gdC5vcHMucG9wKCksIHQudHJ5cy5wb3AoKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoaSA9IHQudHJ5cywgIShpID0gaS5sZW5ndGggPiAwICYmIGlbaS5sZW5ndGggLSAxXSkgJiYgKGFbMF0gPT09IDYgfHwgYVswXSA9PT0gMikpIHtcbiAgICAgICAgICAgICAgdCA9IDA7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFbMF0gPT09IDMgJiYgKCFpIHx8IGFbMV0gPiBpWzBdICYmIGFbMV0gPCBpWzNdKSkge1xuICAgICAgICAgICAgICB0LmxhYmVsID0gYVsxXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYVswXSA9PT0gNiAmJiB0LmxhYmVsIDwgaVsxXSkge1xuICAgICAgICAgICAgICB0LmxhYmVsID0gaVsxXSwgaSA9IGE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgJiYgdC5sYWJlbCA8IGlbMl0pIHtcbiAgICAgICAgICAgICAgdC5sYWJlbCA9IGlbMl0sIHQub3BzLnB1c2goYSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaVsyXSAmJiB0Lm9wcy5wb3AoKSwgdC50cnlzLnBvcCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYSA9IGUuY2FsbChuLCB0KTtcbiAgICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgICAgYSA9IFs2LCBoXSwgcyA9IDA7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByID0gaSA9IDA7XG4gICAgICB9XG4gICAgaWYgKGFbMF0gJiA1KVxuICAgICAgdGhyb3cgYVsxXTtcbiAgICByZXR1cm4geyB2YWx1ZTogYVswXSA/IGFbMV0gOiB2b2lkIDAsIGRvbmU6ICEwIH07XG4gIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoanQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KTtcbmp0LkZyYXBwZUF1dGggPSB2b2lkIDA7XG52YXIgaW8gPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gbihlLCB0LCByLCBzLCBpKSB7XG4gICAgdGhpcy5hcHBVUkwgPSBlLCB0aGlzLmF4aW9zID0gdCwgdGhpcy51c2VUb2tlbiA9IHIgIT0gbnVsbCA/IHIgOiAhMSwgdGhpcy50b2tlbiA9IHMsIHRoaXMudG9rZW5UeXBlID0gaTtcbiAgfVxuICByZXR1cm4gbi5wcm90b3R5cGUubG9naW5XaXRoVXNlcm5hbWVQYXNzd29yZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gUnQodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHQsIHIsIHM7XG4gICAgICByZXR1cm4gU3QodGhpcywgZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gdCA9IGUudXNlcm5hbWUsIHIgPSBlLnBhc3N3b3JkLCBzID0gZS5kZXZpY2UsIFsyLCB0aGlzLmF4aW9zLnBvc3QoXCIvYXBpL21ldGhvZC9sb2dpblwiLCB7XG4gICAgICAgICAgdXNyOiB0LFxuICAgICAgICAgIHB3ZDogcixcbiAgICAgICAgICBkZXZpY2U6IHNcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihvKSB7XG4gICAgICAgICAgcmV0dXJuIG8uZGF0YTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24obykge1xuICAgICAgICAgIHZhciB1LCBsO1xuICAgICAgICAgIHRocm93IHllKHllKHt9LCBvLnJlc3BvbnNlLmRhdGEpLCB7IGh0dHBTdGF0dXM6IG8ucmVzcG9uc2Uuc3RhdHVzLCBodHRwU3RhdHVzVGV4dDogby5yZXNwb25zZS5zdGF0dXNUZXh0LCBtZXNzYWdlOiAodSA9IG8ucmVzcG9uc2UuZGF0YS5tZXNzYWdlKSAhPT0gbnVsbCAmJiB1ICE9PSB2b2lkIDAgPyB1IDogXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgbG9nZ2luZyBpblwiLCBleGNlcHRpb246IChsID0gby5yZXNwb25zZS5kYXRhLmV4Y2VwdGlvbikgIT09IG51bGwgJiYgbCAhPT0gdm9pZCAwID8gbCA6IFwiXCIgfSk7XG4gICAgICAgIH0pXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCBuLnByb3RvdHlwZS5nZXRMb2dnZWRJblVzZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUnQodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFN0KHRoaXMsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmF4aW9zLmdldChcIi9hcGkvbWV0aG9kL2ZyYXBwZS5hdXRoLmdldF9sb2dnZWRfdXNlclwiKS50aGVuKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICByZXR1cm4gdC5kYXRhLm1lc3NhZ2U7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICB2YXIgcjtcbiAgICAgICAgICB0aHJvdyB5ZSh5ZSh7fSwgdC5yZXNwb25zZS5kYXRhKSwgeyBodHRwU3RhdHVzOiB0LnJlc3BvbnNlLnN0YXR1cywgaHR0cFN0YXR1c1RleHQ6IHQucmVzcG9uc2Uuc3RhdHVzVGV4dCwgbWVzc2FnZTogXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgZmV0Y2hpbmcgdGhlIGxvZ2dlZCBpbiB1c2VyXCIsIGV4Y2VwdGlvbjogKHIgPSB0LnJlc3BvbnNlLmRhdGEuZXhjZXB0aW9uKSAhPT0gbnVsbCAmJiByICE9PSB2b2lkIDAgPyByIDogXCJcIiB9KTtcbiAgICAgICAgfSldO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0sIG4ucHJvdG90eXBlLmxvZ291dCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBSdCh0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gU3QodGhpcywgZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gWzIsIHRoaXMuYXhpb3MucG9zdChcIi9hcGkvbWV0aG9kL2xvZ291dFwiLCB7fSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24odCkge1xuICAgICAgICAgIHZhciByLCBzO1xuICAgICAgICAgIHRocm93IHllKHllKHt9LCB0LnJlc3BvbnNlLmRhdGEpLCB7IGh0dHBTdGF0dXM6IHQucmVzcG9uc2Uuc3RhdHVzLCBodHRwU3RhdHVzVGV4dDogdC5yZXNwb25zZS5zdGF0dXNUZXh0LCBtZXNzYWdlOiAociA9IHQucmVzcG9uc2UuZGF0YS5tZXNzYWdlKSAhPT0gbnVsbCAmJiByICE9PSB2b2lkIDAgPyByIDogXCJUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgbG9nZ2luZyBvdXRcIiwgZXhjZXB0aW9uOiAocyA9IHQucmVzcG9uc2UuZGF0YS5leGNlcHRpb24pICE9PSBudWxsICYmIHMgIT09IHZvaWQgMCA/IHMgOiBcIlwiIH0pO1xuICAgICAgICB9KV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSwgbi5wcm90b3R5cGUuZm9yZ2V0UGFzc3dvcmQgPSBmdW5jdGlvbihlKSB7XG4gICAgcmV0dXJuIFJ0KHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBTdCh0aGlzLCBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBbMiwgdGhpcy5heGlvcy5wb3N0KFwiL1wiLCB7XG4gICAgICAgICAgY21kOiBcImZyYXBwZS5jb3JlLmRvY3R5cGUudXNlci51c2VyLnJlc2V0X3Bhc3N3b3JkXCIsXG4gICAgICAgICAgdXNlcjogZVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgdmFyIHMsIGk7XG4gICAgICAgICAgdGhyb3cgeWUoeWUoe30sIHIucmVzcG9uc2UuZGF0YSksIHsgaHR0cFN0YXR1czogci5yZXNwb25zZS5zdGF0dXMsIGh0dHBTdGF0dXNUZXh0OiByLnJlc3BvbnNlLnN0YXR1c1RleHQsIG1lc3NhZ2U6IChzID0gci5yZXNwb25zZS5kYXRhLm1lc3NhZ2UpICE9PSBudWxsICYmIHMgIT09IHZvaWQgMCA/IHMgOiBcIlRoZXJlIHdhcyBhbiBlcnJvciBzZW5kaW5nIHBhc3N3b3JkIHJlc2V0IGVtYWlsLlwiLCBleGNlcHRpb246IChpID0gci5yZXNwb25zZS5kYXRhLmV4Y2VwdGlvbikgIT09IG51bGwgJiYgaSAhPT0gdm9pZCAwID8gaSA6IFwiXCIgfSk7XG4gICAgICAgIH0pXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9LCBuO1xufSgpO1xuanQuRnJhcHBlQXV0aCA9IGlvO1xudmFyIEFyO1xuZnVuY3Rpb24gaHMoKSB7XG4gIHJldHVybiBBciB8fCAoQXIgPSAxLCBmdW5jdGlvbihuKSB7XG4gICAgdmFyIGUgPSBCICYmIEIuX19jcmVhdGVCaW5kaW5nIHx8IChPYmplY3QuY3JlYXRlID8gZnVuY3Rpb24ociwgcywgaSwgbykge1xuICAgICAgbyA9PT0gdm9pZCAwICYmIChvID0gaSk7XG4gICAgICB2YXIgdSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocywgaSk7XG4gICAgICAoIXUgfHwgKFwiZ2V0XCIgaW4gdSA/ICFzLl9fZXNNb2R1bGUgOiB1LndyaXRhYmxlIHx8IHUuY29uZmlndXJhYmxlKSkgJiYgKHUgPSB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc1tpXTtcbiAgICAgIH0gfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLCBvLCB1KTtcbiAgICB9IDogZnVuY3Rpb24ociwgcywgaSwgbykge1xuICAgICAgbyA9PT0gdm9pZCAwICYmIChvID0gaSksIHJbb10gPSBzW2ldO1xuICAgIH0pLCB0ID0gQiAmJiBCLl9fZXhwb3J0U3RhciB8fCBmdW5jdGlvbihyLCBzKSB7XG4gICAgICBmb3IgKHZhciBpIGluIHIpXG4gICAgICAgIGkgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgaSkgJiYgZShzLCByLCBpKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIHQoc28oKSwgbiksIHQoanQsIG4pLCB0KGh0LCBuKSwgdChkdCwgbiksIHQoZnQsIG4pO1xuICB9KHp0KSksIHp0O1xufVxudmFyIG9vID0gaHMoKSwgZHMgPSB7IGV4cG9ydHM6IHt9IH0sIGRuID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBEcjtcbmZ1bmN0aW9uIGFvKCkge1xuICBpZiAoRHIpXG4gICAgcmV0dXJuIGRuO1xuICBEciA9IDE7XG4gIHZhciBuID0gcWU7XG4gIGZ1bmN0aW9uIGUoZiwgcCkge1xuICAgIHJldHVybiBmID09PSBwICYmIChmICE9PSAwIHx8IDEgLyBmID09PSAxIC8gcCkgfHwgZiAhPT0gZiAmJiBwICE9PSBwO1xuICB9XG4gIHZhciB0ID0gdHlwZW9mIE9iamVjdC5pcyA9PSBcImZ1bmN0aW9uXCIgPyBPYmplY3QuaXMgOiBlLCByID0gbi51c2VTdGF0ZSwgcyA9IG4udXNlRWZmZWN0LCBpID0gbi51c2VMYXlvdXRFZmZlY3QsIG8gPSBuLnVzZURlYnVnVmFsdWU7XG4gIGZ1bmN0aW9uIHUoZiwgcCkge1xuICAgIHZhciBtID0gcCgpLCBnID0gcih7IGluc3Q6IHsgdmFsdWU6IG0sIGdldFNuYXBzaG90OiBwIH0gfSksIGIgPSBnWzBdLmluc3QsIEUgPSBnWzFdO1xuICAgIHJldHVybiBpKGZ1bmN0aW9uKCkge1xuICAgICAgYi52YWx1ZSA9IG0sIGIuZ2V0U25hcHNob3QgPSBwLCBsKGIpICYmIEUoeyBpbnN0OiBiIH0pO1xuICAgIH0sIFtmLCBtLCBwXSksIHMoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbChiKSAmJiBFKHsgaW5zdDogYiB9KSwgZihmdW5jdGlvbigpIHtcbiAgICAgICAgbChiKSAmJiBFKHsgaW5zdDogYiB9KTtcbiAgICAgIH0pO1xuICAgIH0sIFtmXSksIG8obSksIG07XG4gIH1cbiAgZnVuY3Rpb24gbChmKSB7XG4gICAgdmFyIHAgPSBmLmdldFNuYXBzaG90O1xuICAgIGYgPSBmLnZhbHVlO1xuICAgIHRyeSB7XG4gICAgICB2YXIgbSA9IHAoKTtcbiAgICAgIHJldHVybiAhdChmLCBtKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYShmLCBwKSB7XG4gICAgcmV0dXJuIHAoKTtcbiAgfVxuICB2YXIgaCA9IHR5cGVvZiB3aW5kb3cgPiBcInVcIiB8fCB0eXBlb2Ygd2luZG93LmRvY3VtZW50ID4gXCJ1XCIgfHwgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ID4gXCJ1XCIgPyBhIDogdTtcbiAgcmV0dXJuIGRuLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gbi51c2VTeW5jRXh0ZXJuYWxTdG9yZSAhPT0gdm9pZCAwID8gbi51c2VTeW5jRXh0ZXJuYWxTdG9yZSA6IGgsIGRuO1xufVxudmFyIHBuID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiB1c2Utc3luYy1leHRlcm5hbC1zdG9yZS1zaGltLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBrcjtcbmZ1bmN0aW9uIHVvKCkge1xuICByZXR1cm4ga3IgfHwgKGtyID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGZ1bmN0aW9uKCkge1xuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPCBcInVcIiAmJiB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydCA9PSBcImZ1bmN0aW9uXCIgJiYgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdGFydChuZXcgRXJyb3IoKSk7XG4gICAgdmFyIG4gPSBxZSwgZSA9IG4uX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG4gICAgZnVuY3Rpb24gdChrKSB7XG4gICAgICB7XG4gICAgICAgIGZvciAodmFyIHkgPSBhcmd1bWVudHMubGVuZ3RoLCBNID0gbmV3IEFycmF5KHkgPiAxID8geSAtIDEgOiAwKSwgVCA9IDE7IFQgPCB5OyBUKyspXG4gICAgICAgICAgTVtUIC0gMV0gPSBhcmd1bWVudHNbVF07XG4gICAgICAgIHIoXCJlcnJvclwiLCBrLCBNKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcihrLCB5LCBNKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBUID0gZS5SZWFjdERlYnVnQ3VycmVudEZyYW1lLCBWID0gVC5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICAgIFYgIT09IFwiXCIgJiYgKHkgKz0gXCIlc1wiLCBNID0gTS5jb25jYXQoW1ZdKSk7XG4gICAgICAgIHZhciBEID0gTS5tYXAoZnVuY3Rpb24oaikge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcoaik7XG4gICAgICAgIH0pO1xuICAgICAgICBELnVuc2hpZnQoXCJXYXJuaW5nOiBcIiArIHkpLCBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2tdLCBjb25zb2xlLCBEKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcyhrLCB5KSB7XG4gICAgICByZXR1cm4gayA9PT0geSAmJiAoayAhPT0gMCB8fCAxIC8gayA9PT0gMSAvIHkpIHx8IGsgIT09IGsgJiYgeSAhPT0geTtcbiAgICB9XG4gICAgdmFyIGkgPSB0eXBlb2YgT2JqZWN0LmlzID09IFwiZnVuY3Rpb25cIiA/IE9iamVjdC5pcyA6IHMsIG8gPSBuLnVzZVN0YXRlLCB1ID0gbi51c2VFZmZlY3QsIGwgPSBuLnVzZUxheW91dEVmZmVjdCwgYSA9IG4udXNlRGVidWdWYWx1ZSwgaCA9ICExLCBmID0gITE7XG4gICAgZnVuY3Rpb24gcChrLCB5LCBNKSB7XG4gICAgICBoIHx8IG4uc3RhcnRUcmFuc2l0aW9uICE9PSB2b2lkIDAgJiYgKGggPSAhMCwgdChcIllvdSBhcmUgdXNpbmcgYW4gb3V0ZGF0ZWQsIHByZS1yZWxlYXNlIGFscGhhIG9mIFJlYWN0IDE4IHRoYXQgZG9lcyBub3Qgc3VwcG9ydCB1c2VTeW5jRXh0ZXJuYWxTdG9yZS4gVGhlIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlIHNoaW0gd2lsbCBub3Qgd29yayBjb3JyZWN0bHkuIFVwZ3JhZGUgdG8gYSBuZXdlciBwcmUtcmVsZWFzZS5cIikpO1xuICAgICAgdmFyIFQgPSB5KCk7XG4gICAgICBpZiAoIWYpIHtcbiAgICAgICAgdmFyIFYgPSB5KCk7XG4gICAgICAgIGkoVCwgVikgfHwgKHQoXCJUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcFwiKSwgZiA9ICEwKTtcbiAgICAgIH1cbiAgICAgIHZhciBEID0gbyh7XG4gICAgICAgIGluc3Q6IHtcbiAgICAgICAgICB2YWx1ZTogVCxcbiAgICAgICAgICBnZXRTbmFwc2hvdDogeVxuICAgICAgICB9XG4gICAgICB9KSwgaiA9IERbMF0uaW5zdCwgTCA9IERbMV07XG4gICAgICByZXR1cm4gbChmdW5jdGlvbigpIHtcbiAgICAgICAgai52YWx1ZSA9IFQsIGouZ2V0U25hcHNob3QgPSB5LCBtKGopICYmIEwoe1xuICAgICAgICAgIGluc3Q6IGpcbiAgICAgICAgfSk7XG4gICAgICB9LCBbaywgVCwgeV0pLCB1KGZ1bmN0aW9uKCkge1xuICAgICAgICBtKGopICYmIEwoe1xuICAgICAgICAgIGluc3Q6IGpcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBRID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbShqKSAmJiBMKHtcbiAgICAgICAgICAgIGluc3Q6IGpcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGsoUSk7XG4gICAgICB9LCBba10pLCBhKFQpLCBUO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtKGspIHtcbiAgICAgIHZhciB5ID0gay5nZXRTbmFwc2hvdCwgTSA9IGsudmFsdWU7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgVCA9IHkoKTtcbiAgICAgICAgcmV0dXJuICFpKE0sIFQpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZyhrLCB5LCBNKSB7XG4gICAgICByZXR1cm4geSgpO1xuICAgIH1cbiAgICB2YXIgYiA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50IDwgXCJ1XCIgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50IDwgXCJ1XCIsIEUgPSAhYiwgXyA9IEUgPyBnIDogcCwgUyA9IG4udXNlU3luY0V4dGVybmFsU3RvcmUgIT09IHZvaWQgMCA/IG4udXNlU3luY0V4dGVybmFsU3RvcmUgOiBfO1xuICAgIHBuLnVzZVN5bmNFeHRlcm5hbFN0b3JlID0gUywgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA8IFwidVwiICYmIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT0gXCJmdW5jdGlvblwiICYmIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG4gIH0oKSksIHBuO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gbi5leHBvcnRzID0gYW8oKSA6IG4uZXhwb3J0cyA9IHVvKCk7XG59KShkcyk7XG5jb25zdCBBZSA9ICgpID0+IHtcbn0sIG9lID0gQWUoKSwgdm4gPSBPYmplY3QsIEMgPSAobikgPT4gbiA9PT0gb2UsIE9lID0gKG4pID0+IHR5cGVvZiBuID09IFwiZnVuY3Rpb25cIiwgRGUgPSAobiwgZSkgPT4gKHtcbiAgLi4ubixcbiAgLi4uZVxufSksIGNvID0gKG4pID0+IE9lKG4udGhlbiksIFR0ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5sZXQgbG8gPSAwO1xuY29uc3QgY3QgPSAobikgPT4ge1xuICBjb25zdCBlID0gdHlwZW9mIG4sIHQgPSBuICYmIG4uY29uc3RydWN0b3IsIHIgPSB0ID09IERhdGU7XG4gIGxldCBzLCBpO1xuICBpZiAodm4obikgPT09IG4gJiYgIXIgJiYgdCAhPSBSZWdFeHApIHtcbiAgICBpZiAocyA9IFR0LmdldChuKSwgcylcbiAgICAgIHJldHVybiBzO1xuICAgIGlmIChzID0gKytsbyArIFwiflwiLCBUdC5zZXQobiwgcyksIHQgPT0gQXJyYXkpIHtcbiAgICAgIGZvciAocyA9IFwiQFwiLCBpID0gMDsgaSA8IG4ubGVuZ3RoOyBpKyspXG4gICAgICAgIHMgKz0gY3QobltpXSkgKyBcIixcIjtcbiAgICAgIFR0LnNldChuLCBzKTtcbiAgICB9XG4gICAgaWYgKHQgPT0gdm4pIHtcbiAgICAgIHMgPSBcIiNcIjtcbiAgICAgIGNvbnN0IG8gPSB2bi5rZXlzKG4pLnNvcnQoKTtcbiAgICAgIGZvciAoOyAhQyhpID0gby5wb3AoKSk7IClcbiAgICAgICAgQyhuW2ldKSB8fCAocyArPSBpICsgXCI6XCIgKyBjdChuW2ldKSArIFwiLFwiKTtcbiAgICAgIFR0LnNldChuLCBzKTtcbiAgICB9XG4gIH0gZWxzZVxuICAgIHMgPSByID8gbi50b0pTT04oKSA6IGUgPT0gXCJzeW1ib2xcIiA/IG4udG9TdHJpbmcoKSA6IGUgPT0gXCJzdHJpbmdcIiA/IEpTT04uc3RyaW5naWZ5KG4pIDogXCJcIiArIG47XG4gIHJldHVybiBzO1xufSwgVGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgeW4gPSB7fSwgT3QgPSB7fSwgam4gPSBcInVuZGVmaW5lZFwiLCAkdCA9IHR5cGVvZiB3aW5kb3cgIT0gam4sIFNuID0gdHlwZW9mIGRvY3VtZW50ICE9IGpuLCBmbyA9ICgpID0+ICR0ICYmIHR5cGVvZiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9IGpuLCBwcyA9IChuLCBlKSA9PiB7XG4gIGNvbnN0IHQgPSBUZS5nZXQobik7XG4gIHJldHVybiBbXG4gICAgKCkgPT4gIUMoZSkgJiYgbi5nZXQoZSkgfHwgeW4sXG4gICAgKHIpID0+IHtcbiAgICAgIGlmICghQyhlKSkge1xuICAgICAgICBjb25zdCBzID0gbi5nZXQoZSk7XG4gICAgICAgIGUgaW4gT3QgfHwgKE90W2VdID0gcyksIHRbNV0oZSwgRGUocywgciksIHMgfHwgeW4pO1xuICAgICAgfVxuICAgIH0sXG4gICAgdFs2XSxcbiAgICAoKSA9PiAhQyhlKSAmJiBlIGluIE90ID8gT3RbZV0gOiAhQyhlKSAmJiBuLmdldChlKSB8fCB5blxuICBdO1xufTtcbmxldCBUbiA9ICEwO1xuY29uc3QgaG8gPSAoKSA9PiBUbiwgW09uLCB4bl0gPSAkdCAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA/IFtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIuYmluZCh3aW5kb3cpLFxuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKHdpbmRvdylcbl0gOiBbXG4gIEFlLFxuICBBZVxuXSwgcG8gPSAoKSA9PiB7XG4gIGNvbnN0IG4gPSBTbiAmJiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGU7XG4gIHJldHVybiBDKG4pIHx8IG4gIT09IFwiaGlkZGVuXCI7XG59LCB2byA9IChuKSA9PiAoU24gJiYgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgbiksIE9uKFwiZm9jdXNcIiwgbiksICgpID0+IHtcbiAgU24gJiYgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgbiksIHhuKFwiZm9jdXNcIiwgbik7XG59KSwgeW8gPSAobikgPT4ge1xuICBjb25zdCBlID0gKCkgPT4ge1xuICAgIFRuID0gITAsIG4oKTtcbiAgfSwgdCA9ICgpID0+IHtcbiAgICBUbiA9ICExO1xuICB9O1xuICByZXR1cm4gT24oXCJvbmxpbmVcIiwgZSksIE9uKFwib2ZmbGluZVwiLCB0KSwgKCkgPT4ge1xuICAgIHhuKFwib25saW5lXCIsIGUpLCB4bihcIm9mZmxpbmVcIiwgdCk7XG4gIH07XG59LCBtbyA9IHtcbiAgaXNPbmxpbmU6IGhvLFxuICBpc1Zpc2libGU6IHBvXG59LCBnbyA9IHtcbiAgaW5pdEZvY3VzOiB2byxcbiAgaW5pdFJlY29ubmVjdDogeW9cbn0sIExyID0gIXFlLnVzZUlkLCBsdCA9ICEkdCB8fCBcIkRlbm9cIiBpbiB3aW5kb3csIF9vID0gKG4pID0+IGZvKCkgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG4pIDogc2V0VGltZW91dChuLCAxKSwgbW4gPSBsdCA/IEdlIDogZWksIGduID0gdHlwZW9mIG5hdmlnYXRvciA8IFwidVwiICYmIG5hdmlnYXRvci5jb25uZWN0aW9uLCBOciA9ICFsdCAmJiBnbiAmJiAoW1xuICBcInNsb3ctMmdcIixcbiAgXCIyZ1wiXG5dLmluY2x1ZGVzKGduLmVmZmVjdGl2ZVR5cGUpIHx8IGduLnNhdmVEYXRhKSwgJG4gPSAobikgPT4ge1xuICBpZiAoT2UobikpXG4gICAgdHJ5IHtcbiAgICAgIG4gPSBuKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBuID0gXCJcIjtcbiAgICB9XG4gIGNvbnN0IGUgPSBuO1xuICByZXR1cm4gbiA9IHR5cGVvZiBuID09IFwic3RyaW5nXCIgPyBuIDogKEFycmF5LmlzQXJyYXkobikgPyBuLmxlbmd0aCA6IG4pID8gY3QobikgOiBcIlwiLCBbXG4gICAgbixcbiAgICBlXG4gIF07XG59O1xubGV0IGJvID0gMDtcbmNvbnN0IENuID0gKCkgPT4gKytibywgdnMgPSAwLCB5cyA9IDEsIG1zID0gMiwgd28gPSAzO1xudmFyIHN0ID0ge1xuICBfX3Byb3RvX186IG51bGwsXG4gIEVSUk9SX1JFVkFMSURBVEVfRVZFTlQ6IHdvLFxuICBGT0NVU19FVkVOVDogdnMsXG4gIE1VVEFURV9FVkVOVDogbXMsXG4gIFJFQ09OTkVDVF9FVkVOVDogeXNcbn07XG5hc3luYyBmdW5jdGlvbiBncyguLi5uKSB7XG4gIGNvbnN0IFtlLCB0LCByLCBzXSA9IG4sIGkgPSBEZSh7XG4gICAgcG9wdWxhdGVDYWNoZTogITAsXG4gICAgdGhyb3dPbkVycm9yOiAhMFxuICB9LCB0eXBlb2YgcyA9PSBcImJvb2xlYW5cIiA/IHtcbiAgICByZXZhbGlkYXRlOiBzXG4gIH0gOiBzIHx8IHt9KTtcbiAgbGV0IG8gPSBpLnBvcHVsYXRlQ2FjaGU7XG4gIGNvbnN0IHUgPSBpLnJvbGxiYWNrT25FcnJvcjtcbiAgbGV0IGwgPSBpLm9wdGltaXN0aWNEYXRhO1xuICBjb25zdCBhID0gaS5yZXZhbGlkYXRlICE9PSAhMSwgaCA9IChtKSA9PiB0eXBlb2YgdSA9PSBcImZ1bmN0aW9uXCIgPyB1KG0pIDogdSAhPT0gITEsIGYgPSBpLnRocm93T25FcnJvcjtcbiAgaWYgKE9lKHQpKSB7XG4gICAgY29uc3QgbSA9IHQsIGcgPSBbXSwgYiA9IGUua2V5cygpO1xuICAgIGZvciAoY29uc3QgRSBvZiBiKVxuICAgICAgIS9eXFwkKGluZnxzdWIpXFwkLy50ZXN0KEUpICYmIG0oZS5nZXQoRSkuX2spICYmIGcucHVzaChFKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoZy5tYXAocCkpO1xuICB9XG4gIHJldHVybiBwKHQpO1xuICBhc3luYyBmdW5jdGlvbiBwKG0pIHtcbiAgICBjb25zdCBbZ10gPSAkbihtKTtcbiAgICBpZiAoIWcpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW2IsIEVdID0gcHMoZSwgZyksIFtfLCBTLCBrLCB5XSA9IFRlLmdldChlKSwgTSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IEYgPSBfW2ddO1xuICAgICAgcmV0dXJuIGEgJiYgKGRlbGV0ZSBrW2ddLCBkZWxldGUgeVtnXSwgRiAmJiBGWzBdKSA/IEZbMF0obXMpLnRoZW4oKCkgPT4gYigpLmRhdGEpIDogYigpLmRhdGE7XG4gICAgfTtcbiAgICBpZiAobi5sZW5ndGggPCAzKVxuICAgICAgcmV0dXJuIE0oKTtcbiAgICBsZXQgVCA9IHIsIFY7XG4gICAgY29uc3QgRCA9IENuKCk7XG4gICAgU1tnXSA9IFtcbiAgICAgIEQsXG4gICAgICAwXG4gICAgXTtcbiAgICBjb25zdCBqID0gIUMobCksIEwgPSBiKCksIFEgPSBMLmRhdGEsIG5lID0gTC5fYywgRyA9IEMobmUpID8gUSA6IG5lO1xuICAgIGlmIChqICYmIChsID0gT2UobCkgPyBsKEcsIFEpIDogbCwgRSh7XG4gICAgICBkYXRhOiBsLFxuICAgICAgX2M6IEdcbiAgICB9KSksIE9lKFQpKVxuICAgICAgdHJ5IHtcbiAgICAgICAgVCA9IFQoRyk7XG4gICAgICB9IGNhdGNoIChGKSB7XG4gICAgICAgIFYgPSBGO1xuICAgICAgfVxuICAgIGlmIChUICYmIGNvKFQpKVxuICAgICAgaWYgKFQgPSBhd2FpdCBULmNhdGNoKChGKSA9PiB7XG4gICAgICAgIFYgPSBGO1xuICAgICAgfSksIEQgIT09IFNbZ11bMF0pIHtcbiAgICAgICAgaWYgKFYpXG4gICAgICAgICAgdGhyb3cgVjtcbiAgICAgICAgcmV0dXJuIFQ7XG4gICAgICB9IGVsc2VcbiAgICAgICAgViAmJiBqICYmIGgoVikgJiYgKG8gPSAhMCwgRSh7XG4gICAgICAgICAgZGF0YTogRyxcbiAgICAgICAgICBfYzogb2VcbiAgICAgICAgfSkpO1xuICAgIGlmIChvICYmICFWKVxuICAgICAgaWYgKE9lKG8pKSB7XG4gICAgICAgIGNvbnN0IEYgPSBvKFQsIEcpO1xuICAgICAgICBFKHtcbiAgICAgICAgICBkYXRhOiBGLFxuICAgICAgICAgIGVycm9yOiBvZSxcbiAgICAgICAgICBfYzogb2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgRSh7XG4gICAgICAgICAgZGF0YTogVCxcbiAgICAgICAgICBlcnJvcjogb2UsXG4gICAgICAgICAgX2M6IG9lXG4gICAgICAgIH0pO1xuICAgIGlmIChTW2ddWzFdID0gQ24oKSwgUHJvbWlzZS5yZXNvbHZlKE0oKSkudGhlbigoKSA9PiB7XG4gICAgICBFKHtcbiAgICAgICAgX2M6IG9lXG4gICAgICB9KTtcbiAgICB9KSwgVikge1xuICAgICAgaWYgKGYpXG4gICAgICAgIHRocm93IFY7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBUO1xuICB9XG59XG5jb25zdCBQciA9IChuLCBlKSA9PiB7XG4gIGZvciAoY29uc3QgdCBpbiBuKVxuICAgIG5bdF1bMF0gJiYgblt0XVswXShlKTtcbn0sIEVvID0gKG4sIGUpID0+IHtcbiAgaWYgKCFUZS5oYXMobikpIHtcbiAgICBjb25zdCB0ID0gRGUoZ28sIGUpLCByID0ge30sIHMgPSBncy5iaW5kKG9lLCBuKTtcbiAgICBsZXQgaSA9IEFlO1xuICAgIGNvbnN0IG8gPSB7fSwgdSA9IChoLCBmKSA9PiB7XG4gICAgICBjb25zdCBwID0gb1toXSB8fCBbXTtcbiAgICAgIHJldHVybiBvW2hdID0gcCwgcC5wdXNoKGYpLCAoKSA9PiBwLnNwbGljZShwLmluZGV4T2YoZiksIDEpO1xuICAgIH0sIGwgPSAoaCwgZiwgcCkgPT4ge1xuICAgICAgbi5zZXQoaCwgZik7XG4gICAgICBjb25zdCBtID0gb1toXTtcbiAgICAgIGlmIChtKVxuICAgICAgICBmb3IgKGNvbnN0IGcgb2YgbSlcbiAgICAgICAgICBnKGYsIHApO1xuICAgIH0sIGEgPSAoKSA9PiB7XG4gICAgICBpZiAoIVRlLmhhcyhuKSAmJiAoVGUuc2V0KG4sIFtcbiAgICAgICAgcixcbiAgICAgICAge30sXG4gICAgICAgIHt9LFxuICAgICAgICB7fSxcbiAgICAgICAgcyxcbiAgICAgICAgbCxcbiAgICAgICAgdVxuICAgICAgXSksICFsdCkpIHtcbiAgICAgICAgY29uc3QgaCA9IHQuaW5pdEZvY3VzKHNldFRpbWVvdXQuYmluZChvZSwgUHIuYmluZChvZSwgciwgdnMpKSksIGYgPSB0LmluaXRSZWNvbm5lY3Qoc2V0VGltZW91dC5iaW5kKG9lLCBQci5iaW5kKG9lLCByLCB5cykpKTtcbiAgICAgICAgaSA9ICgpID0+IHtcbiAgICAgICAgICBoICYmIGgoKSwgZiAmJiBmKCksIFRlLmRlbGV0ZShuKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhKCksIFtcbiAgICAgIG4sXG4gICAgICBzLFxuICAgICAgYSxcbiAgICAgIGlcbiAgICBdO1xuICB9XG4gIHJldHVybiBbXG4gICAgbixcbiAgICBUZS5nZXQobilbNF1cbiAgXTtcbn0sIFJvID0gKG4sIGUsIHQsIHIsIHMpID0+IHtcbiAgY29uc3QgaSA9IHQuZXJyb3JSZXRyeUNvdW50LCBvID0gcy5yZXRyeUNvdW50LCB1ID0gfn4oKE1hdGgucmFuZG9tKCkgKyAwLjUpICogKDEgPDwgKG8gPCA4ID8gbyA6IDgpKSkgKiB0LmVycm9yUmV0cnlJbnRlcnZhbDtcbiAgIUMoaSkgJiYgbyA+IGkgfHwgc2V0VGltZW91dChyLCB1LCBzKTtcbn0sIFNvID0gKG4sIGUpID0+IGN0KG4pID09IGN0KGUpLCBbX3MsIFRvXSA9IEVvKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpLCBPbyA9IERlKFxuICB7XG4gICAgb25Mb2FkaW5nU2xvdzogQWUsXG4gICAgb25TdWNjZXNzOiBBZSxcbiAgICBvbkVycm9yOiBBZSxcbiAgICBvbkVycm9yUmV0cnk6IFJvLFxuICAgIG9uRGlzY2FyZGVkOiBBZSxcbiAgICByZXZhbGlkYXRlT25Gb2N1czogITAsXG4gICAgcmV2YWxpZGF0ZU9uUmVjb25uZWN0OiAhMCxcbiAgICByZXZhbGlkYXRlSWZTdGFsZTogITAsXG4gICAgc2hvdWxkUmV0cnlPbkVycm9yOiAhMCxcbiAgICBlcnJvclJldHJ5SW50ZXJ2YWw6IE5yID8gMWU0IDogNWUzLFxuICAgIGZvY3VzVGhyb3R0bGVJbnRlcnZhbDogNSAqIDFlMyxcbiAgICBkZWR1cGluZ0ludGVydmFsOiAyICogMWUzLFxuICAgIGxvYWRpbmdUaW1lb3V0OiBOciA/IDVlMyA6IDNlMyxcbiAgICBjb21wYXJlOiBTbyxcbiAgICBpc1BhdXNlZDogKCkgPT4gITEsXG4gICAgY2FjaGU6IF9zLFxuICAgIG11dGF0ZTogVG8sXG4gICAgZmFsbGJhY2s6IHt9XG4gIH0sXG4gIG1vXG4pLCB4byA9IChuLCBlKSA9PiB7XG4gIGNvbnN0IHQgPSBEZShuLCBlKTtcbiAgaWYgKGUpIHtcbiAgICBjb25zdCB7IHVzZTogciwgZmFsbGJhY2s6IHMgfSA9IG4sIHsgdXNlOiBpLCBmYWxsYmFjazogbyB9ID0gZTtcbiAgICByICYmIGkgJiYgKHQudXNlID0gci5jb25jYXQoaSkpLCBzICYmIG8gJiYgKHQuZmFsbGJhY2sgPSBEZShzLCBvKSk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59LCBDbyA9IHpyKHt9KSwgQW8gPSBcIiRpbmYkXCIsIGJzID0gJHQgJiYgd2luZG93Ll9fU1dSX0RFVlRPT0xTX1VTRV9fLCBEbyA9IGJzID8gd2luZG93Ll9fU1dSX0RFVlRPT0xTX1VTRV9fIDogW10sIGtvID0gKCkgPT4ge1xuICBicyAmJiAod2luZG93Ll9fU1dSX0RFVlRPT0xTX1JFQUNUX18gPSBxZSk7XG59LCBMbyA9IChuKSA9PiBPZShuWzFdKSA/IFtcbiAgblswXSxcbiAgblsxXSxcbiAgblsyXSB8fCB7fVxuXSA6IFtcbiAgblswXSxcbiAgbnVsbCxcbiAgKG5bMV0gPT09IG51bGwgPyBuWzJdIDogblsxXSkgfHwge31cbl0sIE5vID0gKCkgPT4gRGUoT28sIGVlKENvKSksIFBvID0gKG4pID0+IChlLCB0LCByKSA9PiBuKGUsIHQgJiYgKCguLi5pKSA9PiB7XG4gIGNvbnN0IFtvXSA9ICRuKGUpLCBbLCAsICwgdV0gPSBUZS5nZXQoX3MpO1xuICBpZiAoby5zdGFydHNXaXRoKEFvKSlcbiAgICByZXR1cm4gdCguLi5pKTtcbiAgY29uc3QgbCA9IHVbb107XG4gIHJldHVybiBDKGwpID8gdCguLi5pKSA6IChkZWxldGUgdVtvXSwgbCk7XG59KSwgciksIEJvID0gRG8uY29uY2F0KFBvKSwgRm8gPSAobikgPT4gZnVuY3Rpb24oLi4udCkge1xuICBjb25zdCByID0gTm8oKSwgW3MsIGksIG9dID0gTG8odCksIHUgPSB4byhyLCBvKTtcbiAgbGV0IGwgPSBuO1xuICBjb25zdCB7IHVzZTogYSB9ID0gdSwgaCA9IChhIHx8IFtdKS5jb25jYXQoQm8pO1xuICBmb3IgKGxldCBmID0gaC5sZW5ndGg7IGYtLTsgKVxuICAgIGwgPSBoW2ZdKGwpO1xuICByZXR1cm4gbChzLCBpIHx8IHUuZmV0Y2hlciB8fCBudWxsLCB1KTtcbn0sIFVvID0gKG4sIGUsIHQpID0+IHtcbiAgY29uc3QgciA9IGVbbl0gfHwgKGVbbl0gPSBbXSk7XG4gIHJldHVybiByLnB1c2godCksICgpID0+IHtcbiAgICBjb25zdCBzID0gci5pbmRleE9mKHQpO1xuICAgIHMgPj0gMCAmJiAocltzXSA9IHJbci5sZW5ndGggLSAxXSwgci5wb3AoKSk7XG4gIH07XG59O1xua28oKTtcbmNvbnN0IEJyID0gcWUudXNlIHx8ICgobikgPT4ge1xuICBpZiAobi5zdGF0dXMgPT09IFwicGVuZGluZ1wiKVxuICAgIHRocm93IG47XG4gIGlmIChuLnN0YXR1cyA9PT0gXCJmdWxmaWxsZWRcIilcbiAgICByZXR1cm4gbi52YWx1ZTtcbiAgdGhyb3cgbi5zdGF0dXMgPT09IFwicmVqZWN0ZWRcIiA/IG4ucmVhc29uIDogKG4uc3RhdHVzID0gXCJwZW5kaW5nXCIsIG4udGhlbigoZSkgPT4ge1xuICAgIG4uc3RhdHVzID0gXCJmdWxmaWxsZWRcIiwgbi52YWx1ZSA9IGU7XG4gIH0sIChlKSA9PiB7XG4gICAgbi5zdGF0dXMgPSBcInJlamVjdGVkXCIsIG4ucmVhc29uID0gZTtcbiAgfSksIG4pO1xufSksIF9uID0ge1xuICBkZWR1cGU6ICEwXG59LCBxbyA9IChuLCBlLCB0KSA9PiB7XG4gIGNvbnN0IHsgY2FjaGU6IHIsIGNvbXBhcmU6IHMsIHN1c3BlbnNlOiBpLCBmYWxsYmFja0RhdGE6IG8sIHJldmFsaWRhdGVPbk1vdW50OiB1LCByZXZhbGlkYXRlSWZTdGFsZTogbCwgcmVmcmVzaEludGVydmFsOiBhLCByZWZyZXNoV2hlbkhpZGRlbjogaCwgcmVmcmVzaFdoZW5PZmZsaW5lOiBmLCBrZWVwUHJldmlvdXNEYXRhOiBwIH0gPSB0LCBbbSwgZywgYiwgRV0gPSBUZS5nZXQociksIFtfLCBTXSA9ICRuKG4pLCBrID0gQmUoITEpLCB5ID0gQmUoITEpLCBNID0gQmUoXyksIFQgPSBCZShlKSwgViA9IEJlKHQpLCBEID0gKCkgPT4gVi5jdXJyZW50LCBqID0gKCkgPT4gRCgpLmlzVmlzaWJsZSgpICYmIEQoKS5pc09ubGluZSgpLCBbTCwgUSwgbmUsIEddID0gcHMociwgXyksIEYgPSBCZSh7fSkuY3VycmVudCwgTGUgPSBDKG8pID8gdC5mYWxsYmFja1tfXSA6IG8sIFFlID0gKE4sIFUpID0+IHtcbiAgICBmb3IgKGNvbnN0IFggaW4gRikge1xuICAgICAgY29uc3QgSSA9IFg7XG4gICAgICBpZiAoSSA9PT0gXCJkYXRhXCIpIHtcbiAgICAgICAgaWYgKCFzKE5bSV0sIFVbSV0pICYmICghQyhOW0ldKSB8fCAhcyhJZSwgVVtJXSkpKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH0gZWxzZSBpZiAoVVtJXSAhPT0gTltJXSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH0sIFplID0gS3IoKCkgPT4ge1xuICAgIGNvbnN0IE4gPSAoKCkgPT4gIV8gfHwgIWUgPyAhMSA6IEModSkgPyBEKCkuaXNQYXVzZWQoKSB8fCBpID8gITEgOiBDKGwpID8gITAgOiBsIDogdSkoKSwgVSA9IChKKSA9PiB7XG4gICAgICBjb25zdCBkZSA9IERlKEopO1xuICAgICAgcmV0dXJuIGRlbGV0ZSBkZS5faywgTiA/IHtcbiAgICAgICAgaXNWYWxpZGF0aW5nOiAhMCxcbiAgICAgICAgaXNMb2FkaW5nOiAhMCxcbiAgICAgICAgLi4uZGVcbiAgICAgIH0gOiBkZTtcbiAgICB9LCBYID0gTCgpLCBJID0gRygpLCByZSA9IFUoWCksIFJlID0gWCA9PT0gSSA/IHJlIDogVShJKTtcbiAgICBsZXQgSCA9IHJlO1xuICAgIHJldHVybiBbXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGNvbnN0IEogPSBVKEwoKSk7XG4gICAgICAgIHJldHVybiBRZShKLCBIKSA/IChILmRhdGEgPSBKLmRhdGEsIEguaXNMb2FkaW5nID0gSi5pc0xvYWRpbmcsIEguaXNWYWxpZGF0aW5nID0gSi5pc1ZhbGlkYXRpbmcsIEguZXJyb3IgPSBKLmVycm9yLCBIKSA6IChIID0gSiwgSik7XG4gICAgICB9LFxuICAgICAgKCkgPT4gUmVcbiAgICBdO1xuICB9LCBbXG4gICAgcixcbiAgICBfXG4gIF0pLCBiZSA9IGRzLmV4cG9ydHMudXNlU3luY0V4dGVybmFsU3RvcmUoJChcbiAgICAoTikgPT4gbmUoXywgKFUsIFgpID0+IHtcbiAgICAgIFFlKFgsIFUpIHx8IE4oKTtcbiAgICB9KSxcbiAgICBbXG4gICAgICByLFxuICAgICAgX1xuICAgIF1cbiAgKSwgWmVbMF0sIFplWzFdKSwgZXQgPSAhay5jdXJyZW50LCB5dCA9IG1bX10gJiYgbVtfXS5sZW5ndGggPiAwLCB3ZSA9IGJlLmRhdGEsIEVlID0gQyh3ZSkgPyBMZSA6IHdlLCBOZSA9IGJlLmVycm9yLCBtdCA9IEJlKEVlKSwgSWUgPSBwID8gQyh3ZSkgPyBtdC5jdXJyZW50IDogd2UgOiBFZSwgVmUgPSAoKCkgPT4geXQgJiYgIUMoTmUpID8gITEgOiBldCAmJiAhQyh1KSA/IHUgOiBEKCkuaXNQYXVzZWQoKSA/ICExIDogaSA/IEMoRWUpID8gITEgOiBsIDogQyhFZSkgfHwgbCkoKSwgamUgPSAhIShfICYmIGUgJiYgZXQgJiYgVmUpLCAkZSA9IEMoYmUuaXNWYWxpZGF0aW5nKSA/IGplIDogYmUuaXNWYWxpZGF0aW5nLCB0dCA9IEMoYmUuaXNMb2FkaW5nKSA/IGplIDogYmUuaXNMb2FkaW5nLCB2ZSA9ICQoXG4gICAgYXN5bmMgKE4pID0+IHtcbiAgICAgIGNvbnN0IFUgPSBULmN1cnJlbnQ7XG4gICAgICBpZiAoIV8gfHwgIVUgfHwgeS5jdXJyZW50IHx8IEQoKS5pc1BhdXNlZCgpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBsZXQgWCwgSSwgcmUgPSAhMDtcbiAgICAgIGNvbnN0IFJlID0gTiB8fCB7fSwgSCA9ICFiW19dIHx8ICFSZS5kZWR1cGUsIEogPSAoKSA9PiBMciA/ICF5LmN1cnJlbnQgJiYgXyA9PT0gTS5jdXJyZW50ICYmIGsuY3VycmVudCA6IF8gPT09IE0uY3VycmVudCwgZGUgPSB7XG4gICAgICAgIGlzVmFsaWRhdGluZzogITEsXG4gICAgICAgIGlzTG9hZGluZzogITFcbiAgICAgIH0sIF90ID0gKCkgPT4ge1xuICAgICAgICBRKGRlKTtcbiAgICAgIH0sIE1lID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBpZSA9IGJbX107XG4gICAgICAgIGllICYmIGllWzFdID09PSBJICYmIGRlbGV0ZSBiW19dO1xuICAgICAgfSwgYnQgPSB7XG4gICAgICAgIGlzVmFsaWRhdGluZzogITBcbiAgICAgIH07XG4gICAgICBDKEwoKS5kYXRhKSAmJiAoYnQuaXNMb2FkaW5nID0gITApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKEggJiYgKFEoYnQpLCB0LmxvYWRpbmdUaW1lb3V0ICYmIEMoTCgpLmRhdGEpICYmIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHJlICYmIEooKSAmJiBEKCkub25Mb2FkaW5nU2xvdyhfLCB0KTtcbiAgICAgICAgfSwgdC5sb2FkaW5nVGltZW91dCksIGJbX10gPSBbXG4gICAgICAgICAgVShTKSxcbiAgICAgICAgICBDbigpXG4gICAgICAgIF0pLCBbWCwgSV0gPSBiW19dLCBYID0gYXdhaXQgWCwgSCAmJiBzZXRUaW1lb3V0KE1lLCB0LmRlZHVwaW5nSW50ZXJ2YWwpLCAhYltfXSB8fCBiW19dWzFdICE9PSBJKVxuICAgICAgICAgIHJldHVybiBIICYmIEooKSAmJiBEKCkub25EaXNjYXJkZWQoXyksICExO1xuICAgICAgICBkZS5lcnJvciA9IG9lO1xuICAgICAgICBjb25zdCBpZSA9IGdbX107XG4gICAgICAgIGlmICghQyhpZSkgJiYgKEkgPD0gaWVbMF0gfHwgSSA8PSBpZVsxXSB8fCBpZVsxXSA9PT0gMCkpXG4gICAgICAgICAgcmV0dXJuIF90KCksIEggJiYgSigpICYmIEQoKS5vbkRpc2NhcmRlZChfKSwgITE7XG4gICAgICAgIGNvbnN0IGNlID0gTCgpLmRhdGE7XG4gICAgICAgIGRlLmRhdGEgPSBzKGNlLCBYKSA/IGNlIDogWCwgSCAmJiBKKCkgJiYgRCgpLm9uU3VjY2VzcyhYLCBfLCB0KTtcbiAgICAgIH0gY2F0Y2ggKGllKSB7XG4gICAgICAgIE1lKCk7XG4gICAgICAgIGNvbnN0IGNlID0gRCgpLCB7IHNob3VsZFJldHJ5T25FcnJvcjogV2UgfSA9IGNlO1xuICAgICAgICBjZS5pc1BhdXNlZCgpIHx8IChkZS5lcnJvciA9IGllLCBIICYmIEooKSAmJiAoY2Uub25FcnJvcihpZSwgXywgY2UpLCAoV2UgPT09ICEwIHx8IE9lKFdlKSAmJiBXZShpZSkpICYmIGooKSAmJiBjZS5vbkVycm9yUmV0cnkoaWUsIF8sIGNlLCAoUGUpID0+IHtcbiAgICAgICAgICBjb25zdCBudCA9IG1bX107XG4gICAgICAgICAgbnQgJiYgbnRbMF0gJiYgbnRbMF0oc3QuRVJST1JfUkVWQUxJREFURV9FVkVOVCwgUGUpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgcmV0cnlDb3VudDogKFJlLnJldHJ5Q291bnQgfHwgMCkgKyAxLFxuICAgICAgICAgIGRlZHVwZTogITBcbiAgICAgICAgfSkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZSA9ICExLCBfdCgpLCAhMDtcbiAgICB9LFxuICAgIFtcbiAgICAgIF8sXG4gICAgICByXG4gICAgXVxuICApLCBndCA9ICQoXG4gICAgKC4uLk4pID0+IGdzKHIsIE0uY3VycmVudCwgLi4uTiksXG4gICAgW11cbiAgKTtcbiAgaWYgKG1uKCgpID0+IHtcbiAgICBULmN1cnJlbnQgPSBlLCBWLmN1cnJlbnQgPSB0LCBDKHdlKSB8fCAobXQuY3VycmVudCA9IHdlKTtcbiAgfSksIG1uKCgpID0+IHtcbiAgICBpZiAoIV8pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgTiA9IHZlLmJpbmQob2UsIF9uKTtcbiAgICBsZXQgVSA9IDA7XG4gICAgY29uc3QgSSA9IFVvKF8sIG0sIChyZSwgUmUgPSB7fSkgPT4ge1xuICAgICAgaWYgKHJlID09IHN0LkZPQ1VTX0VWRU5UKSB7XG4gICAgICAgIGNvbnN0IEggPSBEYXRlLm5vdygpO1xuICAgICAgICBEKCkucmV2YWxpZGF0ZU9uRm9jdXMgJiYgSCA+IFUgJiYgaigpICYmIChVID0gSCArIEQoKS5mb2N1c1Rocm90dGxlSW50ZXJ2YWwsIE4oKSk7XG4gICAgICB9IGVsc2UgaWYgKHJlID09IHN0LlJFQ09OTkVDVF9FVkVOVClcbiAgICAgICAgRCgpLnJldmFsaWRhdGVPblJlY29ubmVjdCAmJiBqKCkgJiYgTigpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChyZSA9PSBzdC5NVVRBVEVfRVZFTlQpXG4gICAgICAgICAgcmV0dXJuIHZlKCk7XG4gICAgICAgIGlmIChyZSA9PSBzdC5FUlJPUl9SRVZBTElEQVRFX0VWRU5UKVxuICAgICAgICAgIHJldHVybiB2ZShSZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHkuY3VycmVudCA9ICExLCBNLmN1cnJlbnQgPSBfLCBrLmN1cnJlbnQgPSAhMCwgUSh7XG4gICAgICBfazogU1xuICAgIH0pLCBWZSAmJiAoQyhFZSkgfHwgbHQgPyBOKCkgOiBfbyhOKSksICgpID0+IHtcbiAgICAgIHkuY3VycmVudCA9ICEwLCBJKCk7XG4gICAgfTtcbiAgfSwgW1xuICAgIF9cbiAgXSksIG1uKCgpID0+IHtcbiAgICBsZXQgTjtcbiAgICBmdW5jdGlvbiBVKCkge1xuICAgICAgY29uc3QgSSA9IE9lKGEpID8gYShMKCkuZGF0YSkgOiBhO1xuICAgICAgSSAmJiBOICE9PSAtMSAmJiAoTiA9IHNldFRpbWVvdXQoWCwgSSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBYKCkge1xuICAgICAgIUwoKS5lcnJvciAmJiAoaCB8fCBEKCkuaXNWaXNpYmxlKCkpICYmIChmIHx8IEQoKS5pc09ubGluZSgpKSA/IHZlKF9uKS50aGVuKFUpIDogVSgpO1xuICAgIH1cbiAgICByZXR1cm4gVSgpLCAoKSA9PiB7XG4gICAgICBOICYmIChjbGVhclRpbWVvdXQoTiksIE4gPSAtMSk7XG4gICAgfTtcbiAgfSwgW1xuICAgIGEsXG4gICAgaCxcbiAgICBmLFxuICAgIF9cbiAgXSksIHRpKEllKSwgaSAmJiBDKEVlKSAmJiBfKSB7XG4gICAgaWYgKCFMciAmJiBsdClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhbGxiYWNrIGRhdGEgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyBzdXNwZW5zZSBpbiBTU1IuXCIpO1xuICAgIFQuY3VycmVudCA9IGUsIFYuY3VycmVudCA9IHQsIHkuY3VycmVudCA9ICExO1xuICAgIGNvbnN0IE4gPSBFW19dO1xuICAgIGlmICghQyhOKSkge1xuICAgICAgY29uc3QgVSA9IGd0KE4pO1xuICAgICAgQnIoVSk7XG4gICAgfVxuICAgIGlmIChDKE5lKSkge1xuICAgICAgY29uc3QgVSA9IHZlKF9uKTtcbiAgICAgIEMoSWUpIHx8IChVLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIsIFUudmFsdWUgPSAhMCksIEJyKFUpO1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgTmU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtdXRhdGU6IGd0LFxuICAgIGdldCBkYXRhKCkge1xuICAgICAgcmV0dXJuIEYuZGF0YSA9ICEwLCBJZTtcbiAgICB9LFxuICAgIGdldCBlcnJvcigpIHtcbiAgICAgIHJldHVybiBGLmVycm9yID0gITAsIE5lO1xuICAgIH0sXG4gICAgZ2V0IGlzVmFsaWRhdGluZygpIHtcbiAgICAgIHJldHVybiBGLmlzVmFsaWRhdGluZyA9ICEwLCAkZTtcbiAgICB9LFxuICAgIGdldCBpc0xvYWRpbmcoKSB7XG4gICAgICByZXR1cm4gRi5pc0xvYWRpbmcgPSAhMCwgdHQ7XG4gICAgfVxuICB9O1xufSwgdnQgPSBGbyhxbyksIGdlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG5nZS5vcGVuID0gXCIwXCI7XG5nZS5jbG9zZSA9IFwiMVwiO1xuZ2UucGluZyA9IFwiMlwiO1xuZ2UucG9uZyA9IFwiM1wiO1xuZ2UubWVzc2FnZSA9IFwiNFwiO1xuZ2UudXBncmFkZSA9IFwiNVwiO1xuZ2Uubm9vcCA9IFwiNlwiO1xuY29uc3QgTnQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbk9iamVjdC5rZXlzKGdlKS5mb3JFYWNoKChuKSA9PiB7XG4gIE50W2dlW25dXSA9IG47XG59KTtcbmNvbnN0IEFuID0geyB0eXBlOiBcImVycm9yXCIsIGRhdGE6IFwicGFyc2VyIGVycm9yXCIgfSwgd3MgPSB0eXBlb2YgQmxvYiA9PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIEJsb2IgPCBcInVcIiAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoQmxvYikgPT09IFwiW29iamVjdCBCbG9iQ29uc3RydWN0b3JdXCIsIEVzID0gdHlwZW9mIEFycmF5QnVmZmVyID09IFwiZnVuY3Rpb25cIiwgUnMgPSAobikgPT4gdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PSBcImZ1bmN0aW9uXCIgPyBBcnJheUJ1ZmZlci5pc1ZpZXcobikgOiBuICYmIG4uYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIsIE1uID0gKHsgdHlwZTogbiwgZGF0YTogZSB9LCB0LCByKSA9PiB3cyAmJiBlIGluc3RhbmNlb2YgQmxvYiA/IHQgPyByKGUpIDogRnIoZSwgcikgOiBFcyAmJiAoZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IFJzKGUpKSA/IHQgPyByKGUpIDogRnIobmV3IEJsb2IoW2VdKSwgcikgOiByKGdlW25dICsgKGUgfHwgXCJcIikpLCBGciA9IChuLCBlKSA9PiB7XG4gIGNvbnN0IHQgPSBuZXcgRmlsZVJlYWRlcigpO1xuICByZXR1cm4gdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCByID0gdC5yZXN1bHQuc3BsaXQoXCIsXCIpWzFdO1xuICAgIGUoXCJiXCIgKyAociB8fCBcIlwiKSk7XG4gIH0sIHQucmVhZEFzRGF0YVVSTChuKTtcbn07XG5mdW5jdGlvbiBVcihuKSB7XG4gIHJldHVybiBuIGluc3RhbmNlb2YgVWludDhBcnJheSA/IG4gOiBuIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgVWludDhBcnJheShuKSA6IG5ldyBVaW50OEFycmF5KG4uYnVmZmVyLCBuLmJ5dGVPZmZzZXQsIG4uYnl0ZUxlbmd0aCk7XG59XG5sZXQgYm47XG5mdW5jdGlvbiBJbyhuLCBlKSB7XG4gIGlmICh3cyAmJiBuLmRhdGEgaW5zdGFuY2VvZiBCbG9iKVxuICAgIHJldHVybiBuLmRhdGEuYXJyYXlCdWZmZXIoKS50aGVuKFVyKS50aGVuKGUpO1xuICBpZiAoRXMgJiYgKG4uZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IFJzKG4uZGF0YSkpKVxuICAgIHJldHVybiBlKFVyKG4uZGF0YSkpO1xuICBNbihuLCAhMSwgKHQpID0+IHtcbiAgICBibiB8fCAoYm4gPSBuZXcgVGV4dEVuY29kZXIoKSksIGUoYm4uZW5jb2RlKHQpKTtcbiAgfSk7XG59XG5jb25zdCBxciA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLCB1dCA9IHR5cGVvZiBVaW50OEFycmF5ID4gXCJ1XCIgPyBbXSA6IG5ldyBVaW50OEFycmF5KDI1Nik7XG5mb3IgKGxldCBuID0gMDsgbiA8IHFyLmxlbmd0aDsgbisrKVxuICB1dFtxci5jaGFyQ29kZUF0KG4pXSA9IG47XG5jb25zdCBWbyA9IChuKSA9PiB7XG4gIGxldCBlID0gbi5sZW5ndGggKiAwLjc1LCB0ID0gbi5sZW5ndGgsIHIsIHMgPSAwLCBpLCBvLCB1LCBsO1xuICBuW24ubGVuZ3RoIC0gMV0gPT09IFwiPVwiICYmIChlLS0sIG5bbi5sZW5ndGggLSAyXSA9PT0gXCI9XCIgJiYgZS0tKTtcbiAgY29uc3QgYSA9IG5ldyBBcnJheUJ1ZmZlcihlKSwgaCA9IG5ldyBVaW50OEFycmF5KGEpO1xuICBmb3IgKHIgPSAwOyByIDwgdDsgciArPSA0KVxuICAgIGkgPSB1dFtuLmNoYXJDb2RlQXQocildLCBvID0gdXRbbi5jaGFyQ29kZUF0KHIgKyAxKV0sIHUgPSB1dFtuLmNoYXJDb2RlQXQociArIDIpXSwgbCA9IHV0W24uY2hhckNvZGVBdChyICsgMyldLCBoW3MrK10gPSBpIDw8IDIgfCBvID4+IDQsIGhbcysrXSA9IChvICYgMTUpIDw8IDQgfCB1ID4+IDIsIGhbcysrXSA9ICh1ICYgMykgPDwgNiB8IGwgJiA2MztcbiAgcmV0dXJuIGE7XG59LCBqbyA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PSBcImZ1bmN0aW9uXCIsIFduID0gKG4sIGUpID0+IHtcbiAgaWYgKHR5cGVvZiBuICE9IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibWVzc2FnZVwiLFxuICAgICAgZGF0YTogU3MobiwgZSlcbiAgICB9O1xuICBjb25zdCB0ID0gbi5jaGFyQXQoMCk7XG4gIHJldHVybiB0ID09PSBcImJcIiA/IHtcbiAgICB0eXBlOiBcIm1lc3NhZ2VcIixcbiAgICBkYXRhOiAkbyhuLnN1YnN0cmluZygxKSwgZSlcbiAgfSA6IE50W3RdID8gbi5sZW5ndGggPiAxID8ge1xuICAgIHR5cGU6IE50W3RdLFxuICAgIGRhdGE6IG4uc3Vic3RyaW5nKDEpXG4gIH0gOiB7XG4gICAgdHlwZTogTnRbdF1cbiAgfSA6IEFuO1xufSwgJG8gPSAobiwgZSkgPT4ge1xuICBpZiAoam8pIHtcbiAgICBjb25zdCB0ID0gVm8obik7XG4gICAgcmV0dXJuIFNzKHQsIGUpO1xuICB9IGVsc2VcbiAgICByZXR1cm4geyBiYXNlNjQ6ICEwLCBkYXRhOiBuIH07XG59LCBTcyA9IChuLCBlKSA9PiB7XG4gIHN3aXRjaCAoZSkge1xuICAgIGNhc2UgXCJibG9iXCI6XG4gICAgICByZXR1cm4gbiBpbnN0YW5jZW9mIEJsb2IgPyBuIDogbmV3IEJsb2IoW25dKTtcbiAgICBjYXNlIFwiYXJyYXlidWZmZXJcIjpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG4gaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IG4gOiBuLmJ1ZmZlcjtcbiAgfVxufSwgVHMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMwKSwgTW8gPSAobiwgZSkgPT4ge1xuICBjb25zdCB0ID0gbi5sZW5ndGgsIHIgPSBuZXcgQXJyYXkodCk7XG4gIGxldCBzID0gMDtcbiAgbi5mb3JFYWNoKChpLCBvKSA9PiB7XG4gICAgTW4oaSwgITEsICh1KSA9PiB7XG4gICAgICByW29dID0gdSwgKytzID09PSB0ICYmIGUoci5qb2luKFRzKSk7XG4gICAgfSk7XG4gIH0pO1xufSwgV28gPSAobiwgZSkgPT4ge1xuICBjb25zdCB0ID0gbi5zcGxpdChUcyksIHIgPSBbXTtcbiAgZm9yIChsZXQgcyA9IDA7IHMgPCB0Lmxlbmd0aDsgcysrKSB7XG4gICAgY29uc3QgaSA9IFduKHRbc10sIGUpO1xuICAgIGlmIChyLnB1c2goaSksIGkudHlwZSA9PT0gXCJlcnJvclwiKVxuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHI7XG59O1xuZnVuY3Rpb24gSG8oKSB7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm0obiwgZSkge1xuICAgICAgSW8obiwgKHQpID0+IHtcbiAgICAgICAgY29uc3QgciA9IHQubGVuZ3RoO1xuICAgICAgICBsZXQgcztcbiAgICAgICAgaWYgKHIgPCAxMjYpXG4gICAgICAgICAgcyA9IG5ldyBVaW50OEFycmF5KDEpLCBuZXcgRGF0YVZpZXcocy5idWZmZXIpLnNldFVpbnQ4KDAsIHIpO1xuICAgICAgICBlbHNlIGlmIChyIDwgNjU1MzYpIHtcbiAgICAgICAgICBzID0gbmV3IFVpbnQ4QXJyYXkoMyk7XG4gICAgICAgICAgY29uc3QgaSA9IG5ldyBEYXRhVmlldyhzLmJ1ZmZlcik7XG4gICAgICAgICAgaS5zZXRVaW50OCgwLCAxMjYpLCBpLnNldFVpbnQxNigxLCByKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzID0gbmV3IFVpbnQ4QXJyYXkoOSk7XG4gICAgICAgICAgY29uc3QgaSA9IG5ldyBEYXRhVmlldyhzLmJ1ZmZlcik7XG4gICAgICAgICAgaS5zZXRVaW50OCgwLCAxMjcpLCBpLnNldEJpZ1VpbnQ2NCgxLCBCaWdJbnQocikpO1xuICAgICAgICB9XG4gICAgICAgIG4uZGF0YSAmJiB0eXBlb2Ygbi5kYXRhICE9IFwic3RyaW5nXCIgJiYgKHNbMF0gfD0gMTI4KSwgZS5lbnF1ZXVlKHMpLCBlLmVucXVldWUodCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxubGV0IHduO1xuZnVuY3Rpb24geHQobikge1xuICByZXR1cm4gbi5yZWR1Y2UoKGUsIHQpID0+IGUgKyB0Lmxlbmd0aCwgMCk7XG59XG5mdW5jdGlvbiBDdChuLCBlKSB7XG4gIGlmIChuWzBdLmxlbmd0aCA9PT0gZSlcbiAgICByZXR1cm4gbi5zaGlmdCgpO1xuICBjb25zdCB0ID0gbmV3IFVpbnQ4QXJyYXkoZSk7XG4gIGxldCByID0gMDtcbiAgZm9yIChsZXQgcyA9IDA7IHMgPCBlOyBzKyspXG4gICAgdFtzXSA9IG5bMF1bcisrXSwgciA9PT0gblswXS5sZW5ndGggJiYgKG4uc2hpZnQoKSwgciA9IDApO1xuICByZXR1cm4gbi5sZW5ndGggJiYgciA8IG5bMF0ubGVuZ3RoICYmIChuWzBdID0gblswXS5zbGljZShyKSksIHQ7XG59XG5mdW5jdGlvbiBKbyhuLCBlKSB7XG4gIHduIHx8ICh3biA9IG5ldyBUZXh0RGVjb2RlcigpKTtcbiAgY29uc3QgdCA9IFtdO1xuICBsZXQgciA9IDAsIHMgPSAtMSwgaSA9ICExO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtKG8sIHUpIHtcbiAgICAgIGZvciAodC5wdXNoKG8pOyA7ICkge1xuICAgICAgICBpZiAociA9PT0gMCkge1xuICAgICAgICAgIGlmICh4dCh0KSA8IDEpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjb25zdCBsID0gQ3QodCwgMSk7XG4gICAgICAgICAgaSA9IChsWzBdICYgMTI4KSA9PT0gMTI4LCBzID0gbFswXSAmIDEyNywgcyA8IDEyNiA/IHIgPSAzIDogcyA9PT0gMTI2ID8gciA9IDEgOiByID0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChyID09PSAxKSB7XG4gICAgICAgICAgaWYgKHh0KHQpIDwgMilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNvbnN0IGwgPSBDdCh0LCAyKTtcbiAgICAgICAgICBzID0gbmV3IERhdGFWaWV3KGwuYnVmZmVyLCBsLmJ5dGVPZmZzZXQsIGwubGVuZ3RoKS5nZXRVaW50MTYoMCksIHIgPSAzO1xuICAgICAgICB9IGVsc2UgaWYgKHIgPT09IDIpIHtcbiAgICAgICAgICBpZiAoeHQodCkgPCA4KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY29uc3QgbCA9IEN0KHQsIDgpLCBhID0gbmV3IERhdGFWaWV3KGwuYnVmZmVyLCBsLmJ5dGVPZmZzZXQsIGwubGVuZ3RoKSwgaCA9IGEuZ2V0VWludDMyKDApO1xuICAgICAgICAgIGlmIChoID4gTWF0aC5wb3coMiwgNTMgLSAzMikgLSAxKSB7XG4gICAgICAgICAgICB1LmVucXVldWUoQW4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHMgPSBoICogTWF0aC5wb3coMiwgMzIpICsgYS5nZXRVaW50MzIoNCksIHIgPSAzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh4dCh0KSA8IHMpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjb25zdCBsID0gQ3QodCwgcyk7XG4gICAgICAgICAgdS5lbnF1ZXVlKFduKGkgPyBsIDogd24uZGVjb2RlKGwpLCBlKSksIHIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzID09PSAwIHx8IHMgPiBuKSB7XG4gICAgICAgICAgdS5lbnF1ZXVlKEFuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5jb25zdCBPcyA9IDQ7XG5mdW5jdGlvbiBLKG4pIHtcbiAgaWYgKG4pXG4gICAgcmV0dXJuIFlvKG4pO1xufVxuZnVuY3Rpb24gWW8obikge1xuICBmb3IgKHZhciBlIGluIEsucHJvdG90eXBlKVxuICAgIG5bZV0gPSBLLnByb3RvdHlwZVtlXTtcbiAgcmV0dXJuIG47XG59XG5LLnByb3RvdHlwZS5vbiA9IEsucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihuLCBlKSB7XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge30sICh0aGlzLl9jYWxsYmFja3NbXCIkXCIgKyBuXSA9IHRoaXMuX2NhbGxiYWNrc1tcIiRcIiArIG5dIHx8IFtdKS5wdXNoKGUpLCB0aGlzO1xufTtcbksucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihuLCBlKSB7XG4gIGZ1bmN0aW9uIHQoKSB7XG4gICAgdGhpcy5vZmYobiwgdCksIGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuICByZXR1cm4gdC5mbiA9IGUsIHRoaXMub24obiwgdCksIHRoaXM7XG59O1xuSy5wcm90b3R5cGUub2ZmID0gSy5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBLLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBLLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24obiwgZSkge1xuICBpZiAodGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9LCBhcmd1bWVudHMubGVuZ3RoID09IDApXG4gICAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrcyA9IHt9LCB0aGlzO1xuICB2YXIgdCA9IHRoaXMuX2NhbGxiYWNrc1tcIiRcIiArIG5dO1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIHRoaXM7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpXG4gICAgcmV0dXJuIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbXCIkXCIgKyBuXSwgdGhpcztcbiAgZm9yICh2YXIgciwgcyA9IDA7IHMgPCB0Lmxlbmd0aDsgcysrKVxuICAgIGlmIChyID0gdFtzXSwgciA9PT0gZSB8fCByLmZuID09PSBlKSB7XG4gICAgICB0LnNwbGljZShzLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIHQubGVuZ3RoID09PSAwICYmIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbXCIkXCIgKyBuXSwgdGhpcztcbn07XG5LLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24obikge1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIGZvciAodmFyIGUgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpLCB0ID0gdGhpcy5fY2FsbGJhY2tzW1wiJFwiICsgbl0sIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKVxuICAgIGVbciAtIDFdID0gYXJndW1lbnRzW3JdO1xuICBpZiAodCkge1xuICAgIHQgPSB0LnNsaWNlKDApO1xuICAgIGZvciAodmFyIHIgPSAwLCBzID0gdC5sZW5ndGg7IHIgPCBzOyArK3IpXG4gICAgICB0W3JdLmFwcGx5KHRoaXMsIGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcbksucHJvdG90eXBlLmVtaXRSZXNlcnZlZCA9IEsucHJvdG90eXBlLmVtaXQ7XG5LLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge30sIHRoaXMuX2NhbGxiYWNrc1tcIiRcIiArIG5dIHx8IFtdO1xufTtcbksucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgcmV0dXJuICEhdGhpcy5saXN0ZW5lcnMobikubGVuZ3RoO1xufTtcbmNvbnN0IGhlID0gKCgpID0+IHR5cGVvZiBzZWxmIDwgXCJ1XCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyA8IFwidVwiID8gd2luZG93IDogRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpKSgpO1xuZnVuY3Rpb24geHMobiwgLi4uZSkge1xuICByZXR1cm4gZS5yZWR1Y2UoKHQsIHIpID0+IChuLmhhc093blByb3BlcnR5KHIpICYmICh0W3JdID0gbltyXSksIHQpLCB7fSk7XG59XG5jb25zdCB6byA9IGhlLnNldFRpbWVvdXQsIEtvID0gaGUuY2xlYXJUaW1lb3V0O1xuZnVuY3Rpb24gTXQobiwgZSkge1xuICBlLnVzZU5hdGl2ZVRpbWVycyA/IChuLnNldFRpbWVvdXRGbiA9IHpvLmJpbmQoaGUpLCBuLmNsZWFyVGltZW91dEZuID0gS28uYmluZChoZSkpIDogKG4uc2V0VGltZW91dEZuID0gaGUuc2V0VGltZW91dC5iaW5kKGhlKSwgbi5jbGVhclRpbWVvdXRGbiA9IGhlLmNsZWFyVGltZW91dC5iaW5kKGhlKSk7XG59XG5jb25zdCBHbyA9IDEuMzM7XG5mdW5jdGlvbiBYbyhuKSB7XG4gIHJldHVybiB0eXBlb2YgbiA9PSBcInN0cmluZ1wiID8gUW8obikgOiBNYXRoLmNlaWwoKG4uYnl0ZUxlbmd0aCB8fCBuLnNpemUpICogR28pO1xufVxuZnVuY3Rpb24gUW8obikge1xuICBsZXQgZSA9IDAsIHQgPSAwO1xuICBmb3IgKGxldCByID0gMCwgcyA9IG4ubGVuZ3RoOyByIDwgczsgcisrKVxuICAgIGUgPSBuLmNoYXJDb2RlQXQociksIGUgPCAxMjggPyB0ICs9IDEgOiBlIDwgMjA0OCA/IHQgKz0gMiA6IGUgPCA1NTI5NiB8fCBlID49IDU3MzQ0ID8gdCArPSAzIDogKHIrKywgdCArPSA0KTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBabyhuKSB7XG4gIGxldCBlID0gXCJcIjtcbiAgZm9yIChsZXQgdCBpbiBuKVxuICAgIG4uaGFzT3duUHJvcGVydHkodCkgJiYgKGUubGVuZ3RoICYmIChlICs9IFwiJlwiKSwgZSArPSBlbmNvZGVVUklDb21wb25lbnQodCkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChuW3RdKSk7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gZWEobikge1xuICBsZXQgZSA9IHt9LCB0ID0gbi5zcGxpdChcIiZcIik7XG4gIGZvciAobGV0IHIgPSAwLCBzID0gdC5sZW5ndGg7IHIgPCBzOyByKyspIHtcbiAgICBsZXQgaSA9IHRbcl0uc3BsaXQoXCI9XCIpO1xuICAgIGVbZGVjb2RlVVJJQ29tcG9uZW50KGlbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChpWzFdKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmNsYXNzIHRhIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihlLCB0LCByKSB7XG4gICAgc3VwZXIoZSksIHRoaXMuZGVzY3JpcHRpb24gPSB0LCB0aGlzLmNvbnRleHQgPSByLCB0aGlzLnR5cGUgPSBcIlRyYW5zcG9ydEVycm9yXCI7XG4gIH1cbn1cbmNsYXNzIEhuIGV4dGVuZHMgSyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpLCB0aGlzLndyaXRhYmxlID0gITEsIE10KHRoaXMsIGUpLCB0aGlzLm9wdHMgPSBlLCB0aGlzLnF1ZXJ5ID0gZS5xdWVyeSwgdGhpcy5zb2NrZXQgPSBlLnNvY2tldDtcbiAgfVxuICBvbkVycm9yKGUsIHQsIHIpIHtcbiAgICByZXR1cm4gc3VwZXIuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgbmV3IHRhKGUsIHQsIHIpKSwgdGhpcztcbiAgfVxuICBvcGVuKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWR5U3RhdGUgPSBcIm9wZW5pbmdcIiwgdGhpcy5kb09wZW4oKSwgdGhpcztcbiAgfVxuICBjbG9zZSgpIHtcbiAgICByZXR1cm4gKHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJvcGVuaW5nXCIgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBcIm9wZW5cIikgJiYgKHRoaXMuZG9DbG9zZSgpLCB0aGlzLm9uQ2xvc2UoKSksIHRoaXM7XG4gIH1cbiAgc2VuZChlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID09PSBcIm9wZW5cIiAmJiB0aGlzLndyaXRlKGUpO1xuICB9XG4gIG9uT3BlbigpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBcIm9wZW5cIiwgdGhpcy53cml0YWJsZSA9ICEwLCBzdXBlci5lbWl0UmVzZXJ2ZWQoXCJvcGVuXCIpO1xuICB9XG4gIG9uRGF0YShlKSB7XG4gICAgY29uc3QgdCA9IFduKGUsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuICAgIHRoaXMub25QYWNrZXQodCk7XG4gIH1cbiAgb25QYWNrZXQoZSkge1xuICAgIHN1cGVyLmVtaXRSZXNlcnZlZChcInBhY2tldFwiLCBlKTtcbiAgfVxuICBvbkNsb3NlKGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NlZFwiLCBzdXBlci5lbWl0UmVzZXJ2ZWQoXCJjbG9zZVwiLCBlKTtcbiAgfVxuICBwYXVzZShlKSB7XG4gIH1cbiAgY3JlYXRlVXJpKGUsIHQgPSB7fSkge1xuICAgIHJldHVybiBlICsgXCI6Ly9cIiArIHRoaXMuX2hvc3RuYW1lKCkgKyB0aGlzLl9wb3J0KCkgKyB0aGlzLm9wdHMucGF0aCArIHRoaXMuX3F1ZXJ5KHQpO1xuICB9XG4gIF9ob3N0bmFtZSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5vcHRzLmhvc3RuYW1lO1xuICAgIHJldHVybiBlLmluZGV4T2YoXCI6XCIpID09PSAtMSA/IGUgOiBcIltcIiArIGUgKyBcIl1cIjtcbiAgfVxuICBfcG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRzLnBvcnQgJiYgKHRoaXMub3B0cy5zZWN1cmUgJiYgTnVtYmVyKHRoaXMub3B0cy5wb3J0ICE9PSA0NDMpIHx8ICF0aGlzLm9wdHMuc2VjdXJlICYmIE51bWJlcih0aGlzLm9wdHMucG9ydCkgIT09IDgwKSA/IFwiOlwiICsgdGhpcy5vcHRzLnBvcnQgOiBcIlwiO1xuICB9XG4gIF9xdWVyeShlKSB7XG4gICAgY29uc3QgdCA9IFpvKGUpO1xuICAgIHJldHVybiB0Lmxlbmd0aCA/IFwiP1wiICsgdCA6IFwiXCI7XG4gIH1cbn1cbmNvbnN0IENzID0gXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ei1fXCIuc3BsaXQoXCJcIiksIERuID0gNjQsIG5hID0ge307XG5sZXQgSXIgPSAwLCBBdCA9IDAsIFZyO1xuZnVuY3Rpb24ganIobikge1xuICBsZXQgZSA9IFwiXCI7XG4gIGRvXG4gICAgZSA9IENzW24gJSBEbl0gKyBlLCBuID0gTWF0aC5mbG9vcihuIC8gRG4pO1xuICB3aGlsZSAobiA+IDApO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIEFzKCkge1xuICBjb25zdCBuID0ganIoK25ldyBEYXRlKCkpO1xuICByZXR1cm4gbiAhPT0gVnIgPyAoSXIgPSAwLCBWciA9IG4pIDogbiArIFwiLlwiICsganIoSXIrKyk7XG59XG5mb3IgKDsgQXQgPCBEbjsgQXQrKylcbiAgbmFbQ3NbQXRdXSA9IEF0O1xubGV0IERzID0gITE7XG50cnkge1xuICBEcyA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA8IFwidVwiICYmIFwid2l0aENyZWRlbnRpYWxzXCIgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG59IGNhdGNoIHtcbn1cbmNvbnN0IHJhID0gRHM7XG5mdW5jdGlvbiBrcyhuKSB7XG4gIGNvbnN0IGUgPSBuLnhkb21haW47XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA8IFwidVwiICYmICghZSB8fCByYSkpXG4gICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gIH0gY2F0Y2gge1xuICB9XG4gIGlmICghZSlcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBoZVtbXCJBY3RpdmVcIl0uY29uY2F0KFwiT2JqZWN0XCIpLmpvaW4oXCJYXCIpXShcIk1pY3Jvc29mdC5YTUxIVFRQXCIpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNhKCkge1xufVxuY29uc3QgaWEgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBrcyh7XG4gICAgeGRvbWFpbjogITFcbiAgfSkucmVzcG9uc2VUeXBlICE9IG51bGw7XG59KCk7XG5jbGFzcyBvYSBleHRlbmRzIEhuIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGlmIChzdXBlcihlKSwgdGhpcy5wb2xsaW5nID0gITEsIHR5cGVvZiBsb2NhdGlvbiA8IFwidVwiKSB7XG4gICAgICBjb25zdCByID0gbG9jYXRpb24ucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG4gICAgICBsZXQgcyA9IGxvY2F0aW9uLnBvcnQ7XG4gICAgICBzIHx8IChzID0gciA/IFwiNDQzXCIgOiBcIjgwXCIpLCB0aGlzLnhkID0gdHlwZW9mIGxvY2F0aW9uIDwgXCJ1XCIgJiYgZS5ob3N0bmFtZSAhPT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcyAhPT0gZS5wb3J0O1xuICAgIH1cbiAgICBjb25zdCB0ID0gZSAmJiBlLmZvcmNlQmFzZTY0O1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBpYSAmJiAhdCwgdGhpcy5vcHRzLndpdGhDcmVkZW50aWFscyAmJiAodGhpcy5jb29raWVKYXIgPSB2b2lkIDApO1xuICB9XG4gIGdldCBuYW1lKCkge1xuICAgIHJldHVybiBcInBvbGxpbmdcIjtcbiAgfVxuICBkb09wZW4oKSB7XG4gICAgdGhpcy5wb2xsKCk7XG4gIH1cbiAgcGF1c2UoZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwicGF1c2luZ1wiO1xuICAgIGNvbnN0IHQgPSAoKSA9PiB7XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcInBhdXNlZFwiLCBlKCk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5wb2xsaW5nIHx8ICF0aGlzLndyaXRhYmxlKSB7XG4gICAgICBsZXQgciA9IDA7XG4gICAgICB0aGlzLnBvbGxpbmcgJiYgKHIrKywgdGhpcy5vbmNlKFwicG9sbENvbXBsZXRlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAtLXIgfHwgdCgpO1xuICAgICAgfSkpLCB0aGlzLndyaXRhYmxlIHx8IChyKyssIHRoaXMub25jZShcImRyYWluXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAtLXIgfHwgdCgpO1xuICAgICAgfSkpO1xuICAgIH0gZWxzZVxuICAgICAgdCgpO1xuICB9XG4gIHBvbGwoKSB7XG4gICAgdGhpcy5wb2xsaW5nID0gITAsIHRoaXMuZG9Qb2xsKCksIHRoaXMuZW1pdFJlc2VydmVkKFwicG9sbFwiKTtcbiAgfVxuICBvbkRhdGEoZSkge1xuICAgIGNvbnN0IHQgPSAocikgPT4ge1xuICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJvcGVuaW5nXCIgJiYgci50eXBlID09PSBcIm9wZW5cIiAmJiB0aGlzLm9uT3BlbigpLCByLnR5cGUgPT09IFwiY2xvc2VcIilcbiAgICAgICAgcmV0dXJuIHRoaXMub25DbG9zZSh7IGRlc2NyaXB0aW9uOiBcInRyYW5zcG9ydCBjbG9zZWQgYnkgdGhlIHNlcnZlclwiIH0pLCAhMTtcbiAgICAgIHRoaXMub25QYWNrZXQocik7XG4gICAgfTtcbiAgICBXbyhlLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKS5mb3JFYWNoKHQpLCB0aGlzLnJlYWR5U3RhdGUgIT09IFwiY2xvc2VkXCIgJiYgKHRoaXMucG9sbGluZyA9ICExLCB0aGlzLmVtaXRSZXNlcnZlZChcInBvbGxDb21wbGV0ZVwiKSwgdGhpcy5yZWFkeVN0YXRlID09PSBcIm9wZW5cIiAmJiB0aGlzLnBvbGwoKSk7XG4gIH1cbiAgZG9DbG9zZSgpIHtcbiAgICBjb25zdCBlID0gKCkgPT4ge1xuICAgICAgdGhpcy53cml0ZShbeyB0eXBlOiBcImNsb3NlXCIgfV0pO1xuICAgIH07XG4gICAgdGhpcy5yZWFkeVN0YXRlID09PSBcIm9wZW5cIiA/IGUoKSA6IHRoaXMub25jZShcIm9wZW5cIiwgZSk7XG4gIH1cbiAgd3JpdGUoZSkge1xuICAgIHRoaXMud3JpdGFibGUgPSAhMSwgTW8oZSwgKHQpID0+IHtcbiAgICAgIHRoaXMuZG9Xcml0ZSh0LCAoKSA9PiB7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSAhMCwgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJkcmFpblwiKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHVyaSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5vcHRzLnNlY3VyZSA/IFwiaHR0cHNcIiA6IFwiaHR0cFwiLCB0ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgICByZXR1cm4gdGhpcy5vcHRzLnRpbWVzdGFtcFJlcXVlc3RzICE9PSAhMSAmJiAodFt0aGlzLm9wdHMudGltZXN0YW1wUGFyYW1dID0gQXMoKSksICF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmICF0LnNpZCAmJiAodC5iNjQgPSAxKSwgdGhpcy5jcmVhdGVVcmkoZSwgdCk7XG4gIH1cbiAgcmVxdWVzdChlID0ge30pIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihlLCB7IHhkOiB0aGlzLnhkLCBjb29raWVKYXI6IHRoaXMuY29va2llSmFyIH0sIHRoaXMub3B0cyksIG5ldyBtZSh0aGlzLnVyaSgpLCBlKTtcbiAgfVxuICBkb1dyaXRlKGUsIHQpIHtcbiAgICBjb25zdCByID0gdGhpcy5yZXF1ZXN0KHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBkYXRhOiBlXG4gICAgfSk7XG4gICAgci5vbihcInN1Y2Nlc3NcIiwgdCksIHIub24oXCJlcnJvclwiLCAocywgaSkgPT4ge1xuICAgICAgdGhpcy5vbkVycm9yKFwieGhyIHBvc3QgZXJyb3JcIiwgcywgaSk7XG4gICAgfSk7XG4gIH1cbiAgZG9Qb2xsKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnJlcXVlc3QoKTtcbiAgICBlLm9uKFwiZGF0YVwiLCB0aGlzLm9uRGF0YS5iaW5kKHRoaXMpKSwgZS5vbihcImVycm9yXCIsICh0LCByKSA9PiB7XG4gICAgICB0aGlzLm9uRXJyb3IoXCJ4aHIgcG9sbCBlcnJvclwiLCB0LCByKTtcbiAgICB9KSwgdGhpcy5wb2xsWGhyID0gZTtcbiAgfVxufVxuY2xhc3MgbWUgZXh0ZW5kcyBLIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKCksIE10KHRoaXMsIHQpLCB0aGlzLm9wdHMgPSB0LCB0aGlzLm1ldGhvZCA9IHQubWV0aG9kIHx8IFwiR0VUXCIsIHRoaXMudXJpID0gZSwgdGhpcy5kYXRhID0gdC5kYXRhICE9PSB2b2lkIDAgPyB0LmRhdGEgOiBudWxsLCB0aGlzLmNyZWF0ZSgpO1xuICB9XG4gIGNyZWF0ZSgpIHtcbiAgICB2YXIgZTtcbiAgICBjb25zdCB0ID0geHModGhpcy5vcHRzLCBcImFnZW50XCIsIFwicGZ4XCIsIFwia2V5XCIsIFwicGFzc3BocmFzZVwiLCBcImNlcnRcIiwgXCJjYVwiLCBcImNpcGhlcnNcIiwgXCJyZWplY3RVbmF1dGhvcml6ZWRcIiwgXCJhdXRvVW5yZWZcIik7XG4gICAgdC54ZG9tYWluID0gISF0aGlzLm9wdHMueGQ7XG4gICAgY29uc3QgciA9IHRoaXMueGhyID0gbmV3IGtzKHQpO1xuICAgIHRyeSB7XG4gICAgICByLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCAhMCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5vcHRzLmV4dHJhSGVhZGVycykge1xuICAgICAgICAgIHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrICYmIHIuc2V0RGlzYWJsZUhlYWRlckNoZWNrKCEwKTtcbiAgICAgICAgICBmb3IgKGxldCBzIGluIHRoaXMub3B0cy5leHRyYUhlYWRlcnMpXG4gICAgICAgICAgICB0aGlzLm9wdHMuZXh0cmFIZWFkZXJzLmhhc093blByb3BlcnR5KHMpICYmIHIuc2V0UmVxdWVzdEhlYWRlcihzLCB0aGlzLm9wdHMuZXh0cmFIZWFkZXJzW3NdKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwiUE9TVFwiKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtdHlwZVwiLCBcInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwiKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHIuc2V0UmVxdWVzdEhlYWRlcihcIkFjY2VwdFwiLCBcIiovKlwiKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgKGUgPSB0aGlzLm9wdHMuY29va2llSmFyKSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgfHwgZS5hZGRDb29raWVzKHIpLCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHIgJiYgKHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy5vcHRzLndpdGhDcmVkZW50aWFscyksIHRoaXMub3B0cy5yZXF1ZXN0VGltZW91dCAmJiAoci50aW1lb3V0ID0gdGhpcy5vcHRzLnJlcXVlc3RUaW1lb3V0KSwgci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgIHZhciBzO1xuICAgICAgICByLnJlYWR5U3RhdGUgPT09IDMgJiYgKChzID0gdGhpcy5vcHRzLmNvb2tpZUphcikgPT09IG51bGwgfHwgcyA9PT0gdm9pZCAwIHx8IHMucGFyc2VDb29raWVzKHIpKSwgci5yZWFkeVN0YXRlID09PSA0ICYmIChyLnN0YXR1cyA9PT0gMjAwIHx8IHIuc3RhdHVzID09PSAxMjIzID8gdGhpcy5vbkxvYWQoKSA6IHRoaXMuc2V0VGltZW91dEZuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLm9uRXJyb3IodHlwZW9mIHIuc3RhdHVzID09IFwibnVtYmVyXCIgPyByLnN0YXR1cyA6IDApO1xuICAgICAgICB9LCAwKSk7XG4gICAgICB9LCByLnNlbmQodGhpcy5kYXRhKTtcbiAgICB9IGNhdGNoIChzKSB7XG4gICAgICB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICAgIHRoaXMub25FcnJvcihzKTtcbiAgICAgIH0sIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0eXBlb2YgZG9jdW1lbnQgPCBcInVcIiAmJiAodGhpcy5pbmRleCA9IG1lLnJlcXVlc3RzQ291bnQrKywgbWUucmVxdWVzdHNbdGhpcy5pbmRleF0gPSB0aGlzKTtcbiAgfVxuICBvbkVycm9yKGUpIHtcbiAgICB0aGlzLmVtaXRSZXNlcnZlZChcImVycm9yXCIsIGUsIHRoaXMueGhyKSwgdGhpcy5jbGVhbnVwKCEwKTtcbiAgfVxuICBjbGVhbnVwKGUpIHtcbiAgICBpZiAoISh0eXBlb2YgdGhpcy54aHIgPiBcInVcIiB8fCB0aGlzLnhociA9PT0gbnVsbCkpIHtcbiAgICAgIGlmICh0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBzYSwgZSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgfVxuICAgICAgdHlwZW9mIGRvY3VtZW50IDwgXCJ1XCIgJiYgZGVsZXRlIG1lLnJlcXVlc3RzW3RoaXMuaW5kZXhdLCB0aGlzLnhociA9IG51bGw7XG4gICAgfVxuICB9XG4gIG9uTG9hZCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuICAgIGUgIT09IG51bGwgJiYgKHRoaXMuZW1pdFJlc2VydmVkKFwiZGF0YVwiLCBlKSwgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJzdWNjZXNzXCIpLCB0aGlzLmNsZWFudXAoKSk7XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cbn1cbm1lLnJlcXVlc3RzQ291bnQgPSAwO1xubWUucmVxdWVzdHMgPSB7fTtcbmlmICh0eXBlb2YgZG9jdW1lbnQgPCBcInVcIikge1xuICBpZiAodHlwZW9mIGF0dGFjaEV2ZW50ID09IFwiZnVuY3Rpb25cIilcbiAgICBhdHRhY2hFdmVudChcIm9udW5sb2FkXCIsICRyKTtcbiAgZWxzZSBpZiAodHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgbiA9IFwib25wYWdlaGlkZVwiIGluIGhlID8gXCJwYWdlaGlkZVwiIDogXCJ1bmxvYWRcIjtcbiAgICBhZGRFdmVudExpc3RlbmVyKG4sICRyLCAhMSk7XG4gIH1cbn1cbmZ1bmN0aW9uICRyKCkge1xuICBmb3IgKGxldCBuIGluIG1lLnJlcXVlc3RzKVxuICAgIG1lLnJlcXVlc3RzLmhhc093blByb3BlcnR5KG4pICYmIG1lLnJlcXVlc3RzW25dLmFib3J0KCk7XG59XG5jb25zdCBKbiA9ICgoKSA9PiB0eXBlb2YgUHJvbWlzZSA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFByb21pc2UucmVzb2x2ZSA9PSBcImZ1bmN0aW9uXCIgPyAoZSkgPT4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihlKSA6IChlLCB0KSA9PiB0KGUsIDApKSgpLCBEdCA9IGhlLldlYlNvY2tldCB8fCBoZS5Nb3pXZWJTb2NrZXQsIE1yID0gITAsIGFhID0gXCJhcnJheWJ1ZmZlclwiLCBXciA9IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiB0eXBlb2YgbmF2aWdhdG9yLnByb2R1Y3QgPT0gXCJzdHJpbmdcIiAmJiBuYXZpZ2F0b3IucHJvZHVjdC50b0xvd2VyQ2FzZSgpID09PSBcInJlYWN0bmF0aXZlXCI7XG5jbGFzcyB1YSBleHRlbmRzIEhuIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUpLCB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gIWUuZm9yY2VCYXNlNjQ7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIFwid2Vic29ja2V0XCI7XG4gIH1cbiAgZG9PcGVuKCkge1xuICAgIGlmICghdGhpcy5jaGVjaygpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLnVyaSgpLCB0ID0gdGhpcy5vcHRzLnByb3RvY29scywgciA9IFdyID8ge30gOiB4cyh0aGlzLm9wdHMsIFwiYWdlbnRcIiwgXCJwZXJNZXNzYWdlRGVmbGF0ZVwiLCBcInBmeFwiLCBcImtleVwiLCBcInBhc3NwaHJhc2VcIiwgXCJjZXJ0XCIsIFwiY2FcIiwgXCJjaXBoZXJzXCIsIFwicmVqZWN0VW5hdXRob3JpemVkXCIsIFwibG9jYWxBZGRyZXNzXCIsIFwicHJvdG9jb2xWZXJzaW9uXCIsIFwib3JpZ2luXCIsIFwibWF4UGF5bG9hZFwiLCBcImZhbWlseVwiLCBcImNoZWNrU2VydmVySWRlbnRpdHlcIik7XG4gICAgdGhpcy5vcHRzLmV4dHJhSGVhZGVycyAmJiAoci5oZWFkZXJzID0gdGhpcy5vcHRzLmV4dHJhSGVhZGVycyk7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMud3MgPSBNciAmJiAhV3IgPyB0ID8gbmV3IER0KGUsIHQpIDogbmV3IER0KGUpIDogbmV3IER0KGUsIHQsIHIpO1xuICAgIH0gY2F0Y2ggKHMpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXRSZXNlcnZlZChcImVycm9yXCIsIHMpO1xuICAgIH1cbiAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gIH1cbiAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy53cy5vbm9wZW4gPSAoKSA9PiB7XG4gICAgICB0aGlzLm9wdHMuYXV0b1VucmVmICYmIHRoaXMud3MuX3NvY2tldC51bnJlZigpLCB0aGlzLm9uT3BlbigpO1xuICAgIH0sIHRoaXMud3Mub25jbG9zZSA9IChlKSA9PiB0aGlzLm9uQ2xvc2Uoe1xuICAgICAgZGVzY3JpcHRpb246IFwid2Vic29ja2V0IGNvbm5lY3Rpb24gY2xvc2VkXCIsXG4gICAgICBjb250ZXh0OiBlXG4gICAgfSksIHRoaXMud3Mub25tZXNzYWdlID0gKGUpID0+IHRoaXMub25EYXRhKGUuZGF0YSksIHRoaXMud3Mub25lcnJvciA9IChlKSA9PiB0aGlzLm9uRXJyb3IoXCJ3ZWJzb2NrZXQgZXJyb3JcIiwgZSk7XG4gIH1cbiAgd3JpdGUoZSkge1xuICAgIHRoaXMud3JpdGFibGUgPSAhMTtcbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0KyspIHtcbiAgICAgIGNvbnN0IHIgPSBlW3RdLCBzID0gdCA9PT0gZS5sZW5ndGggLSAxO1xuICAgICAgTW4ociwgdGhpcy5zdXBwb3J0c0JpbmFyeSwgKGkpID0+IHtcbiAgICAgICAgY29uc3QgbyA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIE1yICYmIHRoaXMud3Muc2VuZChpKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgIH1cbiAgICAgICAgcyAmJiBKbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy53cml0YWJsZSA9ICEwLCB0aGlzLmVtaXRSZXNlcnZlZChcImRyYWluXCIpO1xuICAgICAgICB9LCB0aGlzLnNldFRpbWVvdXRGbik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZG9DbG9zZSgpIHtcbiAgICB0eXBlb2YgdGhpcy53cyA8IFwidVwiICYmICh0aGlzLndzLmNsb3NlKCksIHRoaXMud3MgPSBudWxsKTtcbiAgfVxuICB1cmkoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMub3B0cy5zZWN1cmUgPyBcIndzc1wiIDogXCJ3c1wiLCB0ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgICByZXR1cm4gdGhpcy5vcHRzLnRpbWVzdGFtcFJlcXVlc3RzICYmICh0W3RoaXMub3B0cy50aW1lc3RhbXBQYXJhbV0gPSBBcygpKSwgdGhpcy5zdXBwb3J0c0JpbmFyeSB8fCAodC5iNjQgPSAxKSwgdGhpcy5jcmVhdGVVcmkoZSwgdCk7XG4gIH1cbiAgY2hlY2soKSB7XG4gICAgcmV0dXJuICEhRHQ7XG4gIH1cbn1cbmNsYXNzIGNhIGV4dGVuZHMgSG4ge1xuICBnZXQgbmFtZSgpIHtcbiAgICByZXR1cm4gXCJ3ZWJ0cmFuc3BvcnRcIjtcbiAgfVxuICBkb09wZW4oKSB7XG4gICAgdHlwZW9mIFdlYlRyYW5zcG9ydCA9PSBcImZ1bmN0aW9uXCIgJiYgKHRoaXMudHJhbnNwb3J0ID0gbmV3IFdlYlRyYW5zcG9ydCh0aGlzLmNyZWF0ZVVyaShcImh0dHBzXCIpLCB0aGlzLm9wdHMudHJhbnNwb3J0T3B0aW9uc1t0aGlzLm5hbWVdKSwgdGhpcy50cmFuc3BvcnQuY2xvc2VkLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgfSkuY2F0Y2goKGUpID0+IHtcbiAgICAgIHRoaXMub25FcnJvcihcIndlYnRyYW5zcG9ydCBlcnJvclwiLCBlKTtcbiAgICB9KSwgdGhpcy50cmFuc3BvcnQucmVhZHkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLnRyYW5zcG9ydC5jcmVhdGVCaWRpcmVjdGlvbmFsU3RyZWFtKCkudGhlbigoZSkgPT4ge1xuICAgICAgICBjb25zdCB0ID0gSm8oTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpLCByID0gZS5yZWFkYWJsZS5waXBlVGhyb3VnaCh0KS5nZXRSZWFkZXIoKSwgcyA9IEhvKCk7XG4gICAgICAgIHMucmVhZGFibGUucGlwZVRvKGUud3JpdGFibGUpLCB0aGlzLndyaXRlciA9IHMud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gICAgICAgIGNvbnN0IGkgPSAoKSA9PiB7XG4gICAgICAgICAgci5yZWFkKCkudGhlbigoeyBkb25lOiB1LCB2YWx1ZTogbCB9KSA9PiB7XG4gICAgICAgICAgICB1IHx8ICh0aGlzLm9uUGFja2V0KGwpLCBpKCkpO1xuICAgICAgICAgIH0pLmNhdGNoKCh1KSA9PiB7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGkoKTtcbiAgICAgICAgY29uc3QgbyA9IHsgdHlwZTogXCJvcGVuXCIgfTtcbiAgICAgICAgdGhpcy5xdWVyeS5zaWQgJiYgKG8uZGF0YSA9IGB7XCJzaWRcIjpcIiR7dGhpcy5xdWVyeS5zaWR9XCJ9YCksIHRoaXMud3JpdGVyLndyaXRlKG8pLnRoZW4oKCkgPT4gdGhpcy5vbk9wZW4oKSk7XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH1cbiAgd3JpdGUoZSkge1xuICAgIHRoaXMud3JpdGFibGUgPSAhMTtcbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0KyspIHtcbiAgICAgIGNvbnN0IHIgPSBlW3RdLCBzID0gdCA9PT0gZS5sZW5ndGggLSAxO1xuICAgICAgdGhpcy53cml0ZXIud3JpdGUocikudGhlbigoKSA9PiB7XG4gICAgICAgIHMgJiYgSm4oKCkgPT4ge1xuICAgICAgICAgIHRoaXMud3JpdGFibGUgPSAhMCwgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJkcmFpblwiKTtcbiAgICAgICAgfSwgdGhpcy5zZXRUaW1lb3V0Rm4pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGRvQ2xvc2UoKSB7XG4gICAgdmFyIGU7XG4gICAgKGUgPSB0aGlzLnRyYW5zcG9ydCkgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwIHx8IGUuY2xvc2UoKTtcbiAgfVxufVxuY29uc3QgbGEgPSB7XG4gIHdlYnNvY2tldDogdWEsXG4gIHdlYnRyYW5zcG9ydDogY2EsXG4gIHBvbGxpbmc6IG9hXG59LCBmYSA9IC9eKD86KD8hW146QFxcLz8jXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QFxcLz8jXSopKD86OihbXjpAXFwvPyNdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvLCBoYSA9IFtcbiAgXCJzb3VyY2VcIixcbiAgXCJwcm90b2NvbFwiLFxuICBcImF1dGhvcml0eVwiLFxuICBcInVzZXJJbmZvXCIsXG4gIFwidXNlclwiLFxuICBcInBhc3N3b3JkXCIsXG4gIFwiaG9zdFwiLFxuICBcInBvcnRcIixcbiAgXCJyZWxhdGl2ZVwiLFxuICBcInBhdGhcIixcbiAgXCJkaXJlY3RvcnlcIixcbiAgXCJmaWxlXCIsXG4gIFwicXVlcnlcIixcbiAgXCJhbmNob3JcIlxuXTtcbmZ1bmN0aW9uIGtuKG4pIHtcbiAgY29uc3QgZSA9IG4sIHQgPSBuLmluZGV4T2YoXCJbXCIpLCByID0gbi5pbmRleE9mKFwiXVwiKTtcbiAgdCAhPSAtMSAmJiByICE9IC0xICYmIChuID0gbi5zdWJzdHJpbmcoMCwgdCkgKyBuLnN1YnN0cmluZyh0LCByKS5yZXBsYWNlKC86L2csIFwiO1wiKSArIG4uc3Vic3RyaW5nKHIsIG4ubGVuZ3RoKSk7XG4gIGxldCBzID0gZmEuZXhlYyhuIHx8IFwiXCIpLCBpID0ge30sIG8gPSAxNDtcbiAgZm9yICg7IG8tLTsgKVxuICAgIGlbaGFbb11dID0gc1tvXSB8fCBcIlwiO1xuICByZXR1cm4gdCAhPSAtMSAmJiByICE9IC0xICYmIChpLnNvdXJjZSA9IGUsIGkuaG9zdCA9IGkuaG9zdC5zdWJzdHJpbmcoMSwgaS5ob3N0Lmxlbmd0aCAtIDEpLnJlcGxhY2UoLzsvZywgXCI6XCIpLCBpLmF1dGhvcml0eSA9IGkuYXV0aG9yaXR5LnJlcGxhY2UoXCJbXCIsIFwiXCIpLnJlcGxhY2UoXCJdXCIsIFwiXCIpLnJlcGxhY2UoLzsvZywgXCI6XCIpLCBpLmlwdjZ1cmkgPSAhMCksIGkucGF0aE5hbWVzID0gZGEoaSwgaS5wYXRoKSwgaS5xdWVyeUtleSA9IHBhKGksIGkucXVlcnkpLCBpO1xufVxuZnVuY3Rpb24gZGEobiwgZSkge1xuICBjb25zdCB0ID0gL1xcL3syLDl9L2csIHIgPSBlLnJlcGxhY2UodCwgXCIvXCIpLnNwbGl0KFwiL1wiKTtcbiAgcmV0dXJuIChlLnNsaWNlKDAsIDEpID09IFwiL1wiIHx8IGUubGVuZ3RoID09PSAwKSAmJiByLnNwbGljZSgwLCAxKSwgZS5zbGljZSgtMSkgPT0gXCIvXCIgJiYgci5zcGxpY2Uoci5sZW5ndGggLSAxLCAxKSwgcjtcbn1cbmZ1bmN0aW9uIHBhKG4sIGUpIHtcbiAgY29uc3QgdCA9IHt9O1xuICByZXR1cm4gZS5yZXBsYWNlKC8oPzpefCYpKFteJj1dKik9PyhbXiZdKikvZywgZnVuY3Rpb24ociwgcywgaSkge1xuICAgIHMgJiYgKHRbc10gPSBpKTtcbiAgfSksIHQ7XG59XG5jbGFzcyBDZSBleHRlbmRzIEsge1xuICBjb25zdHJ1Y3RvcihlLCB0ID0ge30pIHtcbiAgICBzdXBlcigpLCB0aGlzLmJpbmFyeVR5cGUgPSBhYSwgdGhpcy53cml0ZUJ1ZmZlciA9IFtdLCBlICYmIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgKHQgPSBlLCBlID0gbnVsbCksIGUgPyAoZSA9IGtuKGUpLCB0Lmhvc3RuYW1lID0gZS5ob3N0LCB0LnNlY3VyZSA9IGUucHJvdG9jb2wgPT09IFwiaHR0cHNcIiB8fCBlLnByb3RvY29sID09PSBcIndzc1wiLCB0LnBvcnQgPSBlLnBvcnQsIGUucXVlcnkgJiYgKHQucXVlcnkgPSBlLnF1ZXJ5KSkgOiB0Lmhvc3QgJiYgKHQuaG9zdG5hbWUgPSBrbih0Lmhvc3QpLmhvc3QpLCBNdCh0aGlzLCB0KSwgdGhpcy5zZWN1cmUgPSB0LnNlY3VyZSAhPSBudWxsID8gdC5zZWN1cmUgOiB0eXBlb2YgbG9jYXRpb24gPCBcInVcIiAmJiBsb2NhdGlvbi5wcm90b2NvbCA9PT0gXCJodHRwczpcIiwgdC5ob3N0bmFtZSAmJiAhdC5wb3J0ICYmICh0LnBvcnQgPSB0aGlzLnNlY3VyZSA/IFwiNDQzXCIgOiBcIjgwXCIpLCB0aGlzLmhvc3RuYW1lID0gdC5ob3N0bmFtZSB8fCAodHlwZW9mIGxvY2F0aW9uIDwgXCJ1XCIgPyBsb2NhdGlvbi5ob3N0bmFtZSA6IFwibG9jYWxob3N0XCIpLCB0aGlzLnBvcnQgPSB0LnBvcnQgfHwgKHR5cGVvZiBsb2NhdGlvbiA8IFwidVwiICYmIGxvY2F0aW9uLnBvcnQgPyBsb2NhdGlvbi5wb3J0IDogdGhpcy5zZWN1cmUgPyBcIjQ0M1wiIDogXCI4MFwiKSwgdGhpcy50cmFuc3BvcnRzID0gdC50cmFuc3BvcnRzIHx8IFtcbiAgICAgIFwicG9sbGluZ1wiLFxuICAgICAgXCJ3ZWJzb2NrZXRcIixcbiAgICAgIFwid2VidHJhbnNwb3J0XCJcbiAgICBdLCB0aGlzLndyaXRlQnVmZmVyID0gW10sIHRoaXMucHJldkJ1ZmZlckxlbiA9IDAsIHRoaXMub3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgcGF0aDogXCIvZW5naW5lLmlvXCIsXG4gICAgICBhZ2VudDogITEsXG4gICAgICB3aXRoQ3JlZGVudGlhbHM6ICExLFxuICAgICAgdXBncmFkZTogITAsXG4gICAgICB0aW1lc3RhbXBQYXJhbTogXCJ0XCIsXG4gICAgICByZW1lbWJlclVwZ3JhZGU6ICExLFxuICAgICAgYWRkVHJhaWxpbmdTbGFzaDogITAsXG4gICAgICByZWplY3RVbmF1dGhvcml6ZWQ6ICEwLFxuICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IHtcbiAgICAgICAgdGhyZXNob2xkOiAxMDI0XG4gICAgICB9LFxuICAgICAgdHJhbnNwb3J0T3B0aW9uczoge30sXG4gICAgICBjbG9zZU9uQmVmb3JldW5sb2FkOiAhMVxuICAgIH0sIHQpLCB0aGlzLm9wdHMucGF0aCA9IHRoaXMub3B0cy5wYXRoLnJlcGxhY2UoL1xcLyQvLCBcIlwiKSArICh0aGlzLm9wdHMuYWRkVHJhaWxpbmdTbGFzaCA/IFwiL1wiIDogXCJcIiksIHR5cGVvZiB0aGlzLm9wdHMucXVlcnkgPT0gXCJzdHJpbmdcIiAmJiAodGhpcy5vcHRzLnF1ZXJ5ID0gZWEodGhpcy5vcHRzLnF1ZXJ5KSksIHRoaXMuaWQgPSBudWxsLCB0aGlzLnVwZ3JhZGVzID0gbnVsbCwgdGhpcy5waW5nSW50ZXJ2YWwgPSBudWxsLCB0aGlzLnBpbmdUaW1lb3V0ID0gbnVsbCwgdGhpcy5waW5nVGltZW91dFRpbWVyID0gbnVsbCwgdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT0gXCJmdW5jdGlvblwiICYmICh0aGlzLm9wdHMuY2xvc2VPbkJlZm9yZXVubG9hZCAmJiAodGhpcy5iZWZvcmV1bmxvYWRFdmVudExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc3BvcnQgJiYgKHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpLCB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpKTtcbiAgICB9LCBhZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIHRoaXMuYmVmb3JldW5sb2FkRXZlbnRMaXN0ZW5lciwgITEpKSwgdGhpcy5ob3N0bmFtZSAhPT0gXCJsb2NhbGhvc3RcIiAmJiAodGhpcy5vZmZsaW5lRXZlbnRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgIHRoaXMub25DbG9zZShcInRyYW5zcG9ydCBjbG9zZVwiLCB7XG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIm5ldHdvcmsgY29ubmVjdGlvbiBsb3N0XCJcbiAgICAgIH0pO1xuICAgIH0sIGFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsIHRoaXMub2ZmbGluZUV2ZW50TGlzdGVuZXIsICExKSkpLCB0aGlzLm9wZW4oKTtcbiAgfVxuICBjcmVhdGVUcmFuc3BvcnQoZSkge1xuICAgIGNvbnN0IHQgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdHMucXVlcnkpO1xuICAgIHQuRUlPID0gT3MsIHQudHJhbnNwb3J0ID0gZSwgdGhpcy5pZCAmJiAodC5zaWQgPSB0aGlzLmlkKTtcbiAgICBjb25zdCByID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRzLCB7XG4gICAgICBxdWVyeTogdCxcbiAgICAgIHNvY2tldDogdGhpcyxcbiAgICAgIGhvc3RuYW1lOiB0aGlzLmhvc3RuYW1lLFxuICAgICAgc2VjdXJlOiB0aGlzLnNlY3VyZSxcbiAgICAgIHBvcnQ6IHRoaXMucG9ydFxuICAgIH0sIHRoaXMub3B0cy50cmFuc3BvcnRPcHRpb25zW2VdKTtcbiAgICByZXR1cm4gbmV3IGxhW2VdKHIpO1xuICB9XG4gIG9wZW4oKSB7XG4gICAgbGV0IGU7XG4gICAgaWYgKHRoaXMub3B0cy5yZW1lbWJlclVwZ3JhZGUgJiYgQ2UucHJpb3JXZWJzb2NrZXRTdWNjZXNzICYmIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKFwid2Vic29ja2V0XCIpICE9PSAtMSlcbiAgICAgIGUgPSBcIndlYnNvY2tldFwiO1xuICAgIGVsc2UgaWYgKHRoaXMudHJhbnNwb3J0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc2V0VGltZW91dEZuKCgpID0+IHtcbiAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJlcnJvclwiLCBcIk5vIHRyYW5zcG9ydHMgYXZhaWxhYmxlXCIpO1xuICAgICAgfSwgMCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlXG4gICAgICBlID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlbmluZ1wiO1xuICAgIHRyeSB7XG4gICAgICBlID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQoZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICB0aGlzLnRyYW5zcG9ydHMuc2hpZnQoKSwgdGhpcy5vcGVuKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUub3BlbigpLCB0aGlzLnNldFRyYW5zcG9ydChlKTtcbiAgfVxuICBzZXRUcmFuc3BvcnQoZSkge1xuICAgIHRoaXMudHJhbnNwb3J0ICYmIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpLCB0aGlzLnRyYW5zcG9ydCA9IGUsIGUub24oXCJkcmFpblwiLCB0aGlzLm9uRHJhaW4uYmluZCh0aGlzKSkub24oXCJwYWNrZXRcIiwgdGhpcy5vblBhY2tldC5iaW5kKHRoaXMpKS5vbihcImVycm9yXCIsIHRoaXMub25FcnJvci5iaW5kKHRoaXMpKS5vbihcImNsb3NlXCIsICh0KSA9PiB0aGlzLm9uQ2xvc2UoXCJ0cmFuc3BvcnQgY2xvc2VcIiwgdCkpO1xuICB9XG4gIHByb2JlKGUpIHtcbiAgICBsZXQgdCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KGUpLCByID0gITE7XG4gICAgQ2UucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gITE7XG4gICAgY29uc3QgcyA9ICgpID0+IHtcbiAgICAgIHIgfHwgKHQuc2VuZChbeyB0eXBlOiBcInBpbmdcIiwgZGF0YTogXCJwcm9iZVwiIH1dKSwgdC5vbmNlKFwicGFja2V0XCIsIChmKSA9PiB7XG4gICAgICAgIGlmICghcilcbiAgICAgICAgICBpZiAoZi50eXBlID09PSBcInBvbmdcIiAmJiBmLmRhdGEgPT09IFwicHJvYmVcIikge1xuICAgICAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nID0gITAsIHRoaXMuZW1pdFJlc2VydmVkKFwidXBncmFkaW5nXCIsIHQpLCAhdClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgQ2UucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gdC5uYW1lID09PSBcIndlYnNvY2tldFwiLCB0aGlzLnRyYW5zcG9ydC5wYXVzZSgoKSA9PiB7XG4gICAgICAgICAgICAgIHIgfHwgdGhpcy5yZWFkeVN0YXRlICE9PSBcImNsb3NlZFwiICYmIChoKCksIHRoaXMuc2V0VHJhbnNwb3J0KHQpLCB0LnNlbmQoW3sgdHlwZTogXCJ1cGdyYWRlXCIgfV0pLCB0aGlzLmVtaXRSZXNlcnZlZChcInVwZ3JhZGVcIiwgdCksIHQgPSBudWxsLCB0aGlzLnVwZ3JhZGluZyA9ICExLCB0aGlzLmZsdXNoKCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBuZXcgRXJyb3IoXCJwcm9iZSBlcnJvclwiKTtcbiAgICAgICAgICAgIHAudHJhbnNwb3J0ID0gdC5uYW1lLCB0aGlzLmVtaXRSZXNlcnZlZChcInVwZ3JhZGVFcnJvclwiLCBwKTtcbiAgICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBpKCkge1xuICAgICAgciB8fCAociA9ICEwLCBoKCksIHQuY2xvc2UoKSwgdCA9IG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBvID0gKGYpID0+IHtcbiAgICAgIGNvbnN0IHAgPSBuZXcgRXJyb3IoXCJwcm9iZSBlcnJvcjogXCIgKyBmKTtcbiAgICAgIHAudHJhbnNwb3J0ID0gdC5uYW1lLCBpKCksIHRoaXMuZW1pdFJlc2VydmVkKFwidXBncmFkZUVycm9yXCIsIHApO1xuICAgIH07XG4gICAgZnVuY3Rpb24gdSgpIHtcbiAgICAgIG8oXCJ0cmFuc3BvcnQgY2xvc2VkXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsKCkge1xuICAgICAgbyhcInNvY2tldCBjbG9zZWRcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGEoZikge1xuICAgICAgdCAmJiBmLm5hbWUgIT09IHQubmFtZSAmJiBpKCk7XG4gICAgfVxuICAgIGNvbnN0IGggPSAoKSA9PiB7XG4gICAgICB0LnJlbW92ZUxpc3RlbmVyKFwib3BlblwiLCBzKSwgdC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG8pLCB0LnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgdSksIHRoaXMub2ZmKFwiY2xvc2VcIiwgbCksIHRoaXMub2ZmKFwidXBncmFkaW5nXCIsIGEpO1xuICAgIH07XG4gICAgdC5vbmNlKFwib3BlblwiLCBzKSwgdC5vbmNlKFwiZXJyb3JcIiwgbyksIHQub25jZShcImNsb3NlXCIsIHUpLCB0aGlzLm9uY2UoXCJjbG9zZVwiLCBsKSwgdGhpcy5vbmNlKFwidXBncmFkaW5nXCIsIGEpLCB0aGlzLnVwZ3JhZGVzLmluZGV4T2YoXCJ3ZWJ0cmFuc3BvcnRcIikgIT09IC0xICYmIGUgIT09IFwid2VidHJhbnNwb3J0XCIgPyB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICByIHx8IHQub3BlbigpO1xuICAgIH0sIDIwMCkgOiB0Lm9wZW4oKTtcbiAgfVxuICBvbk9wZW4oKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlblwiLCBDZS5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSB0aGlzLnRyYW5zcG9ydC5uYW1lID09PSBcIndlYnNvY2tldFwiLCB0aGlzLmVtaXRSZXNlcnZlZChcIm9wZW5cIiksIHRoaXMuZmx1c2goKSwgdGhpcy5yZWFkeVN0YXRlID09PSBcIm9wZW5cIiAmJiB0aGlzLm9wdHMudXBncmFkZSkge1xuICAgICAgbGV0IGUgPSAwO1xuICAgICAgY29uc3QgdCA9IHRoaXMudXBncmFkZXMubGVuZ3RoO1xuICAgICAgZm9yICg7IGUgPCB0OyBlKyspXG4gICAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tlXSk7XG4gICAgfVxuICB9XG4gIG9uUGFja2V0KGUpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBcIm9wZW5pbmdcIiB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFwib3BlblwiIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJjbG9zaW5nXCIpXG4gICAgICBzd2l0Y2ggKHRoaXMuZW1pdFJlc2VydmVkKFwicGFja2V0XCIsIGUpLCB0aGlzLmVtaXRSZXNlcnZlZChcImhlYXJ0YmVhdFwiKSwgdGhpcy5yZXNldFBpbmdUaW1lb3V0KCksIGUudHlwZSkge1xuICAgICAgICBjYXNlIFwib3BlblwiOlxuICAgICAgICAgIHRoaXMub25IYW5kc2hha2UoSlNPTi5wYXJzZShlLmRhdGEpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInBpbmdcIjpcbiAgICAgICAgICB0aGlzLnNlbmRQYWNrZXQoXCJwb25nXCIpLCB0aGlzLmVtaXRSZXNlcnZlZChcInBpbmdcIiksIHRoaXMuZW1pdFJlc2VydmVkKFwicG9uZ1wiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgY29uc3QgdCA9IG5ldyBFcnJvcihcInNlcnZlciBlcnJvclwiKTtcbiAgICAgICAgICB0LmNvZGUgPSBlLmRhdGEsIHRoaXMub25FcnJvcih0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRhdGFcIiwgZS5kYXRhKSwgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJtZXNzYWdlXCIsIGUuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbiAgb25IYW5kc2hha2UoZSkge1xuICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiaGFuZHNoYWtlXCIsIGUpLCB0aGlzLmlkID0gZS5zaWQsIHRoaXMudHJhbnNwb3J0LnF1ZXJ5LnNpZCA9IGUuc2lkLCB0aGlzLnVwZ3JhZGVzID0gdGhpcy5maWx0ZXJVcGdyYWRlcyhlLnVwZ3JhZGVzKSwgdGhpcy5waW5nSW50ZXJ2YWwgPSBlLnBpbmdJbnRlcnZhbCwgdGhpcy5waW5nVGltZW91dCA9IGUucGluZ1RpbWVvdXQsIHRoaXMubWF4UGF5bG9hZCA9IGUubWF4UGF5bG9hZCwgdGhpcy5vbk9wZW4oKSwgdGhpcy5yZWFkeVN0YXRlICE9PSBcImNsb3NlZFwiICYmIHRoaXMucmVzZXRQaW5nVGltZW91dCgpO1xuICB9XG4gIHJlc2V0UGluZ1RpbWVvdXQoKSB7XG4gICAgdGhpcy5jbGVhclRpbWVvdXRGbih0aGlzLnBpbmdUaW1lb3V0VGltZXIpLCB0aGlzLnBpbmdUaW1lb3V0VGltZXIgPSB0aGlzLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICB0aGlzLm9uQ2xvc2UoXCJwaW5nIHRpbWVvdXRcIik7XG4gICAgfSwgdGhpcy5waW5nSW50ZXJ2YWwgKyB0aGlzLnBpbmdUaW1lb3V0KSwgdGhpcy5vcHRzLmF1dG9VbnJlZiAmJiB0aGlzLnBpbmdUaW1lb3V0VGltZXIudW5yZWYoKTtcbiAgfVxuICBvbkRyYWluKCkge1xuICAgIHRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsIHRoaXMucHJldkJ1ZmZlckxlbiksIHRoaXMucHJldkJ1ZmZlckxlbiA9IDAsIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoID09PSAwID8gdGhpcy5lbWl0UmVzZXJ2ZWQoXCJkcmFpblwiKSA6IHRoaXMuZmx1c2goKTtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBcImNsb3NlZFwiICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmICF0aGlzLnVwZ3JhZGluZyAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgY29uc3QgZSA9IHRoaXMuZ2V0V3JpdGFibGVQYWNrZXRzKCk7XG4gICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKGUpLCB0aGlzLnByZXZCdWZmZXJMZW4gPSBlLmxlbmd0aCwgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJmbHVzaFwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0V3JpdGFibGVQYWNrZXRzKCkge1xuICAgIGlmICghKHRoaXMubWF4UGF5bG9hZCAmJiB0aGlzLnRyYW5zcG9ydC5uYW1lID09PSBcInBvbGxpbmdcIiAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCA+IDEpKVxuICAgICAgcmV0dXJuIHRoaXMud3JpdGVCdWZmZXI7XG4gICAgbGV0IHQgPSAxO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7IHIrKykge1xuICAgICAgY29uc3QgcyA9IHRoaXMud3JpdGVCdWZmZXJbcl0uZGF0YTtcbiAgICAgIGlmIChzICYmICh0ICs9IFhvKHMpKSwgciA+IDAgJiYgdCA+IHRoaXMubWF4UGF5bG9hZClcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVCdWZmZXIuc2xpY2UoMCwgcik7XG4gICAgICB0ICs9IDI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLndyaXRlQnVmZmVyO1xuICB9XG4gIHdyaXRlKGUsIHQsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUGFja2V0KFwibWVzc2FnZVwiLCBlLCB0LCByKSwgdGhpcztcbiAgfVxuICBzZW5kKGUsIHQsIHIpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUGFja2V0KFwibWVzc2FnZVwiLCBlLCB0LCByKSwgdGhpcztcbiAgfVxuICBzZW5kUGFja2V0KGUsIHQsIHIsIHMpIHtcbiAgICBpZiAodHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiICYmIChzID0gdCwgdCA9IHZvaWQgMCksIHR5cGVvZiByID09IFwiZnVuY3Rpb25cIiAmJiAocyA9IHIsIHIgPSBudWxsKSwgdGhpcy5yZWFkeVN0YXRlID09PSBcImNsb3NpbmdcIiB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFwiY2xvc2VkXCIpXG4gICAgICByZXR1cm47XG4gICAgciA9IHIgfHwge30sIHIuY29tcHJlc3MgPSByLmNvbXByZXNzICE9PSAhMTtcbiAgICBjb25zdCBpID0ge1xuICAgICAgdHlwZTogZSxcbiAgICAgIGRhdGE6IHQsXG4gICAgICBvcHRpb25zOiByXG4gICAgfTtcbiAgICB0aGlzLmVtaXRSZXNlcnZlZChcInBhY2tldENyZWF0ZVwiLCBpKSwgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKGkpLCBzICYmIHRoaXMub25jZShcImZsdXNoXCIsIHMpLCB0aGlzLmZsdXNoKCk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgY29uc3QgZSA9ICgpID0+IHtcbiAgICAgIHRoaXMub25DbG9zZShcImZvcmNlZCBjbG9zZVwiKSwgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9LCB0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5vZmYoXCJ1cGdyYWRlXCIsIHQpLCB0aGlzLm9mZihcInVwZ3JhZGVFcnJvclwiLCB0KSwgZSgpO1xuICAgIH0sIHIgPSAoKSA9PiB7XG4gICAgICB0aGlzLm9uY2UoXCJ1cGdyYWRlXCIsIHQpLCB0aGlzLm9uY2UoXCJ1cGdyYWRlRXJyb3JcIiwgdCk7XG4gICAgfTtcbiAgICByZXR1cm4gKHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJvcGVuaW5nXCIgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBcIm9wZW5cIikgJiYgKHRoaXMucmVhZHlTdGF0ZSA9IFwiY2xvc2luZ1wiLCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCA/IHRoaXMub25jZShcImRyYWluXCIsICgpID0+IHtcbiAgICAgIHRoaXMudXBncmFkaW5nID8gcigpIDogZSgpO1xuICAgIH0pIDogdGhpcy51cGdyYWRpbmcgPyByKCkgOiBlKCkpLCB0aGlzO1xuICB9XG4gIG9uRXJyb3IoZSkge1xuICAgIENlLnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICExLCB0aGlzLmVtaXRSZXNlcnZlZChcImVycm9yXCIsIGUpLCB0aGlzLm9uQ2xvc2UoXCJ0cmFuc3BvcnQgZXJyb3JcIiwgZSk7XG4gIH1cbiAgb25DbG9zZShlLCB0KSB7XG4gICAgKHRoaXMucmVhZHlTdGF0ZSA9PT0gXCJvcGVuaW5nXCIgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBcIm9wZW5cIiB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFwiY2xvc2luZ1wiKSAmJiAodGhpcy5jbGVhclRpbWVvdXRGbih0aGlzLnBpbmdUaW1lb3V0VGltZXIpLCB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJjbG9zZVwiKSwgdGhpcy50cmFuc3BvcnQuY2xvc2UoKSwgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCksIHR5cGVvZiByZW1vdmVFdmVudExpc3RlbmVyID09IFwiZnVuY3Rpb25cIiAmJiAocmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCB0aGlzLmJlZm9yZXVubG9hZEV2ZW50TGlzdGVuZXIsICExKSwgcmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgdGhpcy5vZmZsaW5lRXZlbnRMaXN0ZW5lciwgITEpKSwgdGhpcy5yZWFkeVN0YXRlID0gXCJjbG9zZWRcIiwgdGhpcy5pZCA9IG51bGwsIHRoaXMuZW1pdFJlc2VydmVkKFwiY2xvc2VcIiwgZSwgdCksIHRoaXMud3JpdGVCdWZmZXIgPSBbXSwgdGhpcy5wcmV2QnVmZmVyTGVuID0gMCk7XG4gIH1cbiAgZmlsdGVyVXBncmFkZXMoZSkge1xuICAgIGNvbnN0IHQgPSBbXTtcbiAgICBsZXQgciA9IDA7XG4gICAgY29uc3QgcyA9IGUubGVuZ3RoO1xuICAgIGZvciAoOyByIDwgczsgcisrKVxuICAgICAgfnRoaXMudHJhbnNwb3J0cy5pbmRleE9mKGVbcl0pICYmIHQucHVzaChlW3JdKTtcbiAgICByZXR1cm4gdDtcbiAgfVxufVxuQ2UucHJvdG9jb2wgPSBPcztcbmZ1bmN0aW9uIHZhKG4sIGUgPSBcIlwiLCB0KSB7XG4gIGxldCByID0gbjtcbiAgdCA9IHQgfHwgdHlwZW9mIGxvY2F0aW9uIDwgXCJ1XCIgJiYgbG9jYXRpb24sIG4gPT0gbnVsbCAmJiAobiA9IHQucHJvdG9jb2wgKyBcIi8vXCIgKyB0Lmhvc3QpLCB0eXBlb2YgbiA9PSBcInN0cmluZ1wiICYmIChuLmNoYXJBdCgwKSA9PT0gXCIvXCIgJiYgKG4uY2hhckF0KDEpID09PSBcIi9cIiA/IG4gPSB0LnByb3RvY29sICsgbiA6IG4gPSB0Lmhvc3QgKyBuKSwgL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdChuKSB8fCAodHlwZW9mIHQgPCBcInVcIiA/IG4gPSB0LnByb3RvY29sICsgXCIvL1wiICsgbiA6IG4gPSBcImh0dHBzOi8vXCIgKyBuKSwgciA9IGtuKG4pKSwgci5wb3J0IHx8ICgvXihodHRwfHdzKSQvLnRlc3Qoci5wcm90b2NvbCkgPyByLnBvcnQgPSBcIjgwXCIgOiAvXihodHRwfHdzKXMkLy50ZXN0KHIucHJvdG9jb2wpICYmIChyLnBvcnQgPSBcIjQ0M1wiKSksIHIucGF0aCA9IHIucGF0aCB8fCBcIi9cIjtcbiAgY29uc3QgaSA9IHIuaG9zdC5pbmRleE9mKFwiOlwiKSAhPT0gLTEgPyBcIltcIiArIHIuaG9zdCArIFwiXVwiIDogci5ob3N0O1xuICByZXR1cm4gci5pZCA9IHIucHJvdG9jb2wgKyBcIjovL1wiICsgaSArIFwiOlwiICsgci5wb3J0ICsgZSwgci5ocmVmID0gci5wcm90b2NvbCArIFwiOi8vXCIgKyBpICsgKHQgJiYgdC5wb3J0ID09PSByLnBvcnQgPyBcIlwiIDogXCI6XCIgKyByLnBvcnQpLCByO1xufVxuY29uc3QgeWEgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT0gXCJmdW5jdGlvblwiLCBtYSA9IChuKSA9PiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09IFwiZnVuY3Rpb25cIiA/IEFycmF5QnVmZmVyLmlzVmlldyhuKSA6IG4uYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIsIExzID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZywgZ2EgPSB0eXBlb2YgQmxvYiA9PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIEJsb2IgPCBcInVcIiAmJiBMcy5jYWxsKEJsb2IpID09PSBcIltvYmplY3QgQmxvYkNvbnN0cnVjdG9yXVwiLCBfYSA9IHR5cGVvZiBGaWxlID09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgRmlsZSA8IFwidVwiICYmIExzLmNhbGwoRmlsZSkgPT09IFwiW29iamVjdCBGaWxlQ29uc3RydWN0b3JdXCI7XG5mdW5jdGlvbiBZbihuKSB7XG4gIHJldHVybiB5YSAmJiAobiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IG1hKG4pKSB8fCBnYSAmJiBuIGluc3RhbmNlb2YgQmxvYiB8fCBfYSAmJiBuIGluc3RhbmNlb2YgRmlsZTtcbn1cbmZ1bmN0aW9uIFB0KG4sIGUpIHtcbiAgaWYgKCFuIHx8IHR5cGVvZiBuICE9IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuICExO1xuICBpZiAoQXJyYXkuaXNBcnJheShuKSkge1xuICAgIGZvciAobGV0IHQgPSAwLCByID0gbi5sZW5ndGg7IHQgPCByOyB0KyspXG4gICAgICBpZiAoUHQoblt0XSkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgaWYgKFluKG4pKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKG4udG9KU09OICYmIHR5cGVvZiBuLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgYXJndW1lbnRzLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gUHQobi50b0pTT04oKSwgITApO1xuICBmb3IgKGNvbnN0IHQgaW4gbilcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG4sIHQpICYmIFB0KG5bdF0pKVxuICAgICAgcmV0dXJuICEwO1xuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBiYShuKSB7XG4gIGNvbnN0IGUgPSBbXSwgdCA9IG4uZGF0YSwgciA9IG47XG4gIHJldHVybiByLmRhdGEgPSBMbih0LCBlKSwgci5hdHRhY2htZW50cyA9IGUubGVuZ3RoLCB7IHBhY2tldDogciwgYnVmZmVyczogZSB9O1xufVxuZnVuY3Rpb24gTG4obiwgZSkge1xuICBpZiAoIW4pXG4gICAgcmV0dXJuIG47XG4gIGlmIChZbihuKSkge1xuICAgIGNvbnN0IHQgPSB7IF9wbGFjZWhvbGRlcjogITAsIG51bTogZS5sZW5ndGggfTtcbiAgICByZXR1cm4gZS5wdXNoKG4pLCB0O1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkobikpIHtcbiAgICBjb25zdCB0ID0gbmV3IEFycmF5KG4ubGVuZ3RoKTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IG4ubGVuZ3RoOyByKyspXG4gICAgICB0W3JdID0gTG4obltyXSwgZSk7XG4gICAgcmV0dXJuIHQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG4gPT0gXCJvYmplY3RcIiAmJiAhKG4gaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgIGNvbnN0IHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHIgaW4gbilcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCByKSAmJiAodFtyXSA9IExuKG5bcl0sIGUpKTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIHdhKG4sIGUpIHtcbiAgcmV0dXJuIG4uZGF0YSA9IE5uKG4uZGF0YSwgZSksIGRlbGV0ZSBuLmF0dGFjaG1lbnRzLCBuO1xufVxuZnVuY3Rpb24gTm4obiwgZSkge1xuICBpZiAoIW4pXG4gICAgcmV0dXJuIG47XG4gIGlmIChuICYmIG4uX3BsYWNlaG9sZGVyID09PSAhMCkge1xuICAgIGlmICh0eXBlb2Ygbi5udW0gPT0gXCJudW1iZXJcIiAmJiBuLm51bSA+PSAwICYmIG4ubnVtIDwgZS5sZW5ndGgpXG4gICAgICByZXR1cm4gZVtuLm51bV07XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBhdHRhY2htZW50c1wiKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG4pKVxuICAgIGZvciAobGV0IHQgPSAwOyB0IDwgbi5sZW5ndGg7IHQrKylcbiAgICAgIG5bdF0gPSBObihuW3RdLCBlKTtcbiAgZWxzZSBpZiAodHlwZW9mIG4gPT0gXCJvYmplY3RcIilcbiAgICBmb3IgKGNvbnN0IHQgaW4gbilcbiAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCB0KSAmJiAoblt0XSA9IE5uKG5bdF0sIGUpKTtcbiAgcmV0dXJuIG47XG59XG5jb25zdCBFYSA9IFtcbiAgXCJjb25uZWN0XCIsXG4gIFwiY29ubmVjdF9lcnJvclwiLFxuICBcImRpc2Nvbm5lY3RcIixcbiAgXCJkaXNjb25uZWN0aW5nXCIsXG4gIFwibmV3TGlzdGVuZXJcIixcbiAgXCJyZW1vdmVMaXN0ZW5lclwiXG5dLCBSYSA9IDU7XG52YXIgTztcbihmdW5jdGlvbihuKSB7XG4gIG5bbi5DT05ORUNUID0gMF0gPSBcIkNPTk5FQ1RcIiwgbltuLkRJU0NPTk5FQ1QgPSAxXSA9IFwiRElTQ09OTkVDVFwiLCBuW24uRVZFTlQgPSAyXSA9IFwiRVZFTlRcIiwgbltuLkFDSyA9IDNdID0gXCJBQ0tcIiwgbltuLkNPTk5FQ1RfRVJST1IgPSA0XSA9IFwiQ09OTkVDVF9FUlJPUlwiLCBuW24uQklOQVJZX0VWRU5UID0gNV0gPSBcIkJJTkFSWV9FVkVOVFwiLCBuW24uQklOQVJZX0FDSyA9IDZdID0gXCJCSU5BUllfQUNLXCI7XG59KShPIHx8IChPID0ge30pKTtcbmNsYXNzIFNhIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMucmVwbGFjZXIgPSBlO1xuICB9XG4gIGVuY29kZShlKSB7XG4gICAgcmV0dXJuIChlLnR5cGUgPT09IE8uRVZFTlQgfHwgZS50eXBlID09PSBPLkFDSykgJiYgUHQoZSkgPyB0aGlzLmVuY29kZUFzQmluYXJ5KHtcbiAgICAgIHR5cGU6IGUudHlwZSA9PT0gTy5FVkVOVCA/IE8uQklOQVJZX0VWRU5UIDogTy5CSU5BUllfQUNLLFxuICAgICAgbnNwOiBlLm5zcCxcbiAgICAgIGRhdGE6IGUuZGF0YSxcbiAgICAgIGlkOiBlLmlkXG4gICAgfSkgOiBbdGhpcy5lbmNvZGVBc1N0cmluZyhlKV07XG4gIH1cbiAgZW5jb2RlQXNTdHJpbmcoZSkge1xuICAgIGxldCB0ID0gXCJcIiArIGUudHlwZTtcbiAgICByZXR1cm4gKGUudHlwZSA9PT0gTy5CSU5BUllfRVZFTlQgfHwgZS50eXBlID09PSBPLkJJTkFSWV9BQ0spICYmICh0ICs9IGUuYXR0YWNobWVudHMgKyBcIi1cIiksIGUubnNwICYmIGUubnNwICE9PSBcIi9cIiAmJiAodCArPSBlLm5zcCArIFwiLFwiKSwgZS5pZCAhPSBudWxsICYmICh0ICs9IGUuaWQpLCBlLmRhdGEgIT0gbnVsbCAmJiAodCArPSBKU09OLnN0cmluZ2lmeShlLmRhdGEsIHRoaXMucmVwbGFjZXIpKSwgdDtcbiAgfVxuICBlbmNvZGVBc0JpbmFyeShlKSB7XG4gICAgY29uc3QgdCA9IGJhKGUpLCByID0gdGhpcy5lbmNvZGVBc1N0cmluZyh0LnBhY2tldCksIHMgPSB0LmJ1ZmZlcnM7XG4gICAgcmV0dXJuIHMudW5zaGlmdChyKSwgcztcbiAgfVxufVxuZnVuY3Rpb24gSHIobikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG4pID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuY2xhc3Mgem4gZXh0ZW5kcyBLIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCksIHRoaXMucmV2aXZlciA9IGU7XG4gIH1cbiAgYWRkKGUpIHtcbiAgICBsZXQgdDtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3RvcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ290IHBsYWludGV4dCBkYXRhIHdoZW4gcmVjb25zdHJ1Y3RpbmcgYSBwYWNrZXRcIik7XG4gICAgICB0ID0gdGhpcy5kZWNvZGVTdHJpbmcoZSk7XG4gICAgICBjb25zdCByID0gdC50eXBlID09PSBPLkJJTkFSWV9FVkVOVDtcbiAgICAgIHIgfHwgdC50eXBlID09PSBPLkJJTkFSWV9BQ0sgPyAodC50eXBlID0gciA/IE8uRVZFTlQgOiBPLkFDSywgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IFRhKHQpLCB0LmF0dGFjaG1lbnRzID09PSAwICYmIHN1cGVyLmVtaXRSZXNlcnZlZChcImRlY29kZWRcIiwgdCkpIDogc3VwZXIuZW1pdFJlc2VydmVkKFwiZGVjb2RlZFwiLCB0KTtcbiAgICB9IGVsc2UgaWYgKFluKGUpIHx8IGUuYmFzZTY0KVxuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3RvcilcbiAgICAgICAgdCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShlKSwgdCAmJiAodGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbCwgc3VwZXIuZW1pdFJlc2VydmVkKFwiZGVjb2RlZFwiLCB0KSk7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImdvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldFwiKTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGU6IFwiICsgZSk7XG4gIH1cbiAgZGVjb2RlU3RyaW5nKGUpIHtcbiAgICBsZXQgdCA9IDA7XG4gICAgY29uc3QgciA9IHtcbiAgICAgIHR5cGU6IE51bWJlcihlLmNoYXJBdCgwKSlcbiAgICB9O1xuICAgIGlmIChPW3IudHlwZV0gPT09IHZvaWQgMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gcGFja2V0IHR5cGUgXCIgKyByLnR5cGUpO1xuICAgIGlmIChyLnR5cGUgPT09IE8uQklOQVJZX0VWRU5UIHx8IHIudHlwZSA9PT0gTy5CSU5BUllfQUNLKSB7XG4gICAgICBjb25zdCBpID0gdCArIDE7XG4gICAgICBmb3IgKDsgZS5jaGFyQXQoKyt0KSAhPT0gXCItXCIgJiYgdCAhPSBlLmxlbmd0aDsgKVxuICAgICAgICA7XG4gICAgICBjb25zdCBvID0gZS5zdWJzdHJpbmcoaSwgdCk7XG4gICAgICBpZiAobyAhPSBOdW1iZXIobykgfHwgZS5jaGFyQXQodCkgIT09IFwiLVwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGF0dGFjaG1lbnRzXCIpO1xuICAgICAgci5hdHRhY2htZW50cyA9IE51bWJlcihvKTtcbiAgICB9XG4gICAgaWYgKGUuY2hhckF0KHQgKyAxKSA9PT0gXCIvXCIpIHtcbiAgICAgIGNvbnN0IGkgPSB0ICsgMTtcbiAgICAgIGZvciAoOyArK3QgJiYgIShlLmNoYXJBdCh0KSA9PT0gXCIsXCIgfHwgdCA9PT0gZS5sZW5ndGgpOyApXG4gICAgICAgIDtcbiAgICAgIHIubnNwID0gZS5zdWJzdHJpbmcoaSwgdCk7XG4gICAgfSBlbHNlXG4gICAgICByLm5zcCA9IFwiL1wiO1xuICAgIGNvbnN0IHMgPSBlLmNoYXJBdCh0ICsgMSk7XG4gICAgaWYgKHMgIT09IFwiXCIgJiYgTnVtYmVyKHMpID09IHMpIHtcbiAgICAgIGNvbnN0IGkgPSB0ICsgMTtcbiAgICAgIGZvciAoOyArK3Q7ICkge1xuICAgICAgICBjb25zdCBvID0gZS5jaGFyQXQodCk7XG4gICAgICAgIGlmIChvID09IG51bGwgfHwgTnVtYmVyKG8pICE9IG8pIHtcbiAgICAgICAgICAtLXQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQgPT09IGUubGVuZ3RoKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgci5pZCA9IE51bWJlcihlLnN1YnN0cmluZyhpLCB0ICsgMSkpO1xuICAgIH1cbiAgICBpZiAoZS5jaGFyQXQoKyt0KSkge1xuICAgICAgY29uc3QgaSA9IHRoaXMudHJ5UGFyc2UoZS5zdWJzdHIodCkpO1xuICAgICAgaWYgKHpuLmlzUGF5bG9hZFZhbGlkKHIudHlwZSwgaSkpXG4gICAgICAgIHIuZGF0YSA9IGk7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF5bG9hZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdHJ5UGFyc2UoZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShlLCB0aGlzLnJldml2ZXIpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgaXNQYXlsb2FkVmFsaWQoZSwgdCkge1xuICAgIHN3aXRjaCAoZSkge1xuICAgICAgY2FzZSBPLkNPTk5FQ1Q6XG4gICAgICAgIHJldHVybiBIcih0KTtcbiAgICAgIGNhc2UgTy5ESVNDT05ORUNUOlxuICAgICAgICByZXR1cm4gdCA9PT0gdm9pZCAwO1xuICAgICAgY2FzZSBPLkNPTk5FQ1RfRVJST1I6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdCA9PSBcInN0cmluZ1wiIHx8IEhyKHQpO1xuICAgICAgY2FzZSBPLkVWRU5UOlxuICAgICAgY2FzZSBPLkJJTkFSWV9FVkVOVDpcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodCkgJiYgKHR5cGVvZiB0WzBdID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHRbMF0gPT0gXCJzdHJpbmdcIiAmJiBFYS5pbmRleE9mKHRbMF0pID09PSAtMSk7XG4gICAgICBjYXNlIE8uQUNLOlxuICAgICAgY2FzZSBPLkJJTkFSWV9BQ0s6XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHQpO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMucmVjb25zdHJ1Y3RvciAmJiAodGhpcy5yZWNvbnN0cnVjdG9yLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKSwgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbCk7XG4gIH1cbn1cbmNsYXNzIFRhIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMucGFja2V0ID0gZSwgdGhpcy5idWZmZXJzID0gW10sIHRoaXMucmVjb25QYWNrID0gZTtcbiAgfVxuICB0YWtlQmluYXJ5RGF0YShlKSB7XG4gICAgaWYgKHRoaXMuYnVmZmVycy5wdXNoKGUpLCB0aGlzLmJ1ZmZlcnMubGVuZ3RoID09PSB0aGlzLnJlY29uUGFjay5hdHRhY2htZW50cykge1xuICAgICAgY29uc3QgdCA9IHdhKHRoaXMucmVjb25QYWNrLCB0aGlzLmJ1ZmZlcnMpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpLCB0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmaW5pc2hlZFJlY29uc3RydWN0aW9uKCkge1xuICAgIHRoaXMucmVjb25QYWNrID0gbnVsbCwgdGhpcy5idWZmZXJzID0gW107XG4gIH1cbn1cbmNvbnN0IE9hID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgcHJvdG9jb2w6IFJhLFxuICBnZXQgUGFja2V0VHlwZSgpIHtcbiAgICByZXR1cm4gTztcbiAgfSxcbiAgRW5jb2RlcjogU2EsXG4gIERlY29kZXI6IHpuXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpO1xuZnVuY3Rpb24gcGUobiwgZSwgdCkge1xuICByZXR1cm4gbi5vbihlLCB0KSwgZnVuY3Rpb24oKSB7XG4gICAgbi5vZmYoZSwgdCk7XG4gIH07XG59XG5jb25zdCB4YSA9IE9iamVjdC5mcmVlemUoe1xuICBjb25uZWN0OiAxLFxuICBjb25uZWN0X2Vycm9yOiAxLFxuICBkaXNjb25uZWN0OiAxLFxuICBkaXNjb25uZWN0aW5nOiAxLFxuICBuZXdMaXN0ZW5lcjogMSxcbiAgcmVtb3ZlTGlzdGVuZXI6IDFcbn0pO1xuY2xhc3MgTnMgZXh0ZW5kcyBLIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcikge1xuICAgIHN1cGVyKCksIHRoaXMuY29ubmVjdGVkID0gITEsIHRoaXMucmVjb3ZlcmVkID0gITEsIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdLCB0aGlzLnNlbmRCdWZmZXIgPSBbXSwgdGhpcy5fcXVldWUgPSBbXSwgdGhpcy5fcXVldWVTZXEgPSAwLCB0aGlzLmlkcyA9IDAsIHRoaXMuYWNrcyA9IHt9LCB0aGlzLmZsYWdzID0ge30sIHRoaXMuaW8gPSBlLCB0aGlzLm5zcCA9IHQsIHIgJiYgci5hdXRoICYmICh0aGlzLmF1dGggPSByLmF1dGgpLCB0aGlzLl9vcHRzID0gT2JqZWN0LmFzc2lnbih7fSwgciksIHRoaXMuaW8uX2F1dG9Db25uZWN0ICYmIHRoaXMub3BlbigpO1xuICB9XG4gIGdldCBkaXNjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuICF0aGlzLmNvbm5lY3RlZDtcbiAgfVxuICBzdWJFdmVudHMoKSB7XG4gICAgaWYgKHRoaXMuc3VicylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5pbztcbiAgICB0aGlzLnN1YnMgPSBbXG4gICAgICBwZShlLCBcIm9wZW5cIiwgdGhpcy5vbm9wZW4uYmluZCh0aGlzKSksXG4gICAgICBwZShlLCBcInBhY2tldFwiLCB0aGlzLm9ucGFja2V0LmJpbmQodGhpcykpLFxuICAgICAgcGUoZSwgXCJlcnJvclwiLCB0aGlzLm9uZXJyb3IuYmluZCh0aGlzKSksXG4gICAgICBwZShlLCBcImNsb3NlXCIsIHRoaXMub25jbG9zZS5iaW5kKHRoaXMpKVxuICAgIF07XG4gIH1cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLnN1YnM7XG4gIH1cbiAgY29ubmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0ZWQgPyB0aGlzIDogKHRoaXMuc3ViRXZlbnRzKCksIHRoaXMuaW8uX3JlY29ubmVjdGluZyB8fCB0aGlzLmlvLm9wZW4oKSwgdGhpcy5pby5fcmVhZHlTdGF0ZSA9PT0gXCJvcGVuXCIgJiYgdGhpcy5vbm9wZW4oKSwgdGhpcyk7XG4gIH1cbiAgb3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0KCk7XG4gIH1cbiAgc2VuZCguLi5lKSB7XG4gICAgcmV0dXJuIGUudW5zaGlmdChcIm1lc3NhZ2VcIiksIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBlKSwgdGhpcztcbiAgfVxuICBlbWl0KGUsIC4uLnQpIHtcbiAgICBpZiAoeGEuaGFzT3duUHJvcGVydHkoZSkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGUudG9TdHJpbmcoKSArICdcIiBpcyBhIHJlc2VydmVkIGV2ZW50IG5hbWUnKTtcbiAgICBpZiAodC51bnNoaWZ0KGUpLCB0aGlzLl9vcHRzLnJldHJpZXMgJiYgIXRoaXMuZmxhZ3MuZnJvbVF1ZXVlICYmICF0aGlzLmZsYWdzLnZvbGF0aWxlKVxuICAgICAgcmV0dXJuIHRoaXMuX2FkZFRvUXVldWUodCksIHRoaXM7XG4gICAgY29uc3QgciA9IHtcbiAgICAgIHR5cGU6IE8uRVZFTlQsXG4gICAgICBkYXRhOiB0XG4gICAgfTtcbiAgICBpZiAoci5vcHRpb25zID0ge30sIHIub3B0aW9ucy5jb21wcmVzcyA9IHRoaXMuZmxhZ3MuY29tcHJlc3MgIT09ICExLCB0eXBlb2YgdFt0Lmxlbmd0aCAtIDFdID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3QgbyA9IHRoaXMuaWRzKyssIHUgPSB0LnBvcCgpO1xuICAgICAgdGhpcy5fcmVnaXN0ZXJBY2tDYWxsYmFjayhvLCB1KSwgci5pZCA9IG87XG4gICAgfVxuICAgIGNvbnN0IHMgPSB0aGlzLmlvLmVuZ2luZSAmJiB0aGlzLmlvLmVuZ2luZS50cmFuc3BvcnQgJiYgdGhpcy5pby5lbmdpbmUudHJhbnNwb3J0LndyaXRhYmxlO1xuICAgIHJldHVybiB0aGlzLmZsYWdzLnZvbGF0aWxlICYmICghcyB8fCAhdGhpcy5jb25uZWN0ZWQpIHx8ICh0aGlzLmNvbm5lY3RlZCA/ICh0aGlzLm5vdGlmeU91dGdvaW5nTGlzdGVuZXJzKHIpLCB0aGlzLnBhY2tldChyKSkgOiB0aGlzLnNlbmRCdWZmZXIucHVzaChyKSksIHRoaXMuZmxhZ3MgPSB7fSwgdGhpcztcbiAgfVxuICBfcmVnaXN0ZXJBY2tDYWxsYmFjayhlLCB0KSB7XG4gICAgdmFyIHI7XG4gICAgY29uc3QgcyA9IChyID0gdGhpcy5mbGFncy50aW1lb3V0KSAhPT0gbnVsbCAmJiByICE9PSB2b2lkIDAgPyByIDogdGhpcy5fb3B0cy5hY2tUaW1lb3V0O1xuICAgIGlmIChzID09PSB2b2lkIDApIHtcbiAgICAgIHRoaXMuYWNrc1tlXSA9IHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSB0aGlzLmlvLnNldFRpbWVvdXRGbigoKSA9PiB7XG4gICAgICBkZWxldGUgdGhpcy5hY2tzW2VdO1xuICAgICAgZm9yIChsZXQgbyA9IDA7IG8gPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBvKyspXG4gICAgICAgIHRoaXMuc2VuZEJ1ZmZlcltvXS5pZCA9PT0gZSAmJiB0aGlzLnNlbmRCdWZmZXIuc3BsaWNlKG8sIDEpO1xuICAgICAgdC5jYWxsKHRoaXMsIG5ldyBFcnJvcihcIm9wZXJhdGlvbiBoYXMgdGltZWQgb3V0XCIpKTtcbiAgICB9LCBzKTtcbiAgICB0aGlzLmFja3NbZV0gPSAoLi4ubykgPT4ge1xuICAgICAgdGhpcy5pby5jbGVhclRpbWVvdXRGbihpKSwgdC5hcHBseSh0aGlzLCBbbnVsbCwgLi4ub10pO1xuICAgIH07XG4gIH1cbiAgZW1pdFdpdGhBY2soZSwgLi4udCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLmZsYWdzLnRpbWVvdXQgIT09IHZvaWQgMCB8fCB0aGlzLl9vcHRzLmFja1RpbWVvdXQgIT09IHZvaWQgMDtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHMsIGkpID0+IHtcbiAgICAgIHQucHVzaCgobywgdSkgPT4gciA/IG8gPyBpKG8pIDogcyh1KSA6IHMobykpLCB0aGlzLmVtaXQoZSwgLi4udCk7XG4gICAgfSk7XG4gIH1cbiAgX2FkZFRvUXVldWUoZSkge1xuICAgIGxldCB0O1xuICAgIHR5cGVvZiBlW2UubGVuZ3RoIC0gMV0gPT0gXCJmdW5jdGlvblwiICYmICh0ID0gZS5wb3AoKSk7XG4gICAgY29uc3QgciA9IHtcbiAgICAgIGlkOiB0aGlzLl9xdWV1ZVNlcSsrLFxuICAgICAgdHJ5Q291bnQ6IDAsXG4gICAgICBwZW5kaW5nOiAhMSxcbiAgICAgIGFyZ3M6IGUsXG4gICAgICBmbGFnczogT2JqZWN0LmFzc2lnbih7IGZyb21RdWV1ZTogITAgfSwgdGhpcy5mbGFncylcbiAgICB9O1xuICAgIGUucHVzaCgocywgLi4uaSkgPT4gciAhPT0gdGhpcy5fcXVldWVbMF0gPyB2b2lkIDAgOiAocyAhPT0gbnVsbCA/IHIudHJ5Q291bnQgPiB0aGlzLl9vcHRzLnJldHJpZXMgJiYgKHRoaXMuX3F1ZXVlLnNoaWZ0KCksIHQgJiYgdChzKSkgOiAodGhpcy5fcXVldWUuc2hpZnQoKSwgdCAmJiB0KG51bGwsIC4uLmkpKSwgci5wZW5kaW5nID0gITEsIHRoaXMuX2RyYWluUXVldWUoKSkpLCB0aGlzLl9xdWV1ZS5wdXNoKHIpLCB0aGlzLl9kcmFpblF1ZXVlKCk7XG4gIH1cbiAgX2RyYWluUXVldWUoZSA9ICExKSB7XG4gICAgaWYgKCF0aGlzLmNvbm5lY3RlZCB8fCB0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMuX3F1ZXVlWzBdO1xuICAgIHQucGVuZGluZyAmJiAhZSB8fCAodC5wZW5kaW5nID0gITAsIHQudHJ5Q291bnQrKywgdGhpcy5mbGFncyA9IHQuZmxhZ3MsIHRoaXMuZW1pdC5hcHBseSh0aGlzLCB0LmFyZ3MpKTtcbiAgfVxuICBwYWNrZXQoZSkge1xuICAgIGUubnNwID0gdGhpcy5uc3AsIHRoaXMuaW8uX3BhY2tldChlKTtcbiAgfVxuICBvbm9wZW4oKSB7XG4gICAgdHlwZW9mIHRoaXMuYXV0aCA9PSBcImZ1bmN0aW9uXCIgPyB0aGlzLmF1dGgoKGUpID0+IHtcbiAgICAgIHRoaXMuX3NlbmRDb25uZWN0UGFja2V0KGUpO1xuICAgIH0pIDogdGhpcy5fc2VuZENvbm5lY3RQYWNrZXQodGhpcy5hdXRoKTtcbiAgfVxuICBfc2VuZENvbm5lY3RQYWNrZXQoZSkge1xuICAgIHRoaXMucGFja2V0KHtcbiAgICAgIHR5cGU6IE8uQ09OTkVDVCxcbiAgICAgIGRhdGE6IHRoaXMuX3BpZCA/IE9iamVjdC5hc3NpZ24oeyBwaWQ6IHRoaXMuX3BpZCwgb2Zmc2V0OiB0aGlzLl9sYXN0T2Zmc2V0IH0sIGUpIDogZVxuICAgIH0pO1xuICB9XG4gIG9uZXJyb3IoZSkge1xuICAgIHRoaXMuY29ubmVjdGVkIHx8IHRoaXMuZW1pdFJlc2VydmVkKFwiY29ubmVjdF9lcnJvclwiLCBlKTtcbiAgfVxuICBvbmNsb3NlKGUsIHQpIHtcbiAgICB0aGlzLmNvbm5lY3RlZCA9ICExLCBkZWxldGUgdGhpcy5pZCwgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJkaXNjb25uZWN0XCIsIGUsIHQpO1xuICB9XG4gIG9ucGFja2V0KGUpIHtcbiAgICBpZiAoZS5uc3AgPT09IHRoaXMubnNwKVxuICAgICAgc3dpdGNoIChlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBPLkNPTk5FQ1Q6XG4gICAgICAgICAgZS5kYXRhICYmIGUuZGF0YS5zaWQgPyB0aGlzLm9uY29ubmVjdChlLmRhdGEuc2lkLCBlLmRhdGEucGlkKSA6IHRoaXMuZW1pdFJlc2VydmVkKFwiY29ubmVjdF9lcnJvclwiLCBuZXcgRXJyb3IoXCJJdCBzZWVtcyB5b3UgYXJlIHRyeWluZyB0byByZWFjaCBhIFNvY2tldC5JTyBzZXJ2ZXIgaW4gdjIueCB3aXRoIGEgdjMueCBjbGllbnQsIGJ1dCB0aGV5IGFyZSBub3QgY29tcGF0aWJsZSAobW9yZSBpbmZvcm1hdGlvbiBoZXJlOiBodHRwczovL3NvY2tldC5pby9kb2NzL3YzL21pZ3JhdGluZy1mcm9tLTIteC10by0zLTAvKVwiKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTy5FVkVOVDpcbiAgICAgICAgY2FzZSBPLkJJTkFSWV9FVkVOVDpcbiAgICAgICAgICB0aGlzLm9uZXZlbnQoZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTy5BQ0s6XG4gICAgICAgIGNhc2UgTy5CSU5BUllfQUNLOlxuICAgICAgICAgIHRoaXMub25hY2soZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTy5ESVNDT05ORUNUOlxuICAgICAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgTy5DT05ORUNUX0VSUk9SOlxuICAgICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAgIGNvbnN0IHIgPSBuZXcgRXJyb3IoZS5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgIHIuZGF0YSA9IGUuZGF0YS5kYXRhLCB0aGlzLmVtaXRSZXNlcnZlZChcImNvbm5lY3RfZXJyb3JcIiwgcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbiAgb25ldmVudChlKSB7XG4gICAgY29uc3QgdCA9IGUuZGF0YSB8fCBbXTtcbiAgICBlLmlkICE9IG51bGwgJiYgdC5wdXNoKHRoaXMuYWNrKGUuaWQpKSwgdGhpcy5jb25uZWN0ZWQgPyB0aGlzLmVtaXRFdmVudCh0KSA6IHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKE9iamVjdC5mcmVlemUodCkpO1xuICB9XG4gIGVtaXRFdmVudChlKSB7XG4gICAgaWYgKHRoaXMuX2FueUxpc3RlbmVycyAmJiB0aGlzLl9hbnlMaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5fYW55TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgICBmb3IgKGNvbnN0IHIgb2YgdClcbiAgICAgICAgci5hcHBseSh0aGlzLCBlKTtcbiAgICB9XG4gICAgc3VwZXIuZW1pdC5hcHBseSh0aGlzLCBlKSwgdGhpcy5fcGlkICYmIGUubGVuZ3RoICYmIHR5cGVvZiBlW2UubGVuZ3RoIC0gMV0gPT0gXCJzdHJpbmdcIiAmJiAodGhpcy5fbGFzdE9mZnNldCA9IGVbZS5sZW5ndGggLSAxXSk7XG4gIH1cbiAgYWNrKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcztcbiAgICBsZXQgciA9ICExO1xuICAgIHJldHVybiBmdW5jdGlvbiguLi5zKSB7XG4gICAgICByIHx8IChyID0gITAsIHQucGFja2V0KHtcbiAgICAgICAgdHlwZTogTy5BQ0ssXG4gICAgICAgIGlkOiBlLFxuICAgICAgICBkYXRhOiBzXG4gICAgICB9KSk7XG4gICAgfTtcbiAgfVxuICBvbmFjayhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuYWNrc1tlLmlkXTtcbiAgICB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgJiYgKHQuYXBwbHkodGhpcywgZS5kYXRhKSwgZGVsZXRlIHRoaXMuYWNrc1tlLmlkXSk7XG4gIH1cbiAgb25jb25uZWN0KGUsIHQpIHtcbiAgICB0aGlzLmlkID0gZSwgdGhpcy5yZWNvdmVyZWQgPSB0ICYmIHRoaXMuX3BpZCA9PT0gdCwgdGhpcy5fcGlkID0gdCwgdGhpcy5jb25uZWN0ZWQgPSAhMCwgdGhpcy5lbWl0QnVmZmVyZWQoKSwgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJjb25uZWN0XCIpLCB0aGlzLl9kcmFpblF1ZXVlKCEwKTtcbiAgfVxuICBlbWl0QnVmZmVyZWQoKSB7XG4gICAgdGhpcy5yZWNlaXZlQnVmZmVyLmZvckVhY2goKGUpID0+IHRoaXMuZW1pdEV2ZW50KGUpKSwgdGhpcy5yZWNlaXZlQnVmZmVyID0gW10sIHRoaXMuc2VuZEJ1ZmZlci5mb3JFYWNoKChlKSA9PiB7XG4gICAgICB0aGlzLm5vdGlmeU91dGdvaW5nTGlzdGVuZXJzKGUpLCB0aGlzLnBhY2tldChlKTtcbiAgICB9KSwgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIH1cbiAgb25kaXNjb25uZWN0KCkge1xuICAgIHRoaXMuZGVzdHJveSgpLCB0aGlzLm9uY2xvc2UoXCJpbyBzZXJ2ZXIgZGlzY29ubmVjdFwiKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc3VicyAmJiAodGhpcy5zdWJzLmZvckVhY2goKGUpID0+IGUoKSksIHRoaXMuc3VicyA9IHZvaWQgMCksIHRoaXMuaW8uX2Rlc3Ryb3kodGhpcyk7XG4gIH1cbiAgZGlzY29ubmVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0ZWQgJiYgdGhpcy5wYWNrZXQoeyB0eXBlOiBPLkRJU0NPTk5FQ1QgfSksIHRoaXMuZGVzdHJveSgpLCB0aGlzLmNvbm5lY3RlZCAmJiB0aGlzLm9uY2xvc2UoXCJpbyBjbGllbnQgZGlzY29ubmVjdFwiKSwgdGhpcztcbiAgfVxuICBjbG9zZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNjb25uZWN0KCk7XG4gIH1cbiAgY29tcHJlc3MoZSkge1xuICAgIHJldHVybiB0aGlzLmZsYWdzLmNvbXByZXNzID0gZSwgdGhpcztcbiAgfVxuICBnZXQgdm9sYXRpbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhZ3Mudm9sYXRpbGUgPSAhMCwgdGhpcztcbiAgfVxuICB0aW1lb3V0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5mbGFncy50aW1lb3V0ID0gZSwgdGhpcztcbiAgfVxuICBvbkFueShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FueUxpc3RlbmVycyA9IHRoaXMuX2FueUxpc3RlbmVycyB8fCBbXSwgdGhpcy5fYW55TGlzdGVuZXJzLnB1c2goZSksIHRoaXM7XG4gIH1cbiAgcHJlcGVuZEFueShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FueUxpc3RlbmVycyA9IHRoaXMuX2FueUxpc3RlbmVycyB8fCBbXSwgdGhpcy5fYW55TGlzdGVuZXJzLnVuc2hpZnQoZSksIHRoaXM7XG4gIH1cbiAgb2ZmQW55KGUpIHtcbiAgICBpZiAoIXRoaXMuX2FueUxpc3RlbmVycylcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIGlmIChlKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5fYW55TGlzdGVuZXJzO1xuICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKVxuICAgICAgICBpZiAoZSA9PT0gdFtyXSlcbiAgICAgICAgICByZXR1cm4gdC5zcGxpY2UociwgMSksIHRoaXM7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaXN0ZW5lcnNBbnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FueUxpc3RlbmVycyB8fCBbXTtcbiAgfVxuICBvbkFueU91dGdvaW5nKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMgPSB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyB8fCBbXSwgdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMucHVzaChlKSwgdGhpcztcbiAgfVxuICBwcmVwZW5kQW55T3V0Z29pbmcoZSkge1xuICAgIHJldHVybiB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyA9IHRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzIHx8IFtdLCB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy51bnNoaWZ0KGUpLCB0aGlzO1xuICB9XG4gIG9mZkFueU91dGdvaW5nKGUpIHtcbiAgICBpZiAoIXRoaXMuX2FueU91dGdvaW5nTGlzdGVuZXJzKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKGUpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycztcbiAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKylcbiAgICAgICAgaWYgKGUgPT09IHRbcl0pXG4gICAgICAgICAgcmV0dXJuIHQuc3BsaWNlKHIsIDEpLCB0aGlzO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBsaXN0ZW5lcnNBbnlPdXRnb2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5fYW55T3V0Z29pbmdMaXN0ZW5lcnMgfHwgW107XG4gIH1cbiAgbm90aWZ5T3V0Z29pbmdMaXN0ZW5lcnMoZSkge1xuICAgIGlmICh0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycyAmJiB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLl9hbnlPdXRnb2luZ0xpc3RlbmVycy5zbGljZSgpO1xuICAgICAgZm9yIChjb25zdCByIG9mIHQpXG4gICAgICAgIHIuYXBwbHkodGhpcywgZS5kYXRhKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIFhlKG4pIHtcbiAgbiA9IG4gfHwge30sIHRoaXMubXMgPSBuLm1pbiB8fCAxMDAsIHRoaXMubWF4ID0gbi5tYXggfHwgMWU0LCB0aGlzLmZhY3RvciA9IG4uZmFjdG9yIHx8IDIsIHRoaXMuaml0dGVyID0gbi5qaXR0ZXIgPiAwICYmIG4uaml0dGVyIDw9IDEgPyBuLmppdHRlciA6IDAsIHRoaXMuYXR0ZW1wdHMgPSAwO1xufVxuWGUucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHZhciBuID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICB2YXIgZSA9IE1hdGgucmFuZG9tKCksIHQgPSBNYXRoLmZsb29yKGUgKiB0aGlzLmppdHRlciAqIG4pO1xuICAgIG4gPSAoTWF0aC5mbG9vcihlICogMTApICYgMSkgPT0gMCA/IG4gLSB0IDogbiArIHQ7XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKG4sIHRoaXMubWF4KSB8IDA7XG59O1xuWGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufTtcblhlLnByb3RvdHlwZS5zZXRNaW4gPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMubXMgPSBuO1xufTtcblhlLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbihuKSB7XG4gIHRoaXMubWF4ID0gbjtcbn07XG5YZS5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24obikge1xuICB0aGlzLmppdHRlciA9IG47XG59O1xuY2xhc3MgUG4gZXh0ZW5kcyBLIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHZhciByO1xuICAgIHN1cGVyKCksIHRoaXMubnNwcyA9IHt9LCB0aGlzLnN1YnMgPSBbXSwgZSAmJiB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmICh0ID0gZSwgZSA9IHZvaWQgMCksIHQgPSB0IHx8IHt9LCB0LnBhdGggPSB0LnBhdGggfHwgXCIvc29ja2V0LmlvXCIsIHRoaXMub3B0cyA9IHQsIE10KHRoaXMsIHQpLCB0aGlzLnJlY29ubmVjdGlvbih0LnJlY29ubmVjdGlvbiAhPT0gITEpLCB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKHQucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgMSAvIDApLCB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KHQucmVjb25uZWN0aW9uRGVsYXkgfHwgMWUzKSwgdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heCh0LnJlY29ubmVjdGlvbkRlbGF5TWF4IHx8IDVlMyksIHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigociA9IHQucmFuZG9taXphdGlvbkZhY3RvcikgIT09IG51bGwgJiYgciAhPT0gdm9pZCAwID8gciA6IDAuNSksIHRoaXMuYmFja29mZiA9IG5ldyBYZSh7XG4gICAgICBtaW46IHRoaXMucmVjb25uZWN0aW9uRGVsYXkoKSxcbiAgICAgIG1heDogdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heCgpLFxuICAgICAgaml0dGVyOiB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3IoKVxuICAgIH0pLCB0aGlzLnRpbWVvdXQodC50aW1lb3V0ID09IG51bGwgPyAyZTQgOiB0LnRpbWVvdXQpLCB0aGlzLl9yZWFkeVN0YXRlID0gXCJjbG9zZWRcIiwgdGhpcy51cmkgPSBlO1xuICAgIGNvbnN0IHMgPSB0LnBhcnNlciB8fCBPYTtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgcy5FbmNvZGVyKCksIHRoaXMuZGVjb2RlciA9IG5ldyBzLkRlY29kZXIoKSwgdGhpcy5fYXV0b0Nvbm5lY3QgPSB0LmF1dG9Db25uZWN0ICE9PSAhMSwgdGhpcy5fYXV0b0Nvbm5lY3QgJiYgdGhpcy5vcGVuKCk7XG4gIH1cbiAgcmVjb25uZWN0aW9uKGUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIWUsIHRoaXMpIDogdGhpcy5fcmVjb25uZWN0aW9uO1xuICB9XG4gIHJlY29ubmVjdGlvbkF0dGVtcHRzKGUpIHtcbiAgICByZXR1cm4gZSA9PT0gdm9pZCAwID8gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMgOiAodGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMgPSBlLCB0aGlzKTtcbiAgfVxuICByZWNvbm5lY3Rpb25EZWxheShlKSB7XG4gICAgdmFyIHQ7XG4gICAgcmV0dXJuIGUgPT09IHZvaWQgMCA/IHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5IDogKHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gZSwgKHQgPSB0aGlzLmJhY2tvZmYpID09PSBudWxsIHx8IHQgPT09IHZvaWQgMCB8fCB0LnNldE1pbihlKSwgdGhpcyk7XG4gIH1cbiAgcmFuZG9taXphdGlvbkZhY3RvcihlKSB7XG4gICAgdmFyIHQ7XG4gICAgcmV0dXJuIGUgPT09IHZvaWQgMCA/IHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3IgOiAodGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IGUsICh0ID0gdGhpcy5iYWNrb2ZmKSA9PT0gbnVsbCB8fCB0ID09PSB2b2lkIDAgfHwgdC5zZXRKaXR0ZXIoZSksIHRoaXMpO1xuICB9XG4gIHJlY29ubmVjdGlvbkRlbGF5TWF4KGUpIHtcbiAgICB2YXIgdDtcbiAgICByZXR1cm4gZSA9PT0gdm9pZCAwID8gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXggOiAodGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXggPSBlLCAodCA9IHRoaXMuYmFja29mZikgPT09IG51bGwgfHwgdCA9PT0gdm9pZCAwIHx8IHQuc2V0TWF4KGUpLCB0aGlzKTtcbiAgfVxuICB0aW1lb3V0KGUpIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLl90aW1lb3V0ID0gZSwgdGhpcykgOiB0aGlzLl90aW1lb3V0O1xuICB9XG4gIG1heWJlUmVjb25uZWN0T25PcGVuKCkge1xuICAgICF0aGlzLl9yZWNvbm5lY3RpbmcgJiYgdGhpcy5fcmVjb25uZWN0aW9uICYmIHRoaXMuYmFja29mZi5hdHRlbXB0cyA9PT0gMCAmJiB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG4gIG9wZW4oZSkge1xuICAgIGlmICh+dGhpcy5fcmVhZHlTdGF0ZS5pbmRleE9mKFwib3BlblwiKSlcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIHRoaXMuZW5naW5lID0gbmV3IENlKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICAgIGNvbnN0IHQgPSB0aGlzLmVuZ2luZSwgciA9IHRoaXM7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFwib3BlbmluZ1wiLCB0aGlzLnNraXBSZWNvbm5lY3QgPSAhMTtcbiAgICBjb25zdCBzID0gcGUodCwgXCJvcGVuXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgci5vbm9wZW4oKSwgZSAmJiBlKCk7XG4gICAgfSksIGkgPSAodSkgPT4ge1xuICAgICAgdGhpcy5jbGVhbnVwKCksIHRoaXMuX3JlYWR5U3RhdGUgPSBcImNsb3NlZFwiLCB0aGlzLmVtaXRSZXNlcnZlZChcImVycm9yXCIsIHUpLCBlID8gZSh1KSA6IHRoaXMubWF5YmVSZWNvbm5lY3RPbk9wZW4oKTtcbiAgICB9LCBvID0gcGUodCwgXCJlcnJvclwiLCBpKTtcbiAgICBpZiAodGhpcy5fdGltZW91dCAhPT0gITEpIHtcbiAgICAgIGNvbnN0IHUgPSB0aGlzLl90aW1lb3V0LCBsID0gdGhpcy5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICBzKCksIGkobmV3IEVycm9yKFwidGltZW91dFwiKSksIHQuY2xvc2UoKTtcbiAgICAgIH0sIHUpO1xuICAgICAgdGhpcy5vcHRzLmF1dG9VbnJlZiAmJiBsLnVucmVmKCksIHRoaXMuc3Vicy5wdXNoKCgpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXRGbihsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdWJzLnB1c2gocyksIHRoaXMuc3Vicy5wdXNoKG8pLCB0aGlzO1xuICB9XG4gIGNvbm5lY3QoZSkge1xuICAgIHJldHVybiB0aGlzLm9wZW4oZSk7XG4gIH1cbiAgb25vcGVuKCkge1xuICAgIHRoaXMuY2xlYW51cCgpLCB0aGlzLl9yZWFkeVN0YXRlID0gXCJvcGVuXCIsIHRoaXMuZW1pdFJlc2VydmVkKFwib3BlblwiKTtcbiAgICBjb25zdCBlID0gdGhpcy5lbmdpbmU7XG4gICAgdGhpcy5zdWJzLnB1c2gocGUoZSwgXCJwaW5nXCIsIHRoaXMub25waW5nLmJpbmQodGhpcykpLCBwZShlLCBcImRhdGFcIiwgdGhpcy5vbmRhdGEuYmluZCh0aGlzKSksIHBlKGUsIFwiZXJyb3JcIiwgdGhpcy5vbmVycm9yLmJpbmQodGhpcykpLCBwZShlLCBcImNsb3NlXCIsIHRoaXMub25jbG9zZS5iaW5kKHRoaXMpKSwgcGUodGhpcy5kZWNvZGVyLCBcImRlY29kZWRcIiwgdGhpcy5vbmRlY29kZWQuYmluZCh0aGlzKSkpO1xuICB9XG4gIG9ucGluZygpIHtcbiAgICB0aGlzLmVtaXRSZXNlcnZlZChcInBpbmdcIik7XG4gIH1cbiAgb25kYXRhKGUpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5kZWNvZGVyLmFkZChlKTtcbiAgICB9IGNhdGNoICh0KSB7XG4gICAgICB0aGlzLm9uY2xvc2UoXCJwYXJzZSBlcnJvclwiLCB0KTtcbiAgICB9XG4gIH1cbiAgb25kZWNvZGVkKGUpIHtcbiAgICBKbigoKSA9PiB7XG4gICAgICB0aGlzLmVtaXRSZXNlcnZlZChcInBhY2tldFwiLCBlKTtcbiAgICB9LCB0aGlzLnNldFRpbWVvdXRGbik7XG4gIH1cbiAgb25lcnJvcihlKSB7XG4gICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJlcnJvclwiLCBlKTtcbiAgfVxuICBzb2NrZXQoZSwgdCkge1xuICAgIGxldCByID0gdGhpcy5uc3BzW2VdO1xuICAgIHJldHVybiByID8gdGhpcy5fYXV0b0Nvbm5lY3QgJiYgIXIuYWN0aXZlICYmIHIuY29ubmVjdCgpIDogKHIgPSBuZXcgTnModGhpcywgZSwgdCksIHRoaXMubnNwc1tlXSA9IHIpLCByO1xuICB9XG4gIF9kZXN0cm95KGUpIHtcbiAgICBjb25zdCB0ID0gT2JqZWN0LmtleXModGhpcy5uc3BzKTtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdClcbiAgICAgIGlmICh0aGlzLm5zcHNbcl0uYWN0aXZlKVxuICAgICAgICByZXR1cm47XG4gICAgdGhpcy5fY2xvc2UoKTtcbiAgfVxuICBfcGFja2V0KGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5lbmNvZGVyLmVuY29kZShlKTtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IHQubGVuZ3RoOyByKyspXG4gICAgICB0aGlzLmVuZ2luZS53cml0ZSh0W3JdLCBlLm9wdGlvbnMpO1xuICB9XG4gIGNsZWFudXAoKSB7XG4gICAgdGhpcy5zdWJzLmZvckVhY2goKGUpID0+IGUoKSksIHRoaXMuc3Vicy5sZW5ndGggPSAwLCB0aGlzLmRlY29kZXIuZGVzdHJveSgpO1xuICB9XG4gIF9jbG9zZSgpIHtcbiAgICB0aGlzLnNraXBSZWNvbm5lY3QgPSAhMCwgdGhpcy5fcmVjb25uZWN0aW5nID0gITEsIHRoaXMub25jbG9zZShcImZvcmNlZCBjbG9zZVwiKSwgdGhpcy5lbmdpbmUgJiYgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbiAgfVxuICBkaXNjb25uZWN0KCkge1xuICAgIHJldHVybiB0aGlzLl9jbG9zZSgpO1xuICB9XG4gIG9uY2xvc2UoZSwgdCkge1xuICAgIHRoaXMuY2xlYW51cCgpLCB0aGlzLmJhY2tvZmYucmVzZXQoKSwgdGhpcy5fcmVhZHlTdGF0ZSA9IFwiY2xvc2VkXCIsIHRoaXMuZW1pdFJlc2VydmVkKFwiY2xvc2VcIiwgZSwgdCksIHRoaXMuX3JlY29ubmVjdGlvbiAmJiAhdGhpcy5za2lwUmVjb25uZWN0ICYmIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbiAgcmVjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLl9yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgZSA9IHRoaXM7XG4gICAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cylcbiAgICAgIHRoaXMuYmFja29mZi5yZXNldCgpLCB0aGlzLmVtaXRSZXNlcnZlZChcInJlY29ubmVjdF9mYWlsZWRcIiksIHRoaXMuX3JlY29ubmVjdGluZyA9ICExO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgdCA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuICAgICAgdGhpcy5fcmVjb25uZWN0aW5nID0gITA7XG4gICAgICBjb25zdCByID0gdGhpcy5zZXRUaW1lb3V0Rm4oKCkgPT4ge1xuICAgICAgICBlLnNraXBSZWNvbm5lY3QgfHwgKHRoaXMuZW1pdFJlc2VydmVkKFwicmVjb25uZWN0X2F0dGVtcHRcIiwgZS5iYWNrb2ZmLmF0dGVtcHRzKSwgIWUuc2tpcFJlY29ubmVjdCAmJiBlLm9wZW4oKHMpID0+IHtcbiAgICAgICAgICBzID8gKGUuX3JlY29ubmVjdGluZyA9ICExLCBlLnJlY29ubmVjdCgpLCB0aGlzLmVtaXRSZXNlcnZlZChcInJlY29ubmVjdF9lcnJvclwiLCBzKSkgOiBlLm9ucmVjb25uZWN0KCk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0sIHQpO1xuICAgICAgdGhpcy5vcHRzLmF1dG9VbnJlZiAmJiByLnVucmVmKCksIHRoaXMuc3Vicy5wdXNoKCgpID0+IHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXRGbihyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBvbnJlY29ubmVjdCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuICAgIHRoaXMuX3JlY29ubmVjdGluZyA9ICExLCB0aGlzLmJhY2tvZmYucmVzZXQoKSwgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJyZWNvbm5lY3RcIiwgZSk7XG4gIH1cbn1cbmNvbnN0IGl0ID0ge307XG5mdW5jdGlvbiBCdChuLCBlKSB7XG4gIHR5cGVvZiBuID09IFwib2JqZWN0XCIgJiYgKGUgPSBuLCBuID0gdm9pZCAwKSwgZSA9IGUgfHwge307XG4gIGNvbnN0IHQgPSB2YShuLCBlLnBhdGggfHwgXCIvc29ja2V0LmlvXCIpLCByID0gdC5zb3VyY2UsIHMgPSB0LmlkLCBpID0gdC5wYXRoLCBvID0gaXRbc10gJiYgaSBpbiBpdFtzXS5uc3BzLCB1ID0gZS5mb3JjZU5ldyB8fCBlW1wiZm9yY2UgbmV3IGNvbm5lY3Rpb25cIl0gfHwgZS5tdWx0aXBsZXggPT09ICExIHx8IG87XG4gIGxldCBsO1xuICByZXR1cm4gdSA/IGwgPSBuZXcgUG4ociwgZSkgOiAoaXRbc10gfHwgKGl0W3NdID0gbmV3IFBuKHIsIGUpKSwgbCA9IGl0W3NdKSwgdC5xdWVyeSAmJiAhZS5xdWVyeSAmJiAoZS5xdWVyeSA9IHQucXVlcnlLZXkpLCBsLnNvY2tldCh0LnBhdGgsIGUpO1xufVxuT2JqZWN0LmFzc2lnbihCdCwge1xuICBNYW5hZ2VyOiBQbixcbiAgU29ja2V0OiBOcyxcbiAgaW86IEJ0LFxuICBjb25uZWN0OiBCdFxufSk7XG5jbGFzcyBDYSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHIsIHMpIHtcbiAgICB4ZSh0aGlzLCBcInNvY2tldF9wb3J0XCIpO1xuICAgIHhlKHRoaXMsIFwiaG9zdFwiKTtcbiAgICB4ZSh0aGlzLCBcInBvcnRcIik7XG4gICAgeGUodGhpcywgXCJwcm90b2NvbFwiKTtcbiAgICB4ZSh0aGlzLCBcInVybFwiKTtcbiAgICB4ZSh0aGlzLCBcInNpdGVfbmFtZVwiKTtcbiAgICB4ZSh0aGlzLCBcInNvY2tldFwiKTtcbiAgICB2YXIgaSwgbztcbiAgICBpZiAodGhpcy5zb2NrZXRfcG9ydCA9IHIgIT0gbnVsbCA/IHIgOiBcIjkwMDBcIiwgdGhpcy5ob3N0ID0gKGkgPSB3aW5kb3cubG9jYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBpLmhvc3RuYW1lLCB0aGlzLnBvcnQgPSAobyA9IHdpbmRvdy5sb2NhdGlvbikgIT0gbnVsbCAmJiBvLnBvcnQgPyBgOiR7dGhpcy5zb2NrZXRfcG9ydH1gIDogXCJcIiwgdGhpcy5wcm90b2NvbCA9IHRoaXMucG9ydCA/IFwiaHR0cFwiIDogXCJodHRwc1wiLCBlKSB7XG4gICAgICBsZXQgdSA9IG5ldyBVUkwoZSk7XG4gICAgICB1LnBvcnQgPSBcIlwiLCByID8gKHUucG9ydCA9IHIsIHRoaXMudXJsID0gdS50b1N0cmluZygpKSA6IHRoaXMudXJsID0gdS50b1N0cmluZygpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy51cmwgPSBgJHt0aGlzLnByb3RvY29sfTovLyR7dGhpcy5ob3N0fSR7dGhpcy5wb3J0fS9gO1xuICAgIHQgJiYgKHRoaXMudXJsID0gYCR7dGhpcy51cmx9JHt0fWApLCB0aGlzLnNpdGVfbmFtZSA9IHQsIHRoaXMuc29ja2V0ID0gQnQoYCR7dGhpcy51cmx9YCwge1xuICAgICAgd2l0aENyZWRlbnRpYWxzOiAhMCxcbiAgICAgIHNlY3VyZTogdGhpcy5wcm90b2NvbCA9PT0gXCJodHRwc1wiLFxuICAgICAgZXh0cmFIZWFkZXJzOiBzICYmIHMudXNlVG9rZW4gPT09ICEwID8ge1xuICAgICAgICBBdXRob3JpemF0aW9uOiBgJHtzLnR5cGV9ICR7cy50b2tlbn1gXG4gICAgICB9IDoge31cbiAgICB9KTtcbiAgfVxufVxudmFyIFBzID0geyBleHBvcnRzOiB7fSB9LCBvdCA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIEpyO1xuZnVuY3Rpb24gQWEoKSB7XG4gIGlmIChKcilcbiAgICByZXR1cm4gb3Q7XG4gIEpyID0gMTtcbiAgdmFyIG4gPSBxZSwgZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLCB0ID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCByID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgcyA9IG4uX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXIsIGkgPSB7IGtleTogITAsIHJlZjogITAsIF9fc2VsZjogITAsIF9fc291cmNlOiAhMCB9O1xuICBmdW5jdGlvbiBvKHUsIGwsIGEpIHtcbiAgICB2YXIgaCwgZiA9IHt9LCBwID0gbnVsbCwgbSA9IG51bGw7XG4gICAgYSAhPT0gdm9pZCAwICYmIChwID0gXCJcIiArIGEpLCBsLmtleSAhPT0gdm9pZCAwICYmIChwID0gXCJcIiArIGwua2V5KSwgbC5yZWYgIT09IHZvaWQgMCAmJiAobSA9IGwucmVmKTtcbiAgICBmb3IgKGggaW4gbClcbiAgICAgIHIuY2FsbChsLCBoKSAmJiAhaS5oYXNPd25Qcm9wZXJ0eShoKSAmJiAoZltoXSA9IGxbaF0pO1xuICAgIGlmICh1ICYmIHUuZGVmYXVsdFByb3BzKVxuICAgICAgZm9yIChoIGluIGwgPSB1LmRlZmF1bHRQcm9wcywgbClcbiAgICAgICAgZltoXSA9PT0gdm9pZCAwICYmIChmW2hdID0gbFtoXSk7XG4gICAgcmV0dXJuIHsgJCR0eXBlb2Y6IGUsIHR5cGU6IHUsIGtleTogcCwgcmVmOiBtLCBwcm9wczogZiwgX293bmVyOiBzLmN1cnJlbnQgfTtcbiAgfVxuICByZXR1cm4gb3QuRnJhZ21lbnQgPSB0LCBvdC5qc3ggPSBvLCBvdC5qc3hzID0gbywgb3Q7XG59XG52YXIgYXQgPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBZcjtcbmZ1bmN0aW9uIERhKCkge1xuICByZXR1cm4gWXIgfHwgKFlyID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gcWUsIGUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgdCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksIHIgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksIHMgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksIGkgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksIG8gPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIiksIHUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSwgbCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSwgYSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSwgaCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLCBmID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksIHAgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSwgbSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksIGcgPSBTeW1ib2wuaXRlcmF0b3IsIGIgPSBcIkBAaXRlcmF0b3JcIjtcbiAgICBmdW5jdGlvbiBFKGMpIHtcbiAgICAgIGlmIChjID09PSBudWxsIHx8IHR5cGVvZiBjICE9IFwib2JqZWN0XCIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdmFyIGQgPSBnICYmIGNbZ10gfHwgY1tiXTtcbiAgICAgIHJldHVybiB0eXBlb2YgZCA9PSBcImZ1bmN0aW9uXCIgPyBkIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIF8gPSBuLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuICAgIGZ1bmN0aW9uIFMoYykge1xuICAgICAge1xuICAgICAgICBmb3IgKHZhciBkID0gYXJndW1lbnRzLmxlbmd0aCwgdiA9IG5ldyBBcnJheShkID4gMSA/IGQgLSAxIDogMCksIHcgPSAxOyB3IDwgZDsgdysrKVxuICAgICAgICAgIHZbdyAtIDFdID0gYXJndW1lbnRzW3ddO1xuICAgICAgICBrKFwiZXJyb3JcIiwgYywgdik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGsoYywgZCwgdikge1xuICAgICAge1xuICAgICAgICB2YXIgdyA9IF8uUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSwgQSA9IHcuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICAgICAgICBBICE9PSBcIlwiICYmIChkICs9IFwiJXNcIiwgdiA9IHYuY29uY2F0KFtBXSkpO1xuICAgICAgICB2YXIgcSA9IHYubWFwKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcS51bnNoaWZ0KFwiV2FybmluZzogXCIgKyBkKSwgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtjXSwgY29uc29sZSwgcSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB5ID0gITEsIE0gPSAhMSwgVCA9ICExLCBWID0gITEsIEQgPSAhMSwgajtcbiAgICBqID0gU3ltYm9sLmZvcihcInJlYWN0Lm1vZHVsZS5yZWZlcmVuY2VcIik7XG4gICAgZnVuY3Rpb24gTChjKSB7XG4gICAgICByZXR1cm4gISEodHlwZW9mIGMgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgYyA9PSBcImZ1bmN0aW9uXCIgfHwgYyA9PT0gciB8fCBjID09PSBpIHx8IEQgfHwgYyA9PT0gcyB8fCBjID09PSBhIHx8IGMgPT09IGggfHwgViB8fCBjID09PSBtIHx8IHkgfHwgTSB8fCBUIHx8IHR5cGVvZiBjID09IFwib2JqZWN0XCIgJiYgYyAhPT0gbnVsbCAmJiAoYy4kJHR5cGVvZiA9PT0gcCB8fCBjLiQkdHlwZW9mID09PSBmIHx8IGMuJCR0eXBlb2YgPT09IG8gfHwgYy4kJHR5cGVvZiA9PT0gdSB8fCBjLiQkdHlwZW9mID09PSBsIHx8IGMuJCR0eXBlb2YgPT09IGogfHwgYy5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFEoYywgZCwgdikge1xuICAgICAgdmFyIHcgPSBjLmRpc3BsYXlOYW1lO1xuICAgICAgaWYgKHcpXG4gICAgICAgIHJldHVybiB3O1xuICAgICAgdmFyIEEgPSBkLmRpc3BsYXlOYW1lIHx8IGQubmFtZSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIEEgIT09IFwiXCIgPyB2ICsgXCIoXCIgKyBBICsgXCIpXCIgOiB2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBuZShjKSB7XG4gICAgICByZXR1cm4gYy5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gRyhjKSB7XG4gICAgICBpZiAoYyA9PSBudWxsKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGlmICh0eXBlb2YgYy50YWcgPT0gXCJudW1iZXJcIiAmJiBTKFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIiksIHR5cGVvZiBjID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIGMuZGlzcGxheU5hbWUgfHwgYy5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAodHlwZW9mIGMgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSByOlxuICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgIGNhc2UgdDpcbiAgICAgICAgICByZXR1cm4gXCJQb3J0YWxcIjtcbiAgICAgICAgY2FzZSBpOlxuICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgIGNhc2UgczpcbiAgICAgICAgICByZXR1cm4gXCJTdHJpY3RNb2RlXCI7XG4gICAgICAgIGNhc2UgYTpcbiAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZVwiO1xuICAgICAgICBjYXNlIGg6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VMaXN0XCI7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGMgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChjLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSB1OlxuICAgICAgICAgICAgdmFyIGQgPSBjO1xuICAgICAgICAgICAgcmV0dXJuIG5lKGQpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIG86XG4gICAgICAgICAgICB2YXIgdiA9IGM7XG4gICAgICAgICAgICByZXR1cm4gbmUodi5fY29udGV4dCkgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgbDpcbiAgICAgICAgICAgIHJldHVybiBRKGMsIGMucmVuZGVyLCBcIkZvcndhcmRSZWZcIik7XG4gICAgICAgICAgY2FzZSBmOlxuICAgICAgICAgICAgdmFyIHcgPSBjLmRpc3BsYXlOYW1lIHx8IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdyAhPT0gbnVsbCA/IHcgOiBHKGMudHlwZSkgfHwgXCJNZW1vXCI7XG4gICAgICAgICAgY2FzZSBwOiB7XG4gICAgICAgICAgICB2YXIgQSA9IGMsIHEgPSBBLl9wYXlsb2FkLCB4ID0gQS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBHKHgocSkpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBGID0gT2JqZWN0LmFzc2lnbiwgTGUgPSAwLCBRZSwgWmUsIGJlLCBldCwgeXQsIHdlLCBFZTtcbiAgICBmdW5jdGlvbiBOZSgpIHtcbiAgICB9XG4gICAgTmUuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgZnVuY3Rpb24gbXQoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChMZSA9PT0gMCkge1xuICAgICAgICAgIFFlID0gY29uc29sZS5sb2csIFplID0gY29uc29sZS5pbmZvLCBiZSA9IGNvbnNvbGUud2FybiwgZXQgPSBjb25zb2xlLmVycm9yLCB5dCA9IGNvbnNvbGUuZ3JvdXAsIHdlID0gY29uc29sZS5ncm91cENvbGxhcHNlZCwgRWUgPSBjb25zb2xlLmdyb3VwRW5kO1xuICAgICAgICAgIHZhciBjID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgdmFsdWU6IE5lLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICBpbmZvOiBjLFxuICAgICAgICAgICAgbG9nOiBjLFxuICAgICAgICAgICAgd2FybjogYyxcbiAgICAgICAgICAgIGVycm9yOiBjLFxuICAgICAgICAgICAgZ3JvdXA6IGMsXG4gICAgICAgICAgICBncm91cENvbGxhcHNlZDogYyxcbiAgICAgICAgICAgIGdyb3VwRW5kOiBjXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgTGUrKztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gSWUoKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChMZS0tLCBMZSA9PT0gMCkge1xuICAgICAgICAgIHZhciBjID0ge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgICBsb2c6IEYoe30sIGMsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IFFlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGluZm86IEYoe30sIGMsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IFplXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdhcm46IEYoe30sIGMsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGJlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGVycm9yOiBGKHt9LCBjLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cDogRih7fSwgYywge1xuICAgICAgICAgICAgICB2YWx1ZTogeXRcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IEYoe30sIGMsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHdlXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwRW5kOiBGKHt9LCBjLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBFZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBMZSA8IDAgJiYgUyhcImRpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBWZSA9IF8uUmVhY3RDdXJyZW50RGlzcGF0Y2hlciwgamU7XG4gICAgZnVuY3Rpb24gJGUoYywgZCwgdikge1xuICAgICAge1xuICAgICAgICBpZiAoamUgPT09IHZvaWQgMClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoIChBKSB7XG4gICAgICAgICAgICB2YXIgdyA9IEEuc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgICAgICBqZSA9IHcgJiYgd1sxXSB8fCBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGBcbmAgKyBqZSArIGM7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0dCA9ICExLCB2ZTtcbiAgICB7XG4gICAgICB2YXIgZ3QgPSB0eXBlb2YgV2Vha01hcCA9PSBcImZ1bmN0aW9uXCIgPyBXZWFrTWFwIDogTWFwO1xuICAgICAgdmUgPSBuZXcgZ3QoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTihjLCBkKSB7XG4gICAgICBpZiAoIWMgfHwgdHQpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAge1xuICAgICAgICB2YXIgdiA9IHZlLmdldChjKTtcbiAgICAgICAgaWYgKHYgIT09IHZvaWQgMClcbiAgICAgICAgICByZXR1cm4gdjtcbiAgICAgIH1cbiAgICAgIHZhciB3O1xuICAgICAgdHQgPSAhMDtcbiAgICAgIHZhciBBID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHZvaWQgMDtcbiAgICAgIHZhciBxO1xuICAgICAgcSA9IFZlLmN1cnJlbnQsIFZlLmN1cnJlbnQgPSBudWxsLCBtdCgpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICB2YXIgeCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkoeC5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgdHlwZW9mIFJlZmxlY3QgPT0gXCJvYmplY3RcIiAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoeCwgW10pO1xuICAgICAgICAgICAgfSBjYXRjaCAoU2UpIHtcbiAgICAgICAgICAgICAgdyA9IFNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoYywgW10sIHgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB4LmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKFNlKSB7XG4gICAgICAgICAgICAgIHcgPSBTZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMuY2FsbCh4LnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKFNlKSB7XG4gICAgICAgICAgICB3ID0gU2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGMoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoU2UpIHtcbiAgICAgICAgaWYgKFNlICYmIHcgJiYgdHlwZW9mIFNlLnN0YWNrID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBmb3IgKHZhciBSID0gU2Uuc3RhY2suc3BsaXQoYFxuYCksIHNlID0gdy5zdGFjay5zcGxpdChgXG5gKSwgVyA9IFIubGVuZ3RoIC0gMSwgWSA9IHNlLmxlbmd0aCAtIDE7IFcgPj0gMSAmJiBZID49IDAgJiYgUltXXSAhPT0gc2VbWV07IClcbiAgICAgICAgICAgIFktLTtcbiAgICAgICAgICBmb3IgKDsgVyA+PSAxICYmIFkgPj0gMDsgVy0tLCBZLS0pXG4gICAgICAgICAgICBpZiAoUltXXSAhPT0gc2VbWV0pIHtcbiAgICAgICAgICAgICAgaWYgKFcgIT09IDEgfHwgWSAhPT0gMSlcbiAgICAgICAgICAgICAgICBkb1xuICAgICAgICAgICAgICAgICAgaWYgKFctLSwgWS0tLCBZIDwgMCB8fCBSW1ddICE9PSBzZVtZXSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGUgPSBgXG5gICsgUltXXS5yZXBsYWNlKFwiIGF0IG5ldyBcIiwgXCIgYXQgXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYy5kaXNwbGF5TmFtZSAmJiBsZS5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmIChsZSA9IGxlLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBjLmRpc3BsYXlOYW1lKSksIHR5cGVvZiBjID09IFwiZnVuY3Rpb25cIiAmJiB2ZS5zZXQoYywgbGUpLCBsZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoVyA+PSAxICYmIFkgPj0gMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0dCA9ICExLCBWZS5jdXJyZW50ID0gcSwgSWUoKSwgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBBO1xuICAgICAgfVxuICAgICAgdmFyIEplID0gYyA/IGMuZGlzcGxheU5hbWUgfHwgYy5uYW1lIDogXCJcIiwgcnIgPSBKZSA/ICRlKEplKSA6IFwiXCI7XG4gICAgICByZXR1cm4gdHlwZW9mIGMgPT0gXCJmdW5jdGlvblwiICYmIHZlLnNldChjLCByciksIHJyO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVKGMsIGQsIHYpIHtcbiAgICAgIHJldHVybiBOKGMsICExKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gWChjKSB7XG4gICAgICB2YXIgZCA9IGMucHJvdG90eXBlO1xuICAgICAgcmV0dXJuICEhKGQgJiYgZC5pc1JlYWN0Q29tcG9uZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSShjLCBkLCB2KSB7XG4gICAgICBpZiAoYyA9PSBudWxsKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGlmICh0eXBlb2YgYyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBOKGMsIFgoYykpO1xuICAgICAgaWYgKHR5cGVvZiBjID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiAkZShjKTtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIGE6XG4gICAgICAgICAgcmV0dXJuICRlKFwiU3VzcGVuc2VcIik7XG4gICAgICAgIGNhc2UgaDpcbiAgICAgICAgICByZXR1cm4gJGUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGMgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChjLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBsOlxuICAgICAgICAgICAgcmV0dXJuIFUoYy5yZW5kZXIpO1xuICAgICAgICAgIGNhc2UgZjpcbiAgICAgICAgICAgIHJldHVybiBJKGMudHlwZSwgZCwgdik7XG4gICAgICAgICAgY2FzZSBwOiB7XG4gICAgICAgICAgICB2YXIgdyA9IGMsIEEgPSB3Ll9wYXlsb2FkLCBxID0gdy5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBJKHEoQSksIGQsIHYpO1xuICAgICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgdmFyIHJlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgUmUgPSB7fSwgSCA9IF8uUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICBmdW5jdGlvbiBKKGMpIHtcbiAgICAgIGlmIChjKSB7XG4gICAgICAgIHZhciBkID0gYy5fb3duZXIsIHYgPSBJKGMudHlwZSwgYy5fc291cmNlLCBkID8gZC50eXBlIDogbnVsbCk7XG4gICAgICAgIEguc2V0RXh0cmFTdGFja0ZyYW1lKHYpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIEguc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZShjLCBkLCB2LCB3LCBBKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBxID0gRnVuY3Rpb24uY2FsbC5iaW5kKHJlKTtcbiAgICAgICAgZm9yICh2YXIgeCBpbiBjKVxuICAgICAgICAgIGlmIChxKGMsIHgpKSB7XG4gICAgICAgICAgICB2YXIgUiA9IHZvaWQgMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY1t4XSAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2UgPSBFcnJvcigodyB8fCBcIlJlYWN0IGNsYXNzXCIpICsgXCI6IFwiICsgdiArIFwiIHR5cGUgYFwiICsgeCArIFwiYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgXCIgKyB0eXBlb2YgY1t4XSArIFwiYC5UaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC5cIik7XG4gICAgICAgICAgICAgICAgdGhyb3cgc2UubmFtZSA9IFwiSW52YXJpYW50IFZpb2xhdGlvblwiLCBzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBSID0gY1t4XShkLCB4LCB3LCB2LCBudWxsLCBcIlNFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEXCIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoVykge1xuICAgICAgICAgICAgICBSID0gVztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFIgJiYgIShSIGluc3RhbmNlb2YgRXJyb3IpICYmIChKKEEpLCBTKFwiJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuIFlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyIGNyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLlwiLCB3IHx8IFwiUmVhY3QgY2xhc3NcIiwgdiwgeCwgdHlwZW9mIFIpLCBKKG51bGwpKSwgUiBpbnN0YW5jZW9mIEVycm9yICYmICEoUi5tZXNzYWdlIGluIFJlKSAmJiAoUmVbUi5tZXNzYWdlXSA9ICEwLCBKKEEpLCBTKFwiRmFpbGVkICVzIHR5cGU6ICVzXCIsIHYsIFIubWVzc2FnZSksIEoobnVsbCkpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIF90ID0gQXJyYXkuaXNBcnJheTtcbiAgICBmdW5jdGlvbiBNZShjKSB7XG4gICAgICByZXR1cm4gX3QoYyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJ0KGMpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGQgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wudG9TdHJpbmdUYWcsIHYgPSBkICYmIGNbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCBjLmNvbnN0cnVjdG9yLm5hbWUgfHwgXCJPYmplY3RcIjtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGllKGMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjZShjKSwgITE7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjZShjKSB7XG4gICAgICByZXR1cm4gXCJcIiArIGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdlKGMpIHtcbiAgICAgIGlmIChpZShjKSlcbiAgICAgICAgcmV0dXJuIFMoXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIiwgYnQoYykpLCBjZShjKTtcbiAgICB9XG4gICAgdmFyIFBlID0gXy5SZWFjdEN1cnJlbnRPd25lciwgbnQgPSB7XG4gICAgICBrZXk6ICEwLFxuICAgICAgcmVmOiAhMCxcbiAgICAgIF9fc2VsZjogITAsXG4gICAgICBfX3NvdXJjZTogITBcbiAgICB9LCBLbiwgR24sIFd0O1xuICAgIFd0ID0ge307XG4gICAgZnVuY3Rpb24gVXMoYykge1xuICAgICAgaWYgKHJlLmNhbGwoYywgXCJyZWZcIikpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGMsIFwicmVmXCIpLmdldDtcbiAgICAgICAgaWYgKGQgJiYgZC5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYy5yZWYgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcXMoYykge1xuICAgICAgaWYgKHJlLmNhbGwoYywgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGMsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGQgJiYgZC5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gYy5rZXkgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gSXMoYywgZCkge1xuICAgICAgaWYgKHR5cGVvZiBjLnJlZiA9PSBcInN0cmluZ1wiICYmIFBlLmN1cnJlbnQgJiYgZCAmJiBQZS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gZCkge1xuICAgICAgICB2YXIgdiA9IEcoUGUuY3VycmVudC50eXBlKTtcbiAgICAgICAgV3Rbdl0gfHwgKFMoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiBTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBHKFBlLmN1cnJlbnQudHlwZSksIGMucmVmKSwgV3Rbdl0gPSAhMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFZzKGMsIGQpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHYgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBLbiB8fCAoS24gPSAhMCwgUyhcIiVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0IGluIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgdmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCBwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpXCIsIGQpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdi5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYywgXCJrZXlcIiwge1xuICAgICAgICAgIGdldDogdixcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBqcyhjLCBkKSB7XG4gICAgICB7XG4gICAgICAgIHZhciB2ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgR24gfHwgKEduID0gITAsIFMoXCIlczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCBkKSk7XG4gICAgICAgIH07XG4gICAgICAgIHYuaXNSZWFjdFdhcm5pbmcgPSAhMCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGMsIFwicmVmXCIsIHtcbiAgICAgICAgICBnZXQ6IHYsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyICRzID0gZnVuY3Rpb24oYywgZCwgdiwgdywgQSwgcSwgeCkge1xuICAgICAgdmFyIFIgPSB7XG4gICAgICAgICQkdHlwZW9mOiBlLFxuICAgICAgICB0eXBlOiBjLFxuICAgICAgICBrZXk6IGQsXG4gICAgICAgIHJlZjogdixcbiAgICAgICAgcHJvcHM6IHgsXG4gICAgICAgIF9vd25lcjogcVxuICAgICAgfTtcbiAgICAgIHJldHVybiBSLl9zdG9yZSA9IHt9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkoUi5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6ICExXG4gICAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KFIsIFwiX3NlbGZcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICExLFxuICAgICAgICB2YWx1ZTogd1xuICAgICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSLCBcIl9zb3VyY2VcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICExLFxuICAgICAgICB2YWx1ZTogQVxuICAgICAgfSksIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUoUi5wcm9wcyksIE9iamVjdC5mcmVlemUoUikpLCBSO1xuICAgIH07XG4gICAgZnVuY3Rpb24gTXMoYywgZCwgdiwgdywgQSkge1xuICAgICAge1xuICAgICAgICB2YXIgcSwgeCA9IHt9LCBSID0gbnVsbCwgc2UgPSBudWxsO1xuICAgICAgICB2ICE9PSB2b2lkIDAgJiYgKFdlKHYpLCBSID0gXCJcIiArIHYpLCBxcyhkKSAmJiAoV2UoZC5rZXkpLCBSID0gXCJcIiArIGQua2V5KSwgVXMoZCkgJiYgKHNlID0gZC5yZWYsIElzKGQsIEEpKTtcbiAgICAgICAgZm9yIChxIGluIGQpXG4gICAgICAgICAgcmUuY2FsbChkLCBxKSAmJiAhbnQuaGFzT3duUHJvcGVydHkocSkgJiYgKHhbcV0gPSBkW3FdKTtcbiAgICAgICAgaWYgKGMgJiYgYy5kZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgICB2YXIgVyA9IGMuZGVmYXVsdFByb3BzO1xuICAgICAgICAgIGZvciAocSBpbiBXKVxuICAgICAgICAgICAgeFtxXSA9PT0gdm9pZCAwICYmICh4W3FdID0gV1txXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFIgfHwgc2UpIHtcbiAgICAgICAgICB2YXIgWSA9IHR5cGVvZiBjID09IFwiZnVuY3Rpb25cIiA/IGMuZGlzcGxheU5hbWUgfHwgYy5uYW1lIHx8IFwiVW5rbm93blwiIDogYztcbiAgICAgICAgICBSICYmIFZzKHgsIFkpLCBzZSAmJiBqcyh4LCBZKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHMoYywgUiwgc2UsIEEsIHcsIFBlLmN1cnJlbnQsIHgpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgSHQgPSBfLlJlYWN0Q3VycmVudE93bmVyLCBYbiA9IF8uUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICBmdW5jdGlvbiBIZShjKSB7XG4gICAgICBpZiAoYykge1xuICAgICAgICB2YXIgZCA9IGMuX293bmVyLCB2ID0gSShjLnR5cGUsIGMuX3NvdXJjZSwgZCA/IGQudHlwZSA6IG51bGwpO1xuICAgICAgICBYbi5zZXRFeHRyYVN0YWNrRnJhbWUodik7XG4gICAgICB9IGVsc2VcbiAgICAgICAgWG4uc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgICB2YXIgSnQ7XG4gICAgSnQgPSAhMTtcbiAgICBmdW5jdGlvbiBZdChjKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIGMgPT0gXCJvYmplY3RcIiAmJiBjICE9PSBudWxsICYmIGMuJCR0eXBlb2YgPT09IGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFFuKCkge1xuICAgICAge1xuICAgICAgICBpZiAoSHQuY3VycmVudCkge1xuICAgICAgICAgIHZhciBjID0gRyhIdC5jdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGlmIChjKVxuICAgICAgICAgICAgcmV0dXJuIGBcblxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgXFxgYCArIGMgKyBcImAuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdzKGMpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGMgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhciBkID0gYy5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCBcIlwiKSwgdiA9IGMubGluZU51bWJlcjtcbiAgICAgICAgICByZXR1cm4gYFxuXG5DaGVjayB5b3VyIGNvZGUgYXQgYCArIGQgKyBcIjpcIiArIHYgKyBcIi5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFpuID0ge307XG4gICAgZnVuY3Rpb24gSHMoYykge1xuICAgICAge1xuICAgICAgICB2YXIgZCA9IFFuKCk7XG4gICAgICAgIGlmICghZCkge1xuICAgICAgICAgIHZhciB2ID0gdHlwZW9mIGMgPT0gXCJzdHJpbmdcIiA/IGMgOiBjLmRpc3BsYXlOYW1lIHx8IGMubmFtZTtcbiAgICAgICAgICB2ICYmIChkID0gYFxuXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxgICsgdiArIFwiPi5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVyKGMsIGQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFjLl9zdG9yZSB8fCBjLl9zdG9yZS52YWxpZGF0ZWQgfHwgYy5rZXkgIT0gbnVsbClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGMuX3N0b3JlLnZhbGlkYXRlZCA9ICEwO1xuICAgICAgICB2YXIgdiA9IEhzKGQpO1xuICAgICAgICBpZiAoWm5bdl0pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBablt2XSA9ICEwO1xuICAgICAgICB2YXIgdyA9IFwiXCI7XG4gICAgICAgIGMgJiYgYy5fb3duZXIgJiYgYy5fb3duZXIgIT09IEh0LmN1cnJlbnQgJiYgKHcgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIEcoYy5fb3duZXIudHlwZSkgKyBcIi5cIiksIEhlKGMpLCBTKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCB2LCB3KSwgSGUobnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRyKGMsIGQpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoTWUoYykpXG4gICAgICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBjLmxlbmd0aDsgdisrKSB7XG4gICAgICAgICAgICB2YXIgdyA9IGNbdl07XG4gICAgICAgICAgICBZdCh3KSAmJiBlcih3LCBkKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFl0KGMpKVxuICAgICAgICAgIGMuX3N0b3JlICYmIChjLl9zdG9yZS52YWxpZGF0ZWQgPSAhMCk7XG4gICAgICAgIGVsc2UgaWYgKGMpIHtcbiAgICAgICAgICB2YXIgQSA9IEUoYyk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBBID09IFwiZnVuY3Rpb25cIiAmJiBBICE9PSBjLmVudHJpZXMpXG4gICAgICAgICAgICBmb3IgKHZhciBxID0gQS5jYWxsKGMpLCB4OyAhKHggPSBxLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgICBZdCh4LnZhbHVlKSAmJiBlcih4LnZhbHVlLCBkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBKcyhjKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBkID0gYy50eXBlO1xuICAgICAgICBpZiAoZCA9PSBudWxsIHx8IHR5cGVvZiBkID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgdjtcbiAgICAgICAgaWYgKHR5cGVvZiBkID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICB2ID0gZC5wcm9wVHlwZXM7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkID09IFwib2JqZWN0XCIgJiYgKGQuJCR0eXBlb2YgPT09IGwgfHwgZC4kJHR5cGVvZiA9PT0gZikpXG4gICAgICAgICAgdiA9IGQucHJvcFR5cGVzO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodikge1xuICAgICAgICAgIHZhciB3ID0gRyhkKTtcbiAgICAgICAgICBkZSh2LCBjLnByb3BzLCBcInByb3BcIiwgdywgYyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZC5Qcm9wVHlwZXMgIT09IHZvaWQgMCAmJiAhSnQpIHtcbiAgICAgICAgICBKdCA9ICEwO1xuICAgICAgICAgIHZhciBBID0gRyhkKTtcbiAgICAgICAgICBTKFwiQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/XCIsIEEgfHwgXCJVbmtub3duXCIpO1xuICAgICAgICB9XG4gICAgICAgIHR5cGVvZiBkLmdldERlZmF1bHRQcm9wcyA9PSBcImZ1bmN0aW9uXCIgJiYgIWQuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmIFMoXCJnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gWXMoYykge1xuICAgICAge1xuICAgICAgICBmb3IgKHZhciBkID0gT2JqZWN0LmtleXMoYy5wcm9wcyksIHYgPSAwOyB2IDwgZC5sZW5ndGg7IHYrKykge1xuICAgICAgICAgIHZhciB3ID0gZFt2XTtcbiAgICAgICAgICBpZiAodyAhPT0gXCJjaGlsZHJlblwiICYmIHcgIT09IFwia2V5XCIpIHtcbiAgICAgICAgICAgIEhlKGMpLCBTKFwiSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy5cIiwgdyksIEhlKG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGMucmVmICE9PSBudWxsICYmIChIZShjKSwgUyhcIkludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuXCIpLCBIZShudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5yKGMsIGQsIHYsIHcsIEEsIHEpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHggPSBMKGMpO1xuICAgICAgICBpZiAoIXgpIHtcbiAgICAgICAgICB2YXIgUiA9IFwiXCI7XG4gICAgICAgICAgKGMgPT09IHZvaWQgMCB8fCB0eXBlb2YgYyA9PSBcIm9iamVjdFwiICYmIGMgIT09IG51bGwgJiYgT2JqZWN0LmtleXMoYykubGVuZ3RoID09PSAwKSAmJiAoUiArPSBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCIpO1xuICAgICAgICAgIHZhciBzZSA9IFdzKEEpO1xuICAgICAgICAgIHNlID8gUiArPSBzZSA6IFIgKz0gUW4oKTtcbiAgICAgICAgICB2YXIgVztcbiAgICAgICAgICBjID09PSBudWxsID8gVyA9IFwibnVsbFwiIDogTWUoYykgPyBXID0gXCJhcnJheVwiIDogYyAhPT0gdm9pZCAwICYmIGMuJCR0eXBlb2YgPT09IGUgPyAoVyA9IFwiPFwiICsgKEcoYy50eXBlKSB8fCBcIlVua25vd25cIikgKyBcIiAvPlwiLCBSID0gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikgOiBXID0gdHlwZW9mIGMsIFMoXCJSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXNcIiwgVywgUik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFkgPSBNcyhjLCBkLCB2LCBBLCBxKTtcbiAgICAgICAgaWYgKFkgPT0gbnVsbClcbiAgICAgICAgICByZXR1cm4gWTtcbiAgICAgICAgaWYgKHgpIHtcbiAgICAgICAgICB2YXIgbGUgPSBkLmNoaWxkcmVuO1xuICAgICAgICAgIGlmIChsZSAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgaWYgKHcpXG4gICAgICAgICAgICAgIGlmIChNZShsZSkpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBKZSA9IDA7IEplIDwgbGUubGVuZ3RoOyBKZSsrKVxuICAgICAgICAgICAgICAgICAgdHIobGVbSmVdLCBjKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplICYmIE9iamVjdC5mcmVlemUobGUpO1xuICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICBTKFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgdHIobGUsIGMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjID09PSByID8gWXMoWSkgOiBKcyhZKSwgWTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24genMoYywgZCwgdikge1xuICAgICAgcmV0dXJuIG5yKGMsIGQsIHYsICEwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gS3MoYywgZCwgdikge1xuICAgICAgcmV0dXJuIG5yKGMsIGQsIHYsICExKTtcbiAgICB9XG4gICAgdmFyIEdzID0gS3MsIFhzID0genM7XG4gICAgYXQuRnJhZ21lbnQgPSByLCBhdC5qc3ggPSBHcywgYXQuanN4cyA9IFhzO1xuICB9KCkpLCBhdDtcbn1cbihmdW5jdGlvbihuKSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IG4uZXhwb3J0cyA9IEFhKCkgOiBuLmV4cG9ydHMgPSBEYSgpO1xufSkoUHMpO1xuY29uc3Qga2EgPSBQcy5leHBvcnRzLmpzeCwgdGUgPSB6cihudWxsKSwgVWEgPSAoe1xuICB1cmw6IG4gPSBcIlwiLFxuICB0b2tlblBhcmFtczogZSxcbiAgc29ja2V0UG9ydDogdCxcbiAgc2l0ZU5hbWU6IHIsXG4gIGVuYWJsZVNvY2tldDogcyA9ICEwLFxuICBjaGlsZHJlbjogaVxufSkgPT4ge1xuICBjb25zdCBvID0gS3IoKCkgPT4ge1xuICAgIGNvbnN0IHUgPSBuZXcgb28uRnJhcHBlQXBwKG4sIGUpO1xuICAgIHJldHVybiB7XG4gICAgICB1cmw6IG4sXG4gICAgICB0b2tlblBhcmFtczogZSxcbiAgICAgIGFwcDogdSxcbiAgICAgIGF1dGg6IHUuYXV0aCgpLFxuICAgICAgZGI6IHUuZGIoKSxcbiAgICAgIGNhbGw6IHUuY2FsbCgpLFxuICAgICAgZmlsZTogdS5maWxlKCksXG4gICAgICBzb2NrZXQ6IHMgPyBuZXcgQ2EobiwgciwgdCwgZSkuc29ja2V0IDogdm9pZCAwLFxuICAgICAgZW5hYmxlU29ja2V0OiBzLFxuICAgICAgc29ja2V0UG9ydDogdFxuICAgIH07XG4gIH0sIFtuLCBlLCB0LCBzXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ga2EodGUuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbyxcbiAgICBjaGlsZHJlbjogaVxuICB9KTtcbn0sIHFhID0gKG4pID0+IHtcbiAgY29uc3Qge1xuICAgIHVybDogZSxcbiAgICBhdXRoOiB0LFxuICAgIHRva2VuUGFyYW1zOiByXG4gIH0gPSBlZSh0ZSksIFtzLCBpXSA9IFAoKSwgbyA9ICQoKCkgPT4ge1xuICAgIGNvbnN0IGcgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoXCI7XCIpLmZpbmQoKGIpID0+IGIudHJpbSgpLnN0YXJ0c1dpdGgoXCJ1c2VyX2lkPVwiKSk7XG4gICAgaWYgKGcpIHtcbiAgICAgIGNvbnN0IGIgPSBnLnNwbGl0KFwiPVwiKVsxXTtcbiAgICAgIGkoYiAmJiBiICE9PSBcIkd1ZXN0XCIgPyBiIDogbnVsbCk7XG4gICAgfSBlbHNlXG4gICAgICBpKG51bGwpO1xuICB9LCBbXSk7XG4gIEdlKCgpID0+IHtcbiAgICByICYmIHIudXNlVG9rZW4gPyBpKG51bGwpIDogbygpO1xuICB9LCBbXSk7XG4gIGNvbnN0IHtcbiAgICBkYXRhOiB1LFxuICAgIGVycm9yOiBsLFxuICAgIGlzTG9hZGluZzogYSxcbiAgICBpc1ZhbGlkYXRpbmc6IGgsXG4gICAgbXV0YXRlOiBmXG4gIH0gPSB2dCgoKSA9PiByICYmIHIudXNlVG9rZW4gfHwgcyA/IGAke2V9L2FwaS9tZXRob2QvZnJhcHBlLmF1dGguZ2V0X2xvZ2dlZF91c2VyYCA6IG51bGwsICgpID0+IHQuZ2V0TG9nZ2VkSW5Vc2VyKCksIHtcbiAgICBvbkVycm9yOiAoKSA9PiB7XG4gICAgICBpKG51bGwpO1xuICAgIH0sXG4gICAgc2hvdWxkUmV0cnlPbkVycm9yOiAhMSxcbiAgICByZXZhbGlkYXRlT25Gb2N1czogITEsXG4gICAgLi4ublxuICB9KSwgcCA9ICQoYXN5bmMgKGcsIGIpID0+IHQubG9naW5XaXRoVXNlcm5hbWVQYXNzd29yZCh7XG4gICAgdXNlcm5hbWU6IGcsXG4gICAgcGFzc3dvcmQ6IGJcbiAgfSkudGhlbigoRSkgPT4ge1xuICAgIG8oKTtcbiAgfSksIFtdKSwgbSA9ICQoYXN5bmMgKCkgPT4gdC5sb2dvdXQoKS50aGVuKCgpID0+IGYobnVsbCkpLnRoZW4oKCkgPT4gaShudWxsKSksIFtdKTtcbiAgcmV0dXJuIHtcbiAgICBpc0xvYWRpbmc6IHMgPT09IHZvaWQgMCB8fCBhLFxuICAgIGN1cnJlbnRVc2VyOiB1LFxuICAgIGlzVmFsaWRhdGluZzogaCxcbiAgICBlcnJvcjogbCxcbiAgICBsb2dpbjogcCxcbiAgICBsb2dvdXQ6IG0sXG4gICAgdXBkYXRlQ3VycmVudFVzZXI6IGYsXG4gICAgZ2V0VXNlckNvb2tpZTogb1xuICB9O1xufSwgQnMgPSAobiwgZSwgdCkgPT4ge1xuICBsZXQgciA9IGAke2V9L2FwaS9yZXNvdXJjZS9gO1xuICByZXR1cm4gdCA/IHIgKz0gYCR7bn0vJHt0fWAgOiByICs9IGAke259YCwgcjtcbn0sIElhID0gKG4sIGUsIHQsIHIpID0+IHtcbiAgY29uc3Qge1xuICAgIHVybDogcyxcbiAgICBkYjogaVxuICB9ID0gZWUodGUpO1xuICByZXR1cm4ge1xuICAgIC4uLnZ0KHQgPT09IHZvaWQgMCA/IEJzKG4sIHMsIGUpIDogdCwgKCkgPT4gaS5nZXREb2MobiwgZSksIHIpXG4gIH07XG59LCBMYSA9IChuKSA9PiB7XG4gIHZhciB0LCByLCBzO1xuICBsZXQgZSA9IFwiXCI7XG4gIGlmIChuICE9IG51bGwgJiYgbi5maWVsZHMgJiYgKGUgKz0gXCJmaWVsZHM9XCIgKyBKU09OLnN0cmluZ2lmeShuID09IG51bGwgPyB2b2lkIDAgOiBuLmZpZWxkcykgKyBcIiZcIiksIG4gIT0gbnVsbCAmJiBuLmZpbHRlcnMgJiYgKGUgKz0gXCJmaWx0ZXJzPVwiICsgSlNPTi5zdHJpbmdpZnkobiA9PSBudWxsID8gdm9pZCAwIDogbi5maWx0ZXJzKSArIFwiJlwiKSwgbiAhPSBudWxsICYmIG4ub3JGaWx0ZXJzICYmIChlICs9IFwib3JfZmlsdGVycz1cIiArIEpTT04uc3RyaW5naWZ5KG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4ub3JGaWx0ZXJzKSArIFwiJlwiKSwgbiAhPSBudWxsICYmIG4ubGltaXRfc3RhcnQgJiYgKGUgKz0gXCJsaW1pdF9zdGFydD1cIiArIEpTT04uc3RyaW5naWZ5KG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4ubGltaXRfc3RhcnQpICsgXCImXCIpLCBuICE9IG51bGwgJiYgbi5saW1pdCAmJiAoZSArPSBcImxpbWl0PVwiICsgSlNPTi5zdHJpbmdpZnkobiA9PSBudWxsID8gdm9pZCAwIDogbi5saW1pdCkgKyBcIiZcIiksIG4gIT0gbnVsbCAmJiBuLmdyb3VwQnkgJiYgKGUgKz0gXCJncm91cF9ieT1cIiArIFN0cmluZyhuLmdyb3VwQnkpICsgXCImXCIpLCBuICE9IG51bGwgJiYgbi5vcmRlckJ5KSB7XG4gICAgY29uc3QgaSA9IGAke1N0cmluZygodCA9IG4ub3JkZXJCeSkgPT0gbnVsbCA/IHZvaWQgMCA6IHQuZmllbGQpfSAkeyhzID0gKHIgPSBuLm9yZGVyQnkpID09IG51bGwgPyB2b2lkIDAgOiByLm9yZGVyKSAhPSBudWxsID8gcyA6IFwiYXNjXCJ9YDtcbiAgICBlICs9IFwib3JkZXJfYnk9XCIgKyBpICsgXCImXCI7XG4gIH1cbiAgcmV0dXJuIG4gIT0gbnVsbCAmJiBuLmFzRGljdCAmJiAoZSArPSBcImFzX2RpY3Q9XCIgKyBuLmFzRGljdCksIGU7XG59LCBWYSA9IChuLCBlLCB0LCByKSA9PiB7XG4gIGNvbnN0IHtcbiAgICB1cmw6IHMsXG4gICAgZGI6IGlcbiAgfSA9IGVlKHRlKTtcbiAgcmV0dXJuIHtcbiAgICAuLi52dCh0ID09PSB2b2lkIDAgPyBgJHtCcyhuLCBzKX0/JHtMYShlKX1gIDogdCwgKCkgPT4gaS5nZXREb2NMaXN0KG4sIGUpLCByKVxuICB9O1xufSwgamEgPSAoKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBkYjogblxuICB9ID0gZWUodGUpLCBbZSwgdF0gPSBQKCExKSwgW3IsIHNdID0gUChudWxsKSwgW2ksIG9dID0gUCghMSksIHUgPSAkKCgpID0+IHtcbiAgICB0KCExKSwgcyhudWxsKSwgbyghMSk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVEb2M6ICQoYXN5bmMgKGEsIGgpID0+IChzKG51bGwpLCBvKCExKSwgdCghMCksIG4uY3JlYXRlRG9jKGEsIGgpLnRoZW4oKGYpID0+ICh0KCExKSwgbyghMCksIGYpKS5jYXRjaCgoZikgPT4ge1xuICAgICAgdGhyb3cgdCghMSksIG8oITEpLCBzKGYpLCBmO1xuICAgIH0pKSwgW10pLFxuICAgIGxvYWRpbmc6IGUsXG4gICAgZXJyb3I6IHIsXG4gICAgaXNDb21wbGV0ZWQ6IGksXG4gICAgcmVzZXQ6IHVcbiAgfTtcbn0sICRhID0gKCkgPT4ge1xuICBjb25zdCB7XG4gICAgZGI6IG5cbiAgfSA9IGVlKHRlKSwgW2UsIHRdID0gUCghMSksIFtyLCBzXSA9IFAobnVsbCksIFtpLCBvXSA9IFAoITEpLCB1ID0gJCgoKSA9PiB7XG4gICAgdCghMSksIHMobnVsbCksIG8oITEpO1xuICB9LCBbXSk7XG4gIHJldHVybiB7XG4gICAgdXBkYXRlRG9jOiAkKGFzeW5jIChhLCBoLCBmKSA9PiAocyhudWxsKSwgbyghMSksIHQoITApLCBuLnVwZGF0ZURvYyhhLCBoLCBmKS50aGVuKChwKSA9PiAodCghMSksIG8oITApLCBwKSkuY2F0Y2goKHApID0+IHtcbiAgICAgIHRocm93IHQoITEpLCBvKCExKSwgcyhwKSwgcDtcbiAgICB9KSksIFtdKSxcbiAgICBsb2FkaW5nOiBlLFxuICAgIGVycm9yOiByLFxuICAgIHJlc2V0OiB1LFxuICAgIGlzQ29tcGxldGVkOiBpXG4gIH07XG59LCBNYSA9ICgpID0+IHtcbiAgY29uc3Qge1xuICAgIGRiOiBuXG4gIH0gPSBlZSh0ZSksIFtlLCB0XSA9IFAoITEpLCBbciwgc10gPSBQKG51bGwpLCBbaSwgb10gPSBQKCExKSwgdSA9ICQoKCkgPT4ge1xuICAgIHQoITEpLCBzKG51bGwpLCBvKCExKTtcbiAgfSwgW10pO1xuICByZXR1cm4ge1xuICAgIGRlbGV0ZURvYzogJChhc3luYyAoYSwgaCkgPT4gKHMobnVsbCksIG8oITEpLCB0KCEwKSwgbi5kZWxldGVEb2MoYSwgaCkudGhlbigoZikgPT4gKHQoITEpLCBvKCEwKSwgZikpLmNhdGNoKChmKSA9PiB7XG4gICAgICB0aHJvdyB0KCExKSwgbyghMSksIHMoZiksIGY7XG4gICAgfSkpLCBbXSksXG4gICAgbG9hZGluZzogZSxcbiAgICBlcnJvcjogcixcbiAgICByZXNldDogdSxcbiAgICBpc0NvbXBsZXRlZDogaVxuICB9O1xufTtcbmZ1bmN0aW9uIEZzKG4pIHtcbiAgY29uc3QgZSA9IFtdO1xuICBmb3IgKGxldCB0IGluIG4pXG4gICAgZS5wdXNoKGVuY29kZVVSSUNvbXBvbmVudCh0KSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KG5bdF0pKTtcbiAgcmV0dXJuIGUuam9pbihcIiZcIik7XG59XG5jb25zdCBXYSA9IChuLCBlLCB0ID0gITEsIHIgPSAhMSwgcywgaSkgPT4ge1xuICBjb25zdCB7XG4gICAgdXJsOiBvLFxuICAgIGRiOiB1XG4gIH0gPSBlZSh0ZSk7XG4gIHJldHVybiB7XG4gICAgLi4udnQocyA9PT0gdm9pZCAwID8gKCgpID0+IHtcbiAgICAgIGNvbnN0IGggPSBGcyh0ID8ge1xuICAgICAgICBkb2N0eXBlOiBuLFxuICAgICAgICBmaWx0ZXJzOiBlICE9IG51bGwgPyBlIDogW10sXG4gICAgICAgIGNhY2hlOiB0LFxuICAgICAgICBkZWJ1ZzogclxuICAgICAgfSA6IHtcbiAgICAgICAgZG9jdHlwZTogbixcbiAgICAgICAgZmlsdGVyczogZSAhPSBudWxsID8gZSA6IFtdLFxuICAgICAgICBkZWJ1ZzogclxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYCR7b30vYXBpL21ldGhvZC9mcmFwcGUuY2xpZW50LmdldF9jb3VudD8ke2h9YDtcbiAgICB9KSgpIDogcywgKCkgPT4gdS5nZXRDb3VudChuLCBlLCB0LCByKSwgaSlcbiAgfTtcbn0sIE5hID0gKG4sIGUsIHQsIHIpID0+IHtcbiAgY29uc3Qge1xuICAgIGNhbGw6IHNcbiAgfSA9IGVlKHRlKSwgaSA9IEZzKGUgIT0gbnVsbCA/IGUgOiB7fSksIG8gPSBgJHtufT8ke2l9YDtcbiAgcmV0dXJuIHtcbiAgICAuLi52dCh0ID09PSB2b2lkIDAgPyBvIDogdCwgKCkgPT4gcy5nZXQobiwgZSksIHIpXG4gIH07XG59LCBIYSA9IChuKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjYWxsOiBlXG4gIH0gPSBlZSh0ZSksIFt0LCByXSA9IFAobnVsbCksIFtzLCBpXSA9IFAoITEpLCBbbywgdV0gPSBQKG51bGwpLCBbbCwgYV0gPSBQKCExKSwgaCA9ICQoKCkgPT4ge1xuICAgIHIobnVsbCksIGkoITEpLCB1KG51bGwpLCBhKCExKTtcbiAgfSwgW10pO1xuICByZXR1cm4ge1xuICAgIGNhbGw6ICQoYXN5bmMgKHApID0+ICh1KG51bGwpLCBhKCExKSwgaSghMCksIHIobnVsbCksIGUucG9zdChuLCBwKS50aGVuKChtKSA9PiAocihtKSwgaSghMSksIGEoITApLCBtKSkuY2F0Y2goKG0pID0+IHtcbiAgICAgIHRocm93IGkoITEpLCBhKCExKSwgdShtKSwgbTtcbiAgICB9KSksIFtdKSxcbiAgICByZXN1bHQ6IHQsXG4gICAgbG9hZGluZzogcyxcbiAgICBlcnJvcjogbyxcbiAgICByZXNldDogaCxcbiAgICBpc0NvbXBsZXRlZDogbFxuICB9O1xufSwgSmEgPSAobikgPT4ge1xuICBjb25zdCB7XG4gICAgY2FsbDogZVxuICB9ID0gZWUodGUpLCBbdCwgcl0gPSBQKG51bGwpLCBbcywgaV0gPSBQKCExKSwgW28sIHVdID0gUChudWxsKSwgW2wsIGFdID0gUCghMSksIGggPSAkKCgpID0+IHtcbiAgICByKG51bGwpLCBpKCExKSwgdShudWxsKSwgYSghMSk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHtcbiAgICBjYWxsOiAkKGFzeW5jIChwKSA9PiAodShudWxsKSwgYSghMSksIGkoITApLCByKG51bGwpLCBlLnB1dChuLCBwKS50aGVuKChtKSA9PiAocihtKSwgaSghMSksIGEoITApLCBtKSkuY2F0Y2goKG0pID0+IHtcbiAgICAgIHRocm93IGkoITEpLCBhKCExKSwgdShtKSwgbTtcbiAgICB9KSksIFtdKSxcbiAgICByZXN1bHQ6IHQsXG4gICAgbG9hZGluZzogcyxcbiAgICBlcnJvcjogbyxcbiAgICByZXNldDogaCxcbiAgICBpc0NvbXBsZXRlZDogbFxuICB9O1xufSwgWWEgPSAobikgPT4ge1xuICBjb25zdCB7XG4gICAgY2FsbDogZVxuICB9ID0gZWUodGUpLCBbdCwgcl0gPSBQKG51bGwpLCBbcywgaV0gPSBQKCExKSwgW28sIHVdID0gUChudWxsKSwgW2wsIGFdID0gUCghMSksIGggPSAkKCgpID0+IHtcbiAgICByKG51bGwpLCBpKCExKSwgdShudWxsKSwgYSghMSk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHtcbiAgICBjYWxsOiAkKGFzeW5jIChwKSA9PiAodShudWxsKSwgYSghMSksIGkoITApLCByKG51bGwpLCBlLmRlbGV0ZShuLCBwKS50aGVuKChtKSA9PiAocihtKSwgaSghMSksIGEoITApLCBtKSkuY2F0Y2goKG0pID0+IHtcbiAgICAgIHRocm93IGkoITEpLCBhKCExKSwgdShtKSwgbTtcbiAgICB9KSksIFtdKSxcbiAgICByZXN1bHQ6IHQsXG4gICAgbG9hZGluZzogcyxcbiAgICBlcnJvcjogbyxcbiAgICByZXNldDogaCxcbiAgICBpc0NvbXBsZXRlZDogbFxuICB9O1xufSwgemEgPSAoKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBmaWxlOiBuXG4gIH0gPSBlZSh0ZSksIFtlLCB0XSA9IFAoMCksIFtyLCBzXSA9IFAoITEpLCBbaSwgb10gPSBQKG51bGwpLCBbdSwgbF0gPSBQKCExKSwgYSA9ICQoYXN5bmMgKGYsIHAsIG0pID0+IChoKCksIHMoITApLCBuLnVwbG9hZEZpbGUoZiwgcCwgKGcsIGIpID0+IHQoTWF0aC5yb3VuZChnIC8gYiAqIDEwMCkpLCBtKS50aGVuKChnKSA9PiAobCghMCksIHQoMTAwKSwgcyghMSksIGcuZGF0YS5tZXNzYWdlKSkuY2F0Y2goKGcpID0+IHtcbiAgICB0aHJvdyBjb25zb2xlLmVycm9yKGcpLCBvKGcpLCBzKCExKSwgZztcbiAgfSkpLCBbXSksIGggPSAkKCgpID0+IHtcbiAgICB0KDApLCBzKCExKSwgbyhudWxsKSwgbCghMSk7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHtcbiAgICB1cGxvYWQ6IGEsXG4gICAgcHJvZ3Jlc3M6IGUsXG4gICAgbG9hZGluZzogcixcbiAgICBpc0NvbXBsZXRlZDogdSxcbiAgICBlcnJvcjogaSxcbiAgICByZXNldDogaFxuICB9O1xufSwgS2EgPSAobiwgZSwgdCA9IFtdLCByID0gMjAsIHMgPSAyNTApID0+IHtcbiAgY29uc3QgaSA9IFBhKGUsIHMpO1xuICByZXR1cm4gTmEoXCJmcmFwcGUuZGVzay5zZWFyY2guc2VhcmNoX2xpbmtcIiwge1xuICAgIGRvY3R5cGU6IG4sXG4gICAgcGFnZV9sZW5ndGg6IHIsXG4gICAgdHh0OiBpLFxuICAgIGZpbHRlcnM6IEpTT04uc3RyaW5naWZ5KHQgIT0gbnVsbCA/IHQgOiBbXSlcbiAgfSk7XG59LCBQYSA9IChuLCBlKSA9PiB7XG4gIGNvbnN0IFt0LCByXSA9IFAobik7XG4gIHJldHVybiBHZSgoKSA9PiB7XG4gICAgY29uc3QgcyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcihuKTtcbiAgICB9LCBlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJUaW1lb3V0KHMpO1xuICAgIH07XG4gIH0sIFtuLCBlXSksIHQ7XG59LCBCbiA9IChuLCBlKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBzb2NrZXQ6IHRcbiAgfSA9IGVlKHRlKTtcbiAgR2UoKCkgPT4ge1xuICAgIHQgPT09IHZvaWQgMCAmJiBjb25zb2xlLndhcm4oXCJTb2NrZXQgaXMgbm90IGVuYWJsZWQuIFBsZWFzZSBlbmFibGUgc29ja2V0IGluIEZyYXBwZVByb3ZpZGVyLlwiKTtcbiAgICBsZXQgciA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQub24obiwgZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHIgPT0gbnVsbCB8fCByLm9mZihuKTtcbiAgICB9O1xuICB9LCBbbiwgZV0pO1xufSwgR2EgPSAobiwgZSwgdCwgciA9ICEwKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBzb2NrZXQ6IHNcbiAgfSA9IGVlKHRlKSwgW2ksIG9dID0gUChbXSk7XG4gIEdlKCgpID0+IChzID09PSB2b2lkIDAgJiYgY29uc29sZS53YXJuKFwiU29ja2V0IGlzIG5vdCBlbmFibGVkLiBQbGVhc2UgZW5hYmxlIHNvY2tldCBpbiBGcmFwcGVQcm92aWRlci5cIiksIHMgPT0gbnVsbCB8fCBzLmVtaXQoXCJkb2Nfc3Vic2NyaWJlXCIsIG4sIGUpLCByICYmIChzID09IG51bGwgfHwgcy5lbWl0KFwiZG9jX29wZW5cIiwgbiwgZSkpLCAoKSA9PiB7XG4gICAgcyA9PSBudWxsIHx8IHMuZW1pdChcImRvY191bnN1YnNjcmliZVwiLCBuLCBlKSwgciAmJiAocyA9PSBudWxsIHx8IHMuZW1pdChcImRvY19jbG9zZVwiLCBuLCBlKSk7XG4gIH0pLCBbbiwgZSwgcl0pLCBCbihcImRvY191cGRhdGVcIiwgdCk7XG4gIGNvbnN0IHUgPSAkKCgpID0+IHtcbiAgICBzID09IG51bGwgfHwgcy5lbWl0KFwiZG9jX29wZW5cIiwgbiwgZSk7XG4gIH0sIFtuLCBlXSksIGwgPSAkKCgpID0+IHtcbiAgICBzID09IG51bGwgfHwgcy5lbWl0KFwiZG9jX2Nsb3NlXCIsIG4sIGUpO1xuICB9LCBbbiwgZV0pLCBhID0gJCgoaCkgPT4ge1xuICAgIGguZG9jdHlwZSA9PT0gbiAmJiBoLmRvY25hbWUgPT09IGUgJiYgbyhoLnVzZXJzKTtcbiAgfSwgW24sIGVdKTtcbiAgcmV0dXJuIEJuKFwiZG9jX3ZpZXdlcnNcIiwgYSksIHtcbiAgICB2aWV3ZXJzOiBpLFxuICAgIGVtaXREb2NPcGVuOiB1LFxuICAgIGVtaXREb2NDbG9zZTogbFxuICB9O1xufSwgWGEgPSAobiwgZSkgPT4ge1xuICBjb25zdCB7XG4gICAgc29ja2V0OiB0XG4gIH0gPSBlZSh0ZSk7XG4gIEdlKCgpID0+ICh0ID09PSB2b2lkIDAgJiYgY29uc29sZS53YXJuKFwiU29ja2V0IGlzIG5vdCBlbmFibGVkLiBQbGVhc2UgZW5hYmxlIHNvY2tldCBpbiBGcmFwcGVQcm92aWRlci5cIiksIHQgPT0gbnVsbCB8fCB0LmVtaXQoXCJkb2N0eXBlX3N1YnNjcmliZVwiLCBuKSwgKCkgPT4ge1xuICAgIHQgPT0gbnVsbCB8fCB0LmVtaXQoXCJkb2N0eXBlX3Vuc3Vic2NyaWJlXCIsIG4pO1xuICB9KSwgW25dKSwgQm4oXCJsaXN0X3VwZGF0ZVwiLCBlKTtcbn07XG5leHBvcnQge1xuICB0ZSBhcyBGcmFwcGVDb250ZXh0LFxuICBVYSBhcyBGcmFwcGVQcm92aWRlcixcbiAgTGEgYXMgZ2V0RG9jTGlzdFF1ZXJ5U3RyaW5nLFxuICBCcyBhcyBnZXRSZXF1ZXN0VVJMLFxuICBxYSBhcyB1c2VGcmFwcGVBdXRoLFxuICBqYSBhcyB1c2VGcmFwcGVDcmVhdGVEb2MsXG4gIFlhIGFzIHVzZUZyYXBwZURlbGV0ZUNhbGwsXG4gIE1hIGFzIHVzZUZyYXBwZURlbGV0ZURvYyxcbiAgWGEgYXMgdXNlRnJhcHBlRG9jVHlwZUV2ZW50TGlzdGVuZXIsXG4gIEdhIGFzIHVzZUZyYXBwZURvY3VtZW50RXZlbnRMaXN0ZW5lcixcbiAgQm4gYXMgdXNlRnJhcHBlRXZlbnRMaXN0ZW5lcixcbiAgemEgYXMgdXNlRnJhcHBlRmlsZVVwbG9hZCxcbiAgTmEgYXMgdXNlRnJhcHBlR2V0Q2FsbCxcbiAgSWEgYXMgdXNlRnJhcHBlR2V0RG9jLFxuICBXYSBhcyB1c2VGcmFwcGVHZXREb2NDb3VudCxcbiAgVmEgYXMgdXNlRnJhcHBlR2V0RG9jTGlzdCxcbiAgSGEgYXMgdXNlRnJhcHBlUG9zdENhbGwsXG4gIEphIGFzIHVzZUZyYXBwZVB1dENhbGwsXG4gICRhIGFzIHVzZUZyYXBwZVVwZGF0ZURvYyxcbiAgdnQgYXMgdXNlU1dSLFxuICBObyBhcyB1c2VTV1JDb25maWcsXG4gIEthIGFzIHVzZVNlYXJjaFxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/frappe-react-sdk/dist/frappe-react-sdk.es.js\n");

/***/ })

};
;